[[abilities/apexAcolyte.easel]]
.. glyph=Dna1:Glyph, color=#4400ff, amplifyProportion=0.15

pub symbol WantApexAcolyte

pub fn ApexAcolyteOption(.. ui) {
	SlotOption<WantApexAcolyte> {
		H1 { %("Apex Acolyte") }

		P {
			Span(italic=true) { %("Passive ability. ") }
			%("Your exceptional talents enable you to discern even the smallest frailties and vulnerabilities in your enemies. With surgical precision, you exploit these weaknesses, striking with unparalleled effectiveness, causing your enemies tremble in fear at your mere presence. ")
		}

		P {
			SlotEffect("Unparalleled Effectiveness", icon="fas fa-sword") {
				%("Permanently increase damage dealt by " + (amplifyProportion * 100) + "%.")
			}
		}
	}
}

pub fn ability.ApexAcolyteAbility(unit, owner, btn) {
	NoIncantation {
		DamageModifier(amplifyProportion)
	}
}
[[abilities/arcaneAgility.easel]]
.. glyph=Dodging:Glyph, color=#ff00aa, fastProportion=0.1

pub symbol WantArcaneAgility

pub fn ArcaneAgilityOption(.. ui) {
	SlotOption<WantArcaneAgility> {
		H1 { %("Arcane Agility") }

		P {
			Span(italic=true) { %("Passive ability. ") }
			%("Awaken the arcane fire within and achieve unparalleled nimbleness. Like a flickering flame, deftly dodge your adversaries' attacks as you glide across the battlefield with the fluidity and grace of a dancing inferno.")
		}

		P {
			SlotEffect("Flickering Swiftness", icon="fas fa-running") {
				%("Permanently increase movement speed by " + (fastProportion * 100) + "%.")
			}
		}
	}
}

pub fn ability.ArcaneAgilityAbility(unit, owner, btn) {
	NoIncantation {
		SpeedModifier(fastProportion)
	}
}
[[abilities/beam.easel]]
.. glyph=GlowingHands:Glyph, color=#44ddff, damage=150.0, duration=2s, lifesteal=0.3, cooldown=5.0s

pub symbol WantBeam

pub fn BeamOption(.. ui) {
	SlotOption<WantBeam> {
		H1 { %("Beam") }

		P {
			%("Harness the power of your indomitable focus to unleash a searing beam that obliterates all in its path. ")
		}

		P {
			SlotEffect("Interruptible", icon="fas fa-hand-paper") {
				%("Should you suffer a strike from a foe, the flow of energy will come to a sudden halt as your concentration fractures. ")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.BeamAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility(utility=Utility:High)
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		on BotChannelling target {
			let angleDelta = AngleDelta(unit.Heading, Angle(target - unit.Pos))
			if angleDelta.Abs() < 0.025rev { // Only keep firing the beam if they are still within range
				BotKeepChannelling
			}
		}

		SpeedModifier(-1)
		TurnRateModifier(-0.9999)
		CooldownRate(-1)

		once Interrupt {
			StopIncantation
		}

		Sing(Beam:ChargingSound)
		await ChargeForDuration(0.3s) {
			ChargingIndicator
		}

		Sing(Beam:ChannellingSound)
		await Barrage(interval=3, count=duration / interval) index {
			.. damage = damage / count

			Spawn projectile {
				.. parent=unit
				.. ownerColor=true
				.. lifetime=30, dissipation=6
				.. radius=0.4, speed=240
				.. density=0.01, ccd=true
				.. luminous=1.0, depth=Depth:Projectile
				.. categories = Category:Projectile | Category:Massive, durability=Durability:High

				LaunchBody
				PrepareForCollision
				PropulsiveMotion
				ExpireAfterLifetime

				Collider {
					Shape:Circle
				}

				RayEmitter(shadow=0, taper=0, diminish=0)

				let canHurtSelf = false
				on BeforeCollide that {
					if canHurtSelf || that.Team != owner.Team {
						Attack(that)

						that.Tombstone victim {
							NameBlock(owner)
							%(" incinerated ")
							NameBlock(victim)
							%(" into nothingness ")
						}
					}
				}
				on AfterCollide that {
					if that.Category & Category:Shield {
						canHurtSelf = true // Can bounce off shield to hurt self
					}
					if that.Durability >= this.Durability {
						Expire
					}
				}
			}
		}
	}
}

sound Beam:ChargingSound(duration=0.5s, cutoff=0.5s) {
	Oscillator(wave=$sawtooth, freq=[4,18], harmonics=[1,2.16,4.16,8.16])
	LowPass(freq=[20,250], q=1)
	Envelope(attack=0.49s, sustain=0s)
}

sound Beam:ChannellingSound(duration=0.25s, repeat=0.1s, cutoff=0.25s) {
	Oscillator(wave=$sawtooth, freq=[18,18.1], harmonics=[1,2.16,4.16])
	LowPass(freq=200, q=1)
	Envelope(attack=0.1s, release=0.15s)
}
[[abilities/blast.easel]]
.. glyph=FireRay:Glyph, color=#00ffff, damage=40.0, lifesteal=0.3, cooldown=5.0s

pub symbol WantBlast

pub fn BlastOption(.. ui) {
	SlotOption<WantBlast> {
		H1 { %("Blast") }

		P {
			%("Concentrate your inner reserves, unleashing a cataclysmic force proportional to the time spent in focused meditation. ")
		}

		P {
			SlotEffect("Luminous Convergence", icon="fas fa-hand-paper") {
				%("Hold the button to charge up your blast, and feel the pulsating layers of energy coalesce with each moment of pure concentration.")
			}
			SlotEffect("Interruptible", icon="fas fa-hand-paper") {
				%("A single blow can shatter your concentration, dissipating the accumulated energy and leaving your devastating assault unfulfilled.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.BlastAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. ownerColor=true, damage = damage * unit.DamageModifier

		const birth = Tick

		SpeedModifier(-0.5)

		once Interrupt { StopIncantation }

		if !HasCommenced {
			// Disallow pre-game charging to count during the real game
			once AfterCommence { StopIncantation }
		}

		on BotChannelling {
			const channelDuration=1.0s
			if Tick - birth < channelDuration {
				BotKeepChannelling
			}
		}

		Sing(Blast:ChargingSound)
		await ChargeUntilReleased(2.0s, minProportion=0.1) {
			ChargingIndicator(flicker=0.1)
			CooldownRate(-1)
		}

		Spawn projectile {
			.. parent=unit
			.. damage = damage * ChargeProportion
			.. radius = ChargeProportion.Mix(0.3, 1.2), speed=40.0
			.. aoe=2, impulse = 70 * ChargeProportion
			.. lifetime=2s, dissipation=7
			.. luminous=1.0, depth=Depth:Projectile
			.. feather=1, glare=0.5
			.. density = 140 * ChargeProportion, ccd=true
			.. categories = Category:Projectile | Category:Massive, durability=Durability:Maximum

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Sing(Blast:Sound)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			Bloom(bloom=10*ChargeProportion)
			Smoke(splatter=0.5, shadow=0.5)

			let canHurtSelf = false
			on BeforeCollide that {
				if canHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" farewelled ")
						NameBlock(victim)
						%(" with a bang ")
					}
				}
			}
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=0.5)
					Hear(Blast:HitSound)
					Expire
				}
			}
			once Expire {
				Puff(count=5, splatter=1)
				Aoe:ForEach that {
					if that.Team != owner.Team {
						Aoe:Impulse(that)
						Aoe:Destroy(that)
					}
				}
			}
		}
	}
}

sound Blast:ChargingSound(duration=5s, cutoff=0.5s) {
	Oscillator(wave=$triangle, freq=[4,9], harmonics=[1,2,2.5,4,5,8,10,16])
	Tremolo(volumeModulation=0.8) {
		Oscillator(freq=12)
	}
	Envelope(attack=0.25s, release=0.5s)
}

sound Blast:Sound(duration=1s, cutoff=0.5s) {
	BrownNoise
	LowPass(freq=[8500,2125], q=1)
	Output(into=$mix)

	Input(key=$mix)
	Envelope(attack=0.1s, sustain=0s)
}

sound Blast:HitSound(duration=2s) {
	BrownNoise
	LowPass(freq=500)
	HighPass(freq=100)
	Envelope(attack=0.01s, sustain=0s, release=0.85s)
	Output

	Oscillator(wave=$triangle, freq=[50,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=300)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/blaze.easel]]
.. glyph=FireWave:Glyph, color=#ff00cc, damage=10, lifesteal=0.3, speed=64, cooldown=10.0s

pub symbol WantBlaze

pub fn BlazeOption(.. ui) {
	SlotOption<WantBlaze> {
		H1 { %("Blaze") }

		P {
			%("Perform a swift, incendiary dash, setting the battlefield ablaze as you surge through your adversaries. Harness this blazing velocity to skillfully evade peril or bridge distances, adeptly maneuvering yourself into favorable positions amidst the chaos of combat.")
		}

		P {
			SlotEffect("Incendiary Traversal", icon="fas fa-bolt") {
				%("While dashing, you may pass through obstacles and enemies.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.BlazeAbility(unit, owner, btn) {
	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility(utility=Utility:Low)
		}
	}

	Incantation {
		.. lifetime=7
		.. radius=0.5, dissipation=12
		.. ownerColor=true, depth=Depth:Projectile
		.. shine=1.0, glare=0.7, bloom=3.0, luminous=1.0

		SpeedModifier(-1) // Don't allow other movement to interfere with the charge
		Tangibility(Category:Shield) // Pass through everything except shields
		SenseAlso(Category:Hero) // Sense units while charging so we can apply damage but don't collide with them
		Sing(Blaze:Sound)

		// Set the new target to be the same as where we're charging towards.
		// This is to stop the unit walking backwards after the thrust is complete when using click-to-move
		Movement:WalkTo(Pointer)
		Proximity:OnArrival(Pointer) {
			StopIncantation
		}

		hook Pointer {
			Thrust(Pointer, speed=)
		}

		on unit.BeforeCollide that {
			if that.Team != owner.Team {
				Attack(that)

				that.Tombstone victim {
					NameBlock(owner)
					%(" charred ")
					NameBlock(victim)
					%(" to ash")
				}
			}
		}

		hook Tick {
			Spawn trail {
				.. parent=unit

				LaunchBody(speed=0)
				Smoke(interval=3, splatter=Splatter:Outwards(12, glide=0.15), bloom=1.5)
				ExpireAfterLifetime(7)
			}
		}

		await Sleep(lifetime)
	}
}

sound Blaze:Sound(duration=0.5s, cutoff=0.25s) {
	BrownNoise
	BandPass(freq=[300,400], q=5)
	Envelope(attack=0.05s, sustain=0s)
}
[[abilities/boomerang.easel]]
.. glyph=CrackedBallDunk:Glyph, color=#00ffff, damage=20.0, lifesteal=0.3, cooldown=2s, secondStrikeBonus=0.25

pub symbol WantBoomerang

pub fn BoomerangOption(.. ui) {
	SlotOption<WantBoomerang> {
		H1 { %("Boomerang") }

		P {
			%("Send forth a projectile that slices through the air before returning to your hand. With the potential to strike enemies twice, Boomerang becomes a fearsome weapon in the hands of a skilled wielder.")
		}

		P {
			SlotEffect("Second Strike", icon="fas fa-sword") {
				%("The second strike of Boomerang, if successfully landed, delivers an additional " + (secondStrikeBonus * 100) + "% damage, capitalizing on the vulnerability left by the first strike.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.BoomerangAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit
			.. lifetime=2s, dissipation=25
			.. radius=0.16, speed=53.0
			.. ownerColor=true, luminous=1.0, depth=Depth:Projectile
			.. density=1, ccd=true
			.. categories=Category:Projectile, durability=Durability:High
			.. sense = Category:Hero | Category:Projectile, collideWith = Category:Shield | Category:Obstacle
			.. noLavasteal=true // Not enough knockback to push others into lava

			LaunchBody
			PrepareForCollision
			DriftingMotion
			RayEmitter(fade=0.5)
			Sing(Boomerang:Sound)
			ExpireAfterLifetime

			once<redirect> Sleep(33) {
				Velocity:RedirectTowards(unit.Pos, speed=)
				PropulsiveMotion
				Homing(unit)
			}

			Collider(restitution=0) {
				Shape:Circle
			}

			on BeforeCollide that {
				if that == unit {
					// The boomerang has returned, time to expire
					Expire
				}

				if that.Team != owner.Team {
					if that.Category & Category:Hero {
						Strobe(growth=2, shine=1.0)
						that.StackBuff<boomerang>(cleansable=true, maxStacks=1) stacks {
							ExpireWith(projectile)
							Attack(that, damage * (1.0 + secondStrikeBonus * stacks))
							Hear(Boomerang:HitSound)
							BloomIndicator(that, audience=owner)

							that.Tombstone victim {
								NameBlock(owner)
								%(" sliced ")
								if stacks > 0 {
									%("and diced ")
								}
								NameBlock(victim)
							}
						}
					} else {
						Attack(that)
					}
				}

				if (that.Category & Category:Projectile) && that.Durability >= this.Durability {
					Strobe(growth=2, shine=1.0)
					Expire
				}
			}
		}
	}
}

sound Boomerang:Sound(duration=1.5s) {
	BrownNoise
	BandPass(freq=1900)
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.25)
	Output

	Vibrato(freqModulation=300) {
		Oscillator(freq=2000)
	}
	Oscillator(wave=$sine, freq=1900, harmonics=[1,1.5])
	Tremolo(volumeModulation=1.0) {
		Oscillator(freq=21)
	}
	LowPass(freq=400)
	Envelope(attack=0.01s, sustain=0s)
}

sound Boomerang:HitSound(duration=0.3s) {
	Vibrato(freqModulation=2400) {
		Oscillator(freq=2000)
	}
	Oscillator(wave=$sine, freq=1900, harmonics=[1,1.5])
	Tremolo(volumeModulation=1.0) {
		Oscillator(freq=21)
	}
	LowPass(freq=125)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/bouncer.easel]]
.. glyph=Divert:Glyph, color=#00ff44, damage=12, maxHits=8, lifesteal=0.3, cooldown=7.5s


pub symbol WantBouncer

pub fn BouncerOption(.. ui) {
	SlotOption<WantBouncer> {
		H1 { %("Bouncer") }

		P {
			%("Release a pulsing energy orb that oscillates relentlessly between you and your foe, inflicting damage with each successive impact. ")
			%("Stay close to sustain the perilous waltz that balances the risk of exposure with the promise of persistent punishment. ")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.BouncerAbility(unit, owner, btn) {
	on BotAttacking target {
		const triggerDistance=5
		if Cooldown == 0 && Distance(unit.Pos, target) <= triggerDistance {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit 
			.. lifetime=3.0s, dissipation=20
			.. radius=0.08, speed=50.0
			.. ownerColor=Alliance:Self, luminous=1.0, depth=Depth:Projectile
			.. density=15, ccd=true
			.. categories=Category:Projectile, durability=Durability:High
			.. collideWith = Category:Solid ^ Category:Projectile

			on BotChannelling target {
				const chaseDistance=10
				if Distance(projectile.Pos, target) <= chaseDistance {
					BotKeepChannelling
				}
			}

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Sing(Bouncer:Sound)
			ExpireAfterLifetime

			Proximity:OnRetreat(unit, range=50) {
				Expire
			}

			Collider {
				Shape:Circle
			}
			Sprite(shadow=0.5, glare=1, bloom=1.5, bloomAlpha=1) {
				Shape:Circle(radius=5.0 * radius)
			}

			let numHits = 0
			let canHurtSelf = false
			on BeforeCollide that {
				Hear(Bouncer:BounceSound)
				Strobe(dissipation=10, growth=1.0)

				if canHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" bounced ")
						NameBlock(victim)
						%(" out of existence ")
					}
				}
			}
			on AfterCollide that {
				if that == unit {
					Velocity:RedirectTowards(QueryUnits.WhereAlliance(unit, Alliance:Enemy).FindNearest(this.Pos))
				} else if Alliance(that, unit) & Alliance:Enemy {
					numHits += 1
					Velocity:RedirectTowards(unit)
				}

				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if (that.Category & Category:Projectile) && that.Durability >= this.Durability || numHits >= maxHits {
					Expire
				}
			}

			once Expire {
				Puff(radius=5.0 * radius, count=10, splatter=1, feather=1)
			}
		}
	}
}

sound Bouncer:Sound(duration=0.75s) {
	Oscillator(wave=$square, freq=70)
	LowPass(freq=120)
	HighPass(freq=40)
	Tremolo(volumeModulation=0.5) {
		Oscillator(freq=6)
	}
	Envelope(attack=0.1s, sustain=0s)
}

sound Bouncer:BounceSound(duration=0.25s) {
	Oscillator(wave=$square, freq=[70,140])
	LowPass(freq=120)
	HighPass(freq=40)
	Envelope(attack=0.001s, sustain=0s)
}
[[abilities/charge.easel]]
.. glyph=FireDash:Glyph, color=#ff00cc, damage=0, speed=120, cooldown=10.0s

pub symbol WantCharge

pub fn ChargeOption(.. ui) {
	SlotOption<WantCharge> {
		H1 { %("Charge") }

		P {
			%("Charge forward with thunderous force, knocking away anything in your path.")
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.ChargeAbility(unit, owner, btn, btnIndex?, btnSize) {
	hook IsInLava {
		CooldownRate(IsInLava ? 1.0 : 0.0)
	}

	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. lifetime=16
		.. radius=1.5, dissipation=12
		.. ownerColor=true, depth=Depth:Projectile
		.. shine=1.0, glare=0.7, bloom=3.0, luminous=1.0

		CleanseBuffs
		SeverTethers
		Sing(Charge:Sound)

		// Set the new target to be the same as where we're charging towards.
		// This is to stop the unit walking backwards after the thrust is complete when using click-to-move
		Movement:WalkTo(Pointer)
		
		// Don't allow other movement to interfere with the charge
		SpeedModifier(-1)
		DensityModifier(140)
		SizeModifier(0.5)
		Thrust(Pointer, speed=)
		RayEmitter(fade=1, shadow=0.5)

		Proximity:OnArrival(Pointer) {
			StopIncantation
		}

		on unit.BeforeCollide that {
			Attack(that)

			that.Tombstone victim {
				NameBlock(owner)
				%(" smashed ")
				NameBlock(victim)
				%(" with thunderous force ")
			}
		}

		await Sleep(lifetime)
	}
}

sound Charge:Sound(duration=0.25s) {
	BrownNoise
	LowPass(freq=600)
	Envelope(attack=0.05s, sustain=0s)
}
[[abilities/clickToMove.easel]]
pub symbol WantClickToMove

pub fn ability.ClickToMoveAbility(unit, owner) {
	CommandBinding("Click")

	on ability.InvokeCommand {
		await Subscope {
			// While holding down the button, follow cursor
			hook Pointer {
				Movement:WalkTo(Pointer)
			}

			// Delay the button is released, stop
			await ability.ReleaseCommand
		}
	}
}
[[abilities/difire.easel]]
.. glyph=CrossedSlashes:Glyph, color=#ff0088, damage=20.0
.. numBolts=2, buffDuration=4s, lifesteal=0.3, cooldown=1.5s

pub symbol WantDifire

pub fn DifireOption(.. ui) {
	SlotOption<WantDifire> {
		H1 { %("Difire") }

		P {
			%("Unleash twin bolts of scorching flame that ignite and inflict a prolonged burn. Additional Difire bolts intensify the burn, but only if used before the flames subside.")
		}

		P {
			SlotEffect("Stacking Burn", icon="fas fa-flame") {
				const boltDps = damage / (buffDuration / TicksPerSecond) / numBolts
				%("Each bolt of Difire will add another stack of " + boltDps + " damage per second to your enemy. ")
				%("You must hit them with Difire at least once every " + (buffDuration / TicksPerSecond) + " seconds to keep the fire burning. ")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.DifireAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		await Spray(duration=1, count=numBolts, spray=0.125revs) headingOffset {
			.. damage = damage / count

			Spawn projectile {
				.. parent=unit
				.. lifetime=1.5s, dissipation=15
				.. radius=0.2, speed=52.5
				.. density=10, ccd=true
				.. luminous=1.0, depth=Depth:Projectile
				.. categories=Category:Projectile, durability=Durability:Medium

				const initialCursor = Pointer

				LaunchBody(headingOffset=, speed=60)
				PrepareForCollision
				PropulsiveMotion
				RayEmitter(dissipation=8, shadow=0.25)
				Sing(Difire:Sound)
				ExpireAfterLifetime

				once<redirect> Sleep(2) {
					PropulsiveMotion(0.05, speed=)
					Velocity:RedirectTowards(initialCursor, speed=)
				}

				Collider {
					Shape:Circle
				}

				let canHurtSelf = false
				on BeforeCollide that {
					if canHurtSelf || that.Team != owner.Team {
						Attack(that, damage=0) // All damage is done by Poison, not this - this is to do other things like interrupt the enemy
						if that.HasHp {
							that.StackBuff<burning>(cleansable=true, maxStacks=(that.Category & Category:Hero ? 99 : 0)) stacks {
								ExpireAfterLifetime(buffDuration)
								Poison(that, damage * (stacks + 1), buffDuration)
								Smoke(that,
									radius=1.0, depth=Depth:Particle,
									color=color.WithOpacity(0.15 + 0.1 * stacks), fade=1,
									flutter=$perimeter, splatter=Splatter:Outwards(12))

								that.Tombstone victim {
									NameBlock(owner)
									%(" ignited ")
									NameBlock(victim)
									if stacks > 0 {
										%(" and watched them burn ")
									}
								}
							}
						}
					}
				}
				on AfterCollide that {
					if that.Category & Category:Shield {
						canHurtSelf = true // Can bounce off shield to hurt self
					}
					if that.Durability >= this.Durability && !((that.Category & Category:Projectile) && (that.Owner == this.Owner)) {
						Strobe(shine=1.0)
						Puff(count=5, splatter=1, dissipation=30)
						Hear(Difire:HitSound)
						Expire
					}
				}
			}
		}
	}
}

sound Difire:Sound(duration=1.5s) {
	BrownNoise
	BandPass(freq=735, q=[5,15])
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.5)
}
sound Difire:HitSound(duration=0.33s) {
	Oscillator(wave=$square, freq=[100,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=250)
	Envelope(attack=0.01s, decay=0.1s, sustainVolume=0.3, sustain=0s)
}
[[abilities/drain.easel]]
.. glyph=EnergyBreath:Glyph, color=#22ee88, damage=15, lifesteal=1.0, cooldown=5.0s

pub symbol WantDrain

prop projectile.Repossessor

pub fn DrainOption(.. ui) {
	SlotOption<WantDrain> {
		H1 { %("Drain") }

		P {
			%("From the depths of your soul, release a spectral wisp of energy which hungrily seeks out the life force of your foes, rejuvenating your own being with each stolen spark.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.DrainAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit
			.. radius=0.16, speed=16
			.. lifetime=2s, dissipation=15
			.. luminous=1.0, depth=Depth:Projectile
			.. density=2.8, ccd=true
			.. categories=Category:Projectile, durability=Durability:Low

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			RayEmitter(radius * 1.5, shadow=0.5)
			Sing(Drain:Sound)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			once<redirect> Sleep(Velocity:TicksTo(Pointer)) {
				.. owner = Repossessor ?? owner // lookup latest owner in case of repossession
				Velocity:RedirectTowards(QueryUnits.WhereAlliance(owner, Alliance:Enemy).FindNearest(this.Pos))
			}

			let canHurtSelf = false
			on BeforeCollide that {
				.. owner = Repossessor ?? owner // lookup latest owner in case of repossession
				if canHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" sapped the life from ")
						NameBlock(victim)
					}
				}
			}
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
					this.Repossessor = that.Owner // Now the new owner can receive the lifesteal
				}
				if that.Durability >= this.Durability {
					Strobe(growth=1.0, shine=1.0)
					Puff(count=4, splatter=1)
					Expire
				}
			}
		}
	}
}

sound Drain:Sound(duration=2s) {
	BrownNoise
	BandPass(freq=2500, q=10)
	Envelope(attack=0.25s, sustain=0s)
	Output

	Oscillator(wave=$square, freq=275, harmonics=[1, 1.33, 1.5])
	BandPass(freq=[600,800], q=15)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=10)
	}
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.5)
}
[[abilities/dualSaber.easel]]
.. glyph=WaveStrike:Glyph, color=#ff0000, damage=0, cooldown=7.5s, lifetime=1.5s, length=5.5

pub symbol WantDualSaber

pub fn DualSaberOption(.. ui) {
	SlotOption<WantDualSaber> {
		H1 { %("Dualsaber") }

		P {
			%("Wield formidable twin sabers forged from pure light. The incandescent blades can expertly parry incoming projectiles and forcefully knock back your enemies with each swift and decisive strike. ")
		}

		P {
			SlotEffect("Dual Wield", icon="fas fa-swords") {
				%("Though each saber may be shorter than a solitary counterpart, their combined presence doubles the odds of delivering a decisive strike against your adversaries.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.DualSaberAbility(unit, owner, btn) {
	on BotAttacking target {
		if Cooldown == 0 && Distance(target, unit.Pos) <= length {
			BotUseAbility
		}
	}

	Incantation {
		on Interrupt interruptor {
			if interruptor & Interruptor:Self {
				StopIncantation
			}
		}

		on BotChannelling target {
			if Distance(target, unit.Pos) <= length {
				BotKeepChannelling(spin=true)
			}
		}

		Subspawn saber {
			.. parent=unit
			.. dissipation=10, luminous=1.0
			.. radius=0.25, angleOffset=0.25rev
			.. ccd=true
			.. categories=Category:Shield, durability=Durability:Shield
			.. depth=Depth:Saber
			.. fade=1, shadow=0.25, luminous=1, glare=1, glareAlpha=1, bloom=4, bloomAlpha=1

			PrepareForCollision
			SynchronizeBody
			Sing(DualSaber:Sound)
			SpeedModifier(-0.25)
			TurnRateModifier(-0.95)

			// Main saber collider is actually attached to the unit's body, which means it will transmit forces back onto the unit (e.g. recoil)
			Collider(unit, collideWith=Category:Hero, density=2.5) {
				// Deflector is attached to the saber's independent body so projectiles cannot knock the unit back through the saber
				Collider<deflector>(collideWith=Category:Projectile, density=5.0) {
					// Sprite is attached to the unit (not the independent deflector body) so it does not visually lag behind
					Sprite(unit, shadow=) {
						Shape:Capsule(extent=length, posOffset=@(0,0), angleOffset=)
					}
				}
			}
			
			SwoopEmitter(radius=length, depth=depth+1, angleOffset=)
			SwoopEmitter<back>(radius=length, depth=depth+1, angleOffset = -angleOffset)

			on Movement:Turned step {
				// A strong swing will detach any tethers
				if Abs(step) > 0.05rev {
					SeverTethers
				}
			}

			on Hurt {
				Strobe(dissipation=10, shine=1.0)
			}

			on BeforeCollide that { // Main collider hits units
				Hear(DualSaber:HitSound)

				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" slashed ")
						NameBlock(victim)
						%(" into bite-sized pieces ")
					}

					await Sleep(0.25s)
					StopIncantation
				}
			}

			on BeforeCollide<deflector> that { // Secondary collider hits projectiles only
				Hear(DualSaber:HitSound)
				if that.Category & Category:Destructible { that.Expire }
			}
		}

		await Sleep(lifetime)
	}
}

sound DualSaber:Sound(duration=5s) {
	Vibrato(freqModulation=1) {
		Oscillator(freq=[5,4])
	}
	Oscillator(wave=$square, freq=15.3, harmonics=[1,2,4,8,16])
	LowPass(freq=100)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=7)
	}
	Envelope(attack=0.15s, sustain=0s)
	Gain(volume=0.25s)
}

sound DualSaber:HitSound(duration=0.5s) {
	Vibrato(freqModulation=100) {
		Oscillator(freq=200)
	}
	Oscillator(wave=$sine, freq=100)
	LowPass(freq=100)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/electroshock.easel]]
.. glyph=ElectricWhip:Glyph, color=#ffaa00
.. damage=32.0, lifesteal=1.0, cooldown=1.5s, lifetime=4, speed=80.0, fastProportion=0.2, buffDuration=3s

pub symbol WantElectroshock

pub fn ElectroshockOption(.. ui) {
	SlotOption<WantElectroshock> {
		H1 { %("Electroshock") }

		P {
			%("Shock your enemies at short-range, siphoning away their vitality through the conduit of crackling electricity. ")
			%("The surge of lightning through your veins also quickens your movement. ")
		}

		P {
			SlotEffect("Surging Swiftness", icon="fas fa-running") {
				%("Move " + (fastProportion * 100) + "% faster for " + (buffDuration / TicksPerSecond) + " seconds, even if you miss.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.ElectroshockAbility(unit, owner, btn) {
	on BotAttacking target {
		const chaseDistance = speed * lifetime / TicksPerSecond

		if Cooldown == 0 {
			BotUseAbility

		} else {
			// Chase down our enemies
			let chase = target + chaseDistance * Direction(unit.Pos - target)
			BotMoveTo(chase, utility=Utility:Minimum)
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		SpeedModifier(-1)
		TurnRateModifier(-1)

		await ChargeForDuration(3) {
			ChargingIndicator
		}

		unit.ReplaceBuff<electroshock:fast> {
			SpeedModifier(fastProportion)
			ExpireAfterLifetime(buffDuration)

			hook Vanished {
				if Vanished {
					delete Smoke
				} else {
					Smoke(
						color=color.Fade(0.8), ownerColor=true, luminous=1,
						radius=1.0, depth=Depth:Buff,
						splatter=Splatter:Outwards(5.0),
						feather=0, fade=1, dissipation=30)
				}
			}
		}

		Hear(Electroshock:Sound)
		Spawn projectile {
			.. parent=unit
			.. dissipation=30 
			.. radius=0.4, aoe=1.0, impulse=142
			.. color=#fffcb1, luminous=1.0, depth=Depth:Projectile
			.. density=2.8, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium
			.. collideWith = Category:Shield | Category:Obstacle

			LaunchBody
			PrepareForCollision
			DriftingMotion
			Movement:WalkWith(unit)
			Smoke(splatter=0.15, feather=1)
			Tether(ancestor=unit, taper=1)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			let canHurtSelf = false
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Expire
				}
			}
			once Expire {
				Explosion(aoe)
				Puff(count=7, feather=1, splatter=0.2, flicker=0.25)
				Hear(Electroshock:HitSound)

				Aoe:ForEach that {
					if canHurtSelf || that.Team != owner.Team {
						Attack(that)
						Aoe:Impulse(that)
						Aoe:Destroy(that)

						that.Tombstone victim {
							NameBlock(owner)
							%(" zapped ")
							NameBlock(victim)
						}
					}
				}
			}
		}
	}
}

sound Electroshock:Sound(duration=0.25s) {
	Vibrato(freqModulation=3600) {
		Oscillator(freq=30)
	}
	Oscillator(wave=$triangle, freq=[4800,7200], harmonics=[1,1.33,1.5])
	Tremolo(volumeModulation=[0.2,0]) {
		Oscillator(freq=30)
	}
	Envelope(attack=0.05s, sustain=0s)
	Gain(volume=0.1)
}

sound Electroshock:HitSound(duration=0.15s) {
	Vibrato(freqModulation=[6000,300]) {
		Oscillator(freq=[20,10])
	}
	Oscillator(wave=$triangle, freq=3000, harmonics=[1,1.2,1.4,1.6,1.8,2.4,2.8,3.2,3.6])
	Tremolo(volumeModulation=0.2) {
		Oscillator(freq=3)
	}
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.2)
}
[[abilities/energyMines.easel]]
.. glyph=MineExplosion:Glyph, color=#ff009c, damage=12.0, lifesteal=0.3, cooldown=5.0s, armDelay=8, retreatDelay=1s

pub symbol WantEnergyMines

pub fn EnergyMinesOption(.. ui) {
	SlotOption<WantEnergyMines> {
		H1 { %("Energy Mines") }

		P {
			%("Mark your territory with solid ingots of volatile energy, protecting you from all who dare come too close.")
		}

		P {
			SlotEffect("Stabilizing Presence", icon="fas fa-anchor") {
				%("Your sustained presence stabilizes the mines' volatile energy. Stray too far and they will expire.")
			}
			SlotEffect("Arming Delay", icon="fas fa-stopwatch") {
				%("Energy mines take a moment to activate and only do damage after " + (armDelay / TicksPerSecond) + "s.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.EnergyMinesAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier
	
		TurnRateModifier(-1)

		Hear(Mines:LaunchSound)
		await Spray(duration=5, count=5, spray=0.35revs) {
			Spawn projectile {
				.. parent=unit
				.. lifetime=4.5s, dissipation=15
				.. radius=0.32, speed=40.0, impulse=75, aoe=1.2
				.. density=1.5, ccd=true
				.. ownerColor=Alliance:Self, bloom=1.5, bloomAlpha=0.3, luminous=1.0, depth=Depth:Projectile
				.. categories = Category:Projectile | Category:Destructible | Category:AlwaysBlow, durability=Durability:None
				.. sense=Category:Projectile

				LaunchBody
				PrepareForCollision
				DriftingMotion
				ExpireAfterLifetime

				Sprite(shadow=0.5) {
					Collider {
						Shape:Circle
					}
				}

				let armed = false
				on BeforeCollide that {
					if that.Durability >= this.Durability && !(that.Owner == this.Owner && !(that.Category & Category:Hero)) {
						// Expire on everything unless it is an entity owned by the same player but not the hero.
						// This lets us push mines around with meteors, for example.
						Strobe(shine=1.0)
						Expire
					}
				}

				once Expire {
					Explosion(1.2, shine=1.0)
					Hear(Mines:HitSound)

					Aoe:ForEach that {
						if that.Team != owner.Team {
							Attack(that, armed ? damage : 1)
							Aoe:Impulse

							that.Tombstone victim {
								NameBlock(owner)
								%(" blew ")
								NameBlock(victim)
								%("'s mined")
							}
						}
					}
				}

				once<arm> Sleep(armDelay) {
					armed = true
					Speed = 0
					DecayingMotion
				}

				once<retreat> Sleep(retreatDelay) {
					Proximity:OnRetreat(unit, range=12) {
						Expire
					}
				}
			}
		}
	}
}

sound Mines:LaunchSound(duration=0.17s) {
	Vibrato(freqModulation=[3000,12588]) {
		Oscillator(freq=30)
	}
	Oscillator(wave=$triangle, freq=[6000,6400], harmonics=[1, 1.33, 1.5])
	Tremolo(volumeModulation=0.2) {
		Oscillator(freq=30)
	}
	Envelope(attack=0.05s, release=0.05s)
	Gain(volume=0.1)
}

sound Mines:HitSound(duration=1s) {
	Oscillator(wave=$triangle, freq=[50,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=[300,0])
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/ensnare.easel]]
.. glyph=AtomicSlashes:Glyph, color=#0ace00, damage=0.0, cooldown=6s, silenceDuration=0.5s, ensnareDuration=2s

pub symbol WantEnsnare

signal projectile.OnEnsnare(that);

pub fn EnsnareOption(.. ui) {
	SlotOption<WantEnsnare> {
		H1 { %("Ensnare") }

		P {
			%("Trap your adversaries in an inescapable vortex of mystic energy, leaving them immobilized. Seize the moment to unleash a barrage of your deadliest abilities as they lay helpless before you.")
		}

		P {
			SlotEffect("Mystic Silence", icon="fas fa-hourglass-half") {
				%("Your enemy will be unable to use their abilities for " + (silenceDuration / TicksPerSecond) + " seconds.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.EnsnareAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. lifetime=1.5s, dissipation=15
			.. radius=0.5, aoe=3.6, speed=28
			.. luminous=1.0, depth=Depth:Buff
			.. categories=Category:Projectile
			.. isSensor=true, collideWith=Category:Hero

			ExpireAfterLifetime
			LaunchBody
			PrepareForCollision
			DriftingMotion
			CooldownRate(-1)
			Sing(Ensnare:Sound)
			Smoke(
				flutter=Flutter:Swirl(0.2,period=20),
				feather=1, glare=0.4, bloom=1.5,
				splatter=Splatter:Outwards(5.5,glide=0.3),
				shadow=0.5)

			Collider {
				Shape:Circle
			}
			
			on BeforeCollide that {
				if that.Owner != owner {
					ExpireAfterLifetime(ensnareDuration) // Re-extend lifetime if we catch something

					that.Silence(silenceDuration)
					that.Tombstone victim {
						NameBlock(owner)
						%(" held ")
						NameBlock(victim)
						%(" til the end ")
					}

					OnEnsnare(that)
					break // Only catch the first unit that enters the vortex, otherwise could extend lifetime forever
				}
			}

			once<deploy> Sleep(Velocity:TicksTo(Pointer)) {
				OnEnsnare(null)
			}

			// Plant the vortex either when the projectile reaches the cursor or when it catches a unit
			once OnEnsnare that {
				Speed = 0
				Sing(Ensnare:TrappingSound)

				hook<attractor> Tick {
					Aoe:ForEach(filter=Category:Hero) that {
						Aoe:ImpulseAttenuated(that, impulse=-5.0, attenuate=0.4)
					}
				}

				await Tween(duration=5, initial=0.0, final=1.0) factor {
					.. aoe = factor * aoe

					Smoke(
						count=3, radius=0.5, flutter=Flutter:Swirl(factor * 1.6, period=20),
						feather=1, glare=0.4, bloom=1.5,
						splatter=Splatter:Outwards(5.5,glide=0.3),
						shadow=0.5)
				}
			}
		}
	}
}

sound Ensnare:Sound(duration=1.5s, cutoff=0.5s) {
	Oscillator(wave=$sawtooth, freq=410, harmonics=[1,1.33,1.4,1.5])
	LowPass(freq=100)
	Envelope(attack=0.05s, sustain=0s)
	Gain(volume=0.5)
}

sound Ensnare:TrappingSound(duration=8s) {
	Oscillator(wave=$sawtooth, freq=[410,415], harmonics=[1,1.33,1.4,1.5])
	LowPass(freq=100)
	Tremolo(volumeModulation=0.6) {
		Oscillator(freq=12)
	}
	Envelope(attack=0.25s)
}
[[abilities/fireball.easel]]
.. glyph=Thunderball:Glyph, color=#ff8800, damage=16.0, lifesteal=0.3, cooldown=1.5s

pub symbol WantFireball

pub fn FireballOption(.. ui) {
	SlotOption<WantFireball> {
		H1 { %("Fireball") }

		P {
			%("From your outstretched hand, a fierce, blazing orb of fire hurtles forward, sending enemies tumbling backward. With its short cooldown, you can unleash this swift and reliable spell time and time again.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.FireballAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit 
			.. lifetime=90, dissipation=30 
			.. radius=0.24, speed=48.0
			.. luminous=1.0, depth=Depth:Projectile
			.. density=30.5, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Smoke(splatter=0.15)
			RayEmitter
			ExpireAfterLifetime
			Sing(Fireball:Sound)

			Collider {
				Shape:Circle
			}

			let canHurtSelf = false
			on BeforeCollide that {
				if canHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" scorched ")
						NameBlock(victim)
					}
				}
			}
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}

				if that.Durability >= this.Durability {
					Strobe(growth=0.5, shine=1.0)
					Puff(count=10, splatter=1)
					Hear(Fireball:HitSound)
					Expire
				}
			}
		}
	}
}

sound Fireball:Sound(duration=1.5s, cutoff=0.5s) {
	BrownNoise
	BandPass(freq=[220,330], q=[1,5])
	Envelope(attack=0.25s, release=0.5s)
}

sound Fireball:HitSound(duration=1s) {
	Vibrato(freqModulation=350) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=40)
	LowPass(freq=[500,0], q=1)
	Peaking(freq=165, db=12)
	Envelope(attack=0.01s, decay=0.05s, sustain=0s, sustainVolume=0.2)
}
[[abilities/fireboom.easel]]
.. glyph=BurningDot:Glyph, color=#ff4400
.. damage=10.0, lifesteal=0.3, cooldown=1.5s, maxScale=3, growthDuration=1.0s

pub symbol WantFireboom

pub fn FireboomOption(.. ui) {
	SlotOption<WantFireboom> {
		H1 { %("Fireboom") }

		P {
			%("Conjure a searing ball of flame that detonates upon impact, engulfing enemies within its fiery radius. Fireboom may be slow, but its wide blast zone leaves few places for your enemies to hide. ")
		}

		P {
			SlotEffect("Intensifying Inhalation", icon="fas fa-flame") {
				%("Fireboom begins life as a tiny ember, then grows to " + maxScale + "x damage over " + (growthDuration / TicksPerSecond) + " second. Cultivate Fireboom's full potential by launching it from afar and giving time for the fiery orb to breathe.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.FireboomAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit 
			.. aoe = 2.88 / maxScale, radius = 0.4 / maxScale
			.. impulse=107, speed=18.4
			.. lifetime=2s, dissipation=18
			.. luminous=1.0, depth=Depth:Projectile
			.. density=7.0, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Sing(Fireboom:Sound)
			ExpireAfterLifetime(Velocity:TicksTo(Pointer).Min(lifetime))

			Collider {
				Shape:Circle
			}

			let canHurtSelf = false
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(shine=1.0)
					Expire
				}
			}

			await Tween(duration=growthDuration, initial=1, final=maxScale) factor {
				.. aoe = aoe * factor, radius = radius * factor, damage = damage * factor

				RayEmitter
				Smoke(splatter=0.4)
				Aoe:Indicator(aoe, color=Fade(color, 0.95))

				once Expire {
					Puff(count=10, splatter=Splatter:Outwards(10))
					Explosion(aoe)
					Hear(Fireboom:ExplodeSound)

					Aoe:ForEach that {
						if canHurtSelf || that.Team != owner.Team {
							Attack(that)
							Aoe:Impulse(that)
							Aoe:Destroy(that)

							that.Tombstone victim {
								NameBlock(owner)
								%(" combusted ")
								NameBlock(victim)
								if factor >= 1.0 {
									%(" from afar ")
								}
							}
						}
					}
				}
			}
		}
	}
}


sound Fireboom:Sound(duration=1.5s, cutoff=0.5s) {
	BrownNoise
	BandPass(freq=[140,280], q=[1,5])
	Gain(volume=0.67)
	Output(into=$mix)

	BrownNoise
	BandPass(freq=[280,560], q=[1,5])
	Gain(volume=0.33)
	Output(into=$mix)

	Input(key=$mix)
	Envelope(attack=0.25s, release=0.5s)
}

sound Fireboom:ExplodeSound(duration=1s) {
	Vibrato(freqModulation=2500) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=160)
	LowPass(freq=[280,0])
	HighShelf(freq=[140,0], db=-6)
	Peaking(freq=70, q=1, db=6)
	Envelope(attack=0.03s, decay=0.1s, sustain=0s, sustainVolume=0.2)
	Gain(volume=0.67)
}
[[abilities/firesplatter.easel]]
.. glyph=BubblingBeam:Glyph, color=#ff0044
.. damage=50.0, lifesteal=0.3, cooldown=5.0s
.. lifetime=12, speed=40.0, attackDistance=lifetime * speed / TicksPerSecond

pub symbol WantFiresplatter

pub fn FiresplatterOption(.. ui) {
	SlotOption<WantFiresplatter> {
		H1 { %("Firesplatter") }

		P {
			%("Unleash a sweeping arc of flames, scorching nearby foes while also incinerating incoming attacks with its all-consuming blaze.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.FiresplatterAbility(unit, owner, btn) {
	on BotAttacking target {
		if Cooldown == 0 && Distance(unit.Pos, target) <= attackDistance {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		TurnRateModifier(-1)
		SpeedModifier(-0.5)

		Sing(Firesplatter:Sound)
		await Spray(duration=20, count=10, spray=0.2revs) {
			.. damage = damage / count

			Spawn projectile {
				.. parent=unit
				.. dissipation=12, radius=0.32
				.. density=0.5, ccd=true
				.. luminous=1.0, depth=Depth:Projectile
				.. categories=Category:Projectile, durability=Durability:High

				LaunchBody
				PrepareForCollision
				PropulsiveMotion
				RayEmitter(dissipation=7)
				Smoke(dissipation=30, splatter=0.3, feather=1.0)
				ExpireAfterLifetime

				Collider {
					Shape:Circle
				}

				let canHurtSelf = false
				on BeforeCollide that {
					if canHurtSelf || that.Team != owner.Team {
						Attack(that)

						that.Tombstone victim {
							NameBlock(owner)
							%(" burned ")
							NameBlock(victim)
							%(" to a crisp")
						}
					}
				}
				on AfterCollide that {
					if that.Category & Category:Shield {
						canHurtSelf = true // Can bounce off shield to hurt self
					}
					if that.Durability >= this.Durability {
						Strobe(shine=0.5, growth=0.25)
						Puff(count=1, splatter=1)
						Expire
					}
				}
			}
		}
	}
}

sound Firesplatter:Sound(duration=0.5s) {
	Vibrato(freqModulation=[3600,10800]) {
		Oscillator(freq=30)
	}
	Oscillator(wave=$triangle, freq=[4800,7200], harmonics=[1, 1.33, 1.5])
	Tremolo(volumeModulation=0.1) {
		Oscillator(freq=30)
	}
	Envelope(attack=0.1s, release=0.25s)
	Gain(volume=0.1)
}
[[abilities/followCursor.easel]]
.. glyph=null, color=#0000

pub symbol WantFollowCursor

pub fn ability.FollowCursorAbility(unit, owner) {
	TouchscreenPointer // make the touchscreen act like a mouse when using FollowCursorAbility

	hook Pointer, IsPointerActive {
		if IsPointerActive {
			Movement:WalkTo(Pointer)
		} else {
			Movement:Stop
		}
	}
}
[[abilities/forcefield.easel]]
.. glyph=WoodenFence:Glyph, color=#3366ff, cooldown=7.5s, lifetime=2.0s
.. easeInFraction=0.05

pub symbol WantForcefield

pub fn ForcefieldOption(.. ui) {
	SlotOption<WantForcefield> {
		H1 { %("Forcefield") }

		P {
			%("Forge an impressive barrier of shimmering light that resolutely repels foes and their onslaughts. Fortunately, you may pass through your radiant barrier unhindered, allowing you to navigate the battlefield with ease while your adversaries are left confounded by its impenetrable presence.")
		}

		P {
			SlotEffect("Unhindered Passage", icon="fas fa-portal-exit") {
				%("You can walk through your own Forcefield.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.ForcefieldAbility(unit, owner, btn) {
	on BotDeflecting target {
		if Cooldown == 0 {
			let mid = unit.Pos + (target - unit.Pos) / 2.0
			BotUseAbility(target=mid)
		}
	}

	Incantation {
		Spawn shield {
			.. parent=unit
			.. dissipation=10
			.. extent=6.0, radius=0.25, maxDistance=20
			.. density=100.0, restitution=1.0
			.. luminous=1.0, depth=Depth:Shield
			.. ccd=true
			.. categories = Category:Shield | Category:Obstacle | Category:Aoe, durability=Durability:Shield
			.. collideWith = Category:Solid ^ Category:Shield ^ Category:Obstacle

			Body(Towards(parent.Pos, Pointer, maxDistance), heading=Angle(Pointer - parent.Pos))
			PrepareForCollision
			DecayingMotion
			Sing(Forcefield:Sound)
			ExpireAfterLifetime

			Collider(passthroughParent=true) {
				Shape:Capsule(angleOffset=0.25rev)
			}

			on Hurt {
				Strobe(dissipation=10, shine=1.0)
			}

			Tween(duration=lifetime, initial=0, final=1) a {
				.. fade = a * 0.5, color=color.Fade(fade)
				.. ease = Min(1, a/easeInFraction), extent=extent*ease

				Sprite(flicker=0.1, shadow=0.25, glare=1, glareAlpha=1-fade, bloom=5.0, bloomAlpha=1) {
					Shape:Capsule(angleOffset=0.25rev)
				}
			}

			on BeforeCollide that {
				if that.Category & Category:Projectile {
					Hear(Forcefield:HitSound)
				}
			}
		}
	}
}

sound Forcefield:Sound(duration=2s) {
	Oscillator(wave=$sine, freq=100)
	Envelope(attack=0.05s, sustain=0s)
	Gain(volume=0.25)
}

sound Forcefield:HitSound(duration=0.5s) {
	Vibrato(freqModulation=100) {
		Oscillator(freq=200)
	}
	Oscillator(freq=100)
	LowPass(freq=100)
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.5)
}
[[abilities/frostsplatter.easel]]
.. glyph=Frostfire:Glyph, color=#44ffff, cooldown=5s, damage=0, slowProportion=0.5, buffDuration=1.25s

pub symbol WantFrostsplatter

pub fn FrostsplatterOption(.. ui) {
	SlotOption<WantFrostsplatter> {
		H1 { %("Frostsplatter") }

		P {
			%("Summon a fierce blast of frigid winds that slows nearby enemies to a crawl and blows away incoming attacks.")
		}

		P {
			SlotEffect("Frigid Stagger", icon="fas fa-snowflake") {
				%("Slows nearby enemies by " + (slowProportion * 100.0) + "% for " + (buffDuration / TicksPerSecond) + "s.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.FrostsplatterAbility(unit, owner, btn) {
	on BotDeflecting {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		TurnRateModifier(-1)

		Hear(Frostsplatter:Sound)
		await Spray(duration=3, count=6, spray=0.3revs) {
			Spawn projectile {
				.. parent=unit
				.. lifetime=25, dissipation=10
				.. radius=0.8, speed=16
				.. density=12.0, restitution=0, durability=Durability:Low, ccd=true
				.. feather=0.7, glare=0.7, glareAlpha=0.4, bloom=0, luminous=0, depth=Depth:Projectile
				.. categories=Category:Projectile, sense = Category:Projectile | Category:Hero

				LaunchBody
				PrepareForCollision
				PropulsiveMotion
				Bloom(bloom=0.8, luminous=1)
				Smoke(radius=1.2, dissipation=30, splatter=0.8, color=#4ff4, fade=1)
				ExpireAfterLifetime

				Collider {
					Shape:Circle
				}

				on BeforeCollide that {
					if (that.Category & Category:Hero) && that.Team != owner.Team {
						Attack(that)

						that.Tombstone victim {
							NameBlock(owner)
							%(" chilled ")
							NameBlock(victim)
							%(" with dis-gust")
						}

						that.ReplaceBuff<cold>(cleansable=true) {
							ExpireAfterLifetime(buffDuration)
							SpeedModifier(-slowProportion, that)
							Smoke(that,
								color=#4ff4, fade=1, feather=0.5,
								radius=1.0, dissipation=20, depth=Depth:Particle,
								flutter=$perimeter)
						}
					}
				}
				on AfterCollide that {
					if that.Durability >= this.Durability {
						Strobe(shine=1)
						Expire
					}
				}

				Wind(1.0, radius=)
			}
		}
	}
}

sound Frostsplatter:Sound(duration=0.6s, cutoff=0.5s) {
	BrownNoise
	BandPass(freq=125, q=1)
	Envelope(attack=0.07s, sustain=0s)
}
[[abilities/grapple.easel]]
.. glyph=Grapple:Glyph, color=#ff0066, damage=0, cooldown=5s

pub symbol WantGrapple

pub fn GrappleOption(.. ui) {
	SlotOption<WantGrapple> {
		H1 { %("Grapple") }

		P {
			%("With a grapple of mystical energy, capture your adversary and swing them straight into the jaws of peril. ")
		}

		P {
			SlotEffect("Forceful Fling", icon="fas fa-arrows") {
				%("Hold down the button to capture your enemy, move your cursor to swing and then release the button to throw your enemy. ")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.GrappleAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. lifetime=50, dissipation=5
			.. radius=0.2, speed=72
			.. depth=Depth:Tether
			.. luminous=0, taper=0.3, shadow=0.5
			.. density=1.5, restitution=0, ccd=true
			.. categories = Category:Projectile | Category:Grabber, durability=Durability:Low
			.. sense = Category:Hero | Category:Obstacle

			on BotChannelling {
				BotKeepChannelling
			}

			LaunchBody(turnRate=3rev)
			PrepareForCollision
			DecayingMotion
			CooldownRate(-1)
			Sing(Grapple:Sound)
			ExpireWith(unit)
			ExpireAfterLifetime
			Movement:WalkWith(unit)
			
			hook<followCursor> Pointer {
				Homing(Pointer, turnRate=0.002rev)
			}

			once<redirect> Sleep(35) {
				Velocity:RedirectTowards(unit.Pos, speed=4)
				delete hook<followCursor>
				Homing(unit)
				await Sleep(5)
				Velocity:RedirectTowards(unit.Pos, speed=96)
				PropulsiveMotion
			}

			once ability.ReleaseCommand {
				Expire
			}

			Sprite {
				Shape:Equilateral(radius=4.0 * radius, numPoints=3)
			}
			
			// passthroughSiblings=false so the Grapple can immediately collide with a sibling like a Meteor even when it is spawned inside of the Meteor
			Collider(passthroughSiblings=false) {
				Shape:Circle
			}

			on BeforeCollide that {
				if that == unit { Expire } // The grapple has returned, expire it
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" threw ")
						NameBlock(victim)
						%(" a goodbye party ")
					}
				}
			}

			once SeverTethers { Expire }

			TetherBuffOnHit(radius=2.0 * radius, crater=0.4, bloomAlpha=0.5, shadow=0.5, glare=0, shine=0.5) that {
				// Throw the enemy into the void
				on BotChannelling enemy {
					if !enemy.IsInLava {
						BotKeepChannelling(spin=true, utility=Utility:Maximum)
					}
				}

				// If we've grappled onto a meteor/meteorite, slightly different settings
				const isProjectile = that.Category & Category:Projectile
				ExpireAfterLifetime(isProjectile ? 2s : 1s)
				CooldownRate(-1)
				SpeedModifier(-1) // Stop the unit moving because otherwise they keep shortening the grapple as they move towards the target, reducing control
				TurnRateModifier(-0.99)

				TowTether(unit, attractor=that)
				Tween(duration=0.5s, initial=0.0, final=1.0) factor {
					SwingTether(that, unit=, turnProportion=factor * (isProjectile ? 0.01 : 0.05), momentumFactor=isProjectile ? 1.0 : 0.9)
				}

				once ability.ReleaseCommand { Expire }
			}
		}
	}
}

sound Grapple:Sound(duration=1.25s) {
	Oscillator(wave=$square, freq=200, harmonics=[1,2,4,8,16])
	LowPass(freq=200)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=16)
	}
	Envelope(attack=1s, sustain=0s)
}
[[abilities/halo.easel]]
.. glyph=AngelOutfit:Glyph, color=#ffaa00, damage=6, lifesteal=1.0, lifetime=3.0s, cooldown=7.5s, numHalos=3, fastProportion=0.2

pub symbol WantHalo

pub fn HaloOption(.. ui) {
	SlotOption<WantHalo> {
		H1 { %("Halo") }

		P {
			%("Manifest " + numHalos + " resplendent swirls of radiant energy, burning your enemies with holy light and stealing a fragment of their soul with each hit.")
		}

		P {
			SlotEffect("Interruptible", icon="fas fa-hand-paper") {
				%("Any disruption, be it an attempt to cast another spell or a strike from your enemies, compromises your steadfast devotion and will shatter the celestial radiance of your halos.")
			}
			SlotEffect("Rapid Gracefulness", icon="fas fa-running") {
				%("Move " + (fastProportion * 100) + "% faster as your every step shimmers with the favor of the gods.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.HaloAbility(unit, owner, btn) {
	on BotAttacking target {
		const triggerDistance = 5
		if Cooldown == 0 && Distance(unit.Pos, target) <= triggerDistance {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		SpeedModifier(fastProportion)

		on Interrupt interruptor {
			StopIncantation
		}

		on BotChannelling target {
			const chaseDistance=10
			if Distance(unit.Pos, target) <= chaseDistance {
				BotKeepChannelling
			}
		}

		await Barrage(interval=1.5s, count=numHalos) index {
			Subspawn projectile { // Subspawn so all halos expire at the same time when incantation ends
				.. parent=unit
				.. dissipation=15 
				.. radius=0.1, speed=40.0
				.. luminous=1.0, depth=Depth:Projectile
				.. density=1, ccd=true
				.. categories=Category:Projectile | Category:Destructible, durability=Durability:Minimum
				.. collideWith = Category:Solid ^ Category:Projectile
				.. noLavasteal=true // Not enough knockback to push others into lava

				LaunchBody
				PrepareForCollision
				PropulsiveMotion
				Movement:WalkWith(unit)
				Homing(unit, turnProportion=0.2)
				RayEmitter(bloom=2, fade=1, taper=0)
				Sing(Halo:Sound)

				Collider {
					Shape:Circle
				}

				on BeforeCollide that {
					if that.Team != owner.Team {
						Attack(that)
						Strobe(growth=1.0)
						Hear(Halo:HitSound)

						that.Tombstone victim {
							NameBlock(owner)
							%(" enlightened ")
							NameBlock(victim)
							%(" in a blazing spectacle")
						}
					}
				}
			}
		}

		// All halos expire live for the same lifetime duration and expire at the same time
		await Sleep(lifetime)
	}
}

sound Halo:Sound(duration=0.3s) {
	Oscillator(wave=$sawtooth, freq=[9000,11500], harmonics=[1, 1.167, 1.33, 1.78, 2, 2.25])
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.25)
}

sound Halo:HitSound(duration=0.3s) {
	Oscillator(wave=$sawtooth, freq=[7000,6880], harmonics=[1, 1.167, 1.33, 1.78, 2, 2.25])
	HighPass(freq=6500)
	LowPass(freq=[10000,0])
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.25)
}
[[abilities/homing.easel]]
.. glyph=BoltSaw:Glyph, color=#44ffcc, damage=16, lifesteal=0.3, cooldown=9.0s

pub symbol WantHoming

prop projectile.Repossessor

pub fn HomingOption(.. ui) {
	SlotOption<WantHoming> {
		H1 { %("Homing") }

		P {
			%("Summon a tenacious, enchanted sphere that ceaselessly pursues your enemy. While they are preoccupied, seize the opportunity to unleash a barrage of your most potent abilities upon them.")
		}

		P {
			SlotEffect("Ceaseless Pursuit", icon="fas fa-crosshairs") {
				%("Homing seeks the enemy that was nearest to your cursor when launched.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.HomingAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility(utility=Utility:High)
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit
			.. lifetime=3.5s, dissipation=30, ownerColor=Alliance:Self
			.. radius=0.24, speed=12, alignHeadingToVelocity=true
			.. density=35, ccd=true
			.. luminous=1.0, depth=Depth:Projectile
			.. categories=Category:Projectile | Category:Aoe, durability=Durability:High

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			ExpireAfterLifetime
			Sing(Homing:Sound)

			Sprite {
				Collider {
					Shape:Circle
				}
			}

			hook Repossessor {
				.. owner = Repossessor ?? owner
				RayEmitter<helix1>(radius, fade=0, flutter=Flutter:Helix(radius * 0.5, period=18))
				RayEmitter<helix2>(radius * 0.5, fade=1, flutter=Flutter:Helix(radius * 2.0, period=18, angleOffset=0.4rev), bloom=0, glare=0)
				Homing(QueryUnits.WhereAlliance(owner, Alliance:Enemy).FindNearest(Pointer), turnProportion=0.05)
			}

			let canHurtSelf = false
			on BeforeCollide that {
				if canHurtSelf || owner.Team != that.Team {
					Attack(that)

					if that.Category & Category:Shield {
						canHurtSelf = true // Can bounce off shield to hurt self
						this.Repossessor = that.Owner // Change the owner
					}

					that.Tombstone victim {
						NameBlock(owner)
						%("'s endless pursuit ended ")
						NameBlock(victim)
					}
				}
			}
			on AfterCollide that {
				if that.Durability >= this.Durability {
					Strobe(growth=0.25, shine=1.0)
					Puff(count=10, splatter=1)
					Expire
				}
			}
		}
	}
}

sound Homing:Sound(duration=5s, cutoff=0.5s) {
	BrownNoise
	HighPass(freq=1800)
	LowPass(freq=1803)
	Gain(volume=0.25)
	Output(into=$final)

	Oscillator(freq=800, harmonics=[1,1.5])
	LowPass(freq=200)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=6.67)
	}
	Output(into=$final)

	Input(key=$final)
	Envelope(attack=0.5s, sustain=0s)
}
[[abilities/horcrux.easel]]
.. glyph=BurningEye:Glyph, color=#22ee88, damage=30.0, duration=1.0s, lifesteal=1.0, cooldown=7.5s

pub symbol WantHorcrux

pub fn HorcruxOption(.. ui) {
	SlotOption<WantHorcrux> {
		H1 { %("Horcrux") }

		P {
			%("Secure your existence on this mortal plane with this enigmatic relic which safeguards you from death. This fragile object also draws life from nearby foes but never kills them. Be cautious when placing your Horcrux as even the slightest touch of your enemy will shatter it, leaving you at the whims of fate.")
		}

		P {
			SlotEffect("Unkillable", icon="fas fa-skull") {
				%("As long as your Horcrux is alive, you cannot die.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.HorcruxAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility(utility=Utility:Low)
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit
			.. lifetime=3s, dissipation=15
			.. interval=6, damagePerInterval = interval * damage / duration, maxHits = damage / damagePerInterval
			.. radius=0.28, aoe=3.2, speed=28
			.. luminous=1, depth=Depth:Projectile
			.. density=1, ccd=true
			.. categories=Category:Projectile | Category:Destructible, durability=Durability:Low
			.. noLavasteal=true // Not enough knockback to push others into lava

			const birth = Tick

			LaunchBody(turnRate=1rev)
			PrepareForCollision
			PropulsiveMotion
			Unkillable(true)
			CooldownRate(-1)
			Aoe:Indicator(color=color.Fade(0.95))
			Smoke(splatter=Splatter:Outwards(6.0,glide=0.3), dissipation=10)
			Sing(Horcrux:Sound)
			ExpireAfterLifetime

			hook unit.Vanished {
				if unit.Vanished {
					delete Tether
				} else {
					Tether(ancestor=unit, color=#fff2, radius=0.1, taper=0.5, fade=0.25)
				}
			}

			Collider(collideWith = Category:Solid ^ Category:Projectile) { // No collisions with projectiles while deploying
				Shape:Circle
			}

			Sprite(bloom=4, bloomAlpha=0.5, luminous=1, shadow=0.25, depth=depth + 1) {
				Shape:Equilateral(numPoints=5, radius=2.0 * radius)
			}

			on AfterCollide that {
				if (that.Category & Category:Hero) && that.Durability >= this.Durability {
					Strobe(growth=0.5, shine=1.0)
					Puff(count=10, splatter=1)
					Expire
				}
			}

			once<deploy> Sleep(Min(lifetime, Velocity:TicksTo(Pointer))) {
				DecayingMotion
				Speed = 0
			}

			hook<aoe> Sleep(interval) {
				.. damage = damage * interval / TicksPerSecond

				ColliderProps(collideWith=Category:Solid) // Restore collisions with projectiles after deployment

				Aoe:ForEach(filter=Category:Hero) that {
					if that.Team != owner.Team && TakeHitIfWithinLimit(that, maxHits=) {
						Attack(that, damagePerInterval, noHurt=true, noInterrupt=true, minHealth=1)
						Puff(that,
							radius=1.0, depth=Depth:Particle,
							color=color.Fade(0.7),
							flutter=$perimeter, splatter=Splatter:Outwards(12))

						that.Tombstone victim {
							NameBlock(owner)
							%(" stole ")
							NameBlock(victim)
							%("'s soul")
						}
					}
				}
			}

			hook<pulse> Tick {
				const cycle=13, proportion = ((Tick - birth) % cycle) / cycle
				Sprite<radiation>(crater=0.8, feather=0.3, bloom=1.5, shine=0.1,
					color=color.Fade(0.95).Fade(proportion)) {

					Shape:Circle(radius=aoe * proportion)
				}
			}
		}
	}
}

sound Horcrux:Sound(duration=1s) {
	Oscillator(wave=$sine, freq=150, harmonics=[1, 1.5])
	Tremolo(volumeModulation=0.2) {
		Oscillator(freq=8)
	}
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.25)
}
[[abilities/link.easel]]
.. glyph=AndromedaChain:Glyph, color=#4444ff, cooldown=7.5s, relayProportion=1.0, damage=0

pub symbol WantLink1

pub fn LinkOption(.. ui) {
	SlotOption<WantLink1> {
		H1 { %("Link") }

		P {
			%("Forge an ethereal grapple that binds your foe to you, irresistably drawing them towards you. With your souls entwined, all incoming damage will be transferred from you to them, turning their aggression into their own undoing.")
		}

		P {
			SlotEffect("Ethereal Relay", icon="fas fa-exchange") {
				%("While linked, " + (relayProportion * 100) + "% of received damage is instead applied to your enemy.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.LinkAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit 
			.. lifetime=94, dissipation=5
			.. radius=0.4, speed=40.0
			.. ownerColor=true, color=#fff, depth=Depth:Tether
			.. luminous=1.0, taper=0.3, flicker=0.4
			.. density=10, restitution=0, ccd=true
			.. categories=Category:Projectile, durability=Durability:Low
			.. sense = Category:Hero | Category:Obstacle

			LaunchBody(turnRate=2rev)
			PrepareForCollision
			DriftingMotion
			ExpireWith(unit)
			ExpireAfterLifetime
			Sing(Link:Sound)
			CooldownRate(-1)
			Movement:WalkWith(unit)

			Sprite(bloom=2) {
				Shape:Equilateral(radius=, numPoints=3)
			}
			Collider {
				Shape:Circle
			}

			once<redirect> Sleep(40) {
				Velocity:RedirectTowards(unit.Pos, speed=4)
				await Sleep(20)
				Velocity:RedirectTowards(unit.Pos, speed=48)
			}

			on BeforeCollide that {
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" transmuted their demise to ")
						NameBlock(victim)
					}
				}
			}

			once SeverTethers { Expire }

			TetherBuffOnHit(radius=0.2, bloomAlpha=0.5, shadow=0.5) that {
				ExpireAfterLifetime(1.75s)
				CooldownRate(-1)
				PullTether(that, attractor=unit, impulse=5, minDistance=2, maxDistance=10)
				TowTether(that, attractor=unit)

				if (that.Category & (Category:Hero | Category:Obstacle)) && that.Team != owner.Team {
					Relay(that)
					RelayProportion(relayProportion)
				}
			}
		}
	}
}

sound Link:Sound(duration=2s) {
	Oscillator(wave=$square, freq=150, harmonics=[1,2,4,8,16])
	LowPass(freq=150)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=10)
	}
	Envelope(attack=1s, sustain=0s)
}
[[abilities/meteor.easel]]
.. glyph=CometSpark:Glyph, color=#ff0000, damage=0, cooldown=9.0s

pub symbol WantMeteor

pub fn MeteorOption(.. ui) {
	SlotOption<WantMeteor> {
		H1 { %("Meteor") }

		P {
			%("Summon a colossal meteor that hurtles towards your foes, shielding you from harm with its unstoppable momentum and unwavering absorption of all incoming attacks, enduring them without so much as a flinch. ")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.MeteorAbility(unit, owner, btn) {
	on BotDeflecting {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. lifetime=2s, dissipation=24
			.. radius=2.88, speed=16
			.. feather=0, bloom=0, shine=0, glare=0, luminous=0.0, depth=Depth:Projectile+10
			.. density=140, restitution=0, ccd=true
			.. categories = Category:Projectile | Category:CanGrab | Category:Aoe | Category:Massive, durability=Durability:Maximum
			.. collideWith = Category:Solid ^ Category:Shield

			LaunchBody
			PrepareForCollision
			PropulsiveMotion(0.2)
			Hear(Meteor:LaunchSound)
			Sing(Meteor:Sound)
			ExpireAfterLifetime

			// we're only using the avatar for the bloom
			// depth+1 to place avatar behind the particles - the bloom will surround them
			Sprite(depth=depth+1, bloom=5, crater=1, luminous=0) {

				// passthroughSiblings=false so the Grapple can immediately collide with a sibling like a Meteor even when it is spawned inside of the Meteor
				Collider(passthroughSiblings=false) {
					Shape:Circle
				}
			}

			Smoke(splatter=0.5, fade=#900, shadow=0.25)

			on Hurt {
				Strobe(shine=1.0)
			}

			on BeforeCollide that {
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" drove ")
						NameBlock(victim)
						%(" to their downfall ")
					}
				}
			}
		}
	}
}

sound Meteor:LaunchSound(duration=0.33s) {
	Oscillator(wave=$square, freq=[20,1], harmonics=[1, 2, 3, 4, 5, 6, 7, 8])
	HighPass(freq=40)
	LowPass(freq=300)
	Envelope(attack=0.1s, sustain=0s)
}

sound Meteor:Sound(duration=2s) {
	Oscillator(wave=$square, freq=[1,10], harmonics=[1, 1.5, 2, 2.1, 2.16, 3.5, 6.7, 8.2])
	HighPass(freq=40)
	LowPass(freq=100)
	Envelope(attack=0.16s, sustain=0.5s)
}
[[abilities/meteorite.easel]]
.. glyph=FragmentedMeteor:Glyph, color=#ff0066, damage=0, cooldown=6.5s

pub symbol WantMeteorite

signal projectile.MeteoriteSplit

pub fn MeteoriteOption(.. ui) {
	SlotOption<WantMeteorite> {
		H1 { %("Meteorite") }

		P {
			%("Summon a meteorite that hurtles towards your foes with unstoppable momentum. Upon encountering enemy spells, this indomitable force splits in two and continues its relentless advance.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.MeteoriteAbility(unit, owner, btn) {
	on BotDeflecting {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. lifetime=2.0s, dissipation=12
			.. radius=1.44, speed=24, propulsion=0.2
			.. feather=0, bloom=0, shine=0, glare=0, luminous=0.0
			.. fade=#803, depth=Depth:Projectile+10
			.. density=140, restitution=0, ccd=true
			.. categories = Category:Projectile | Category:CanGrab | Category:Aoe | Category:Massive, durability=Durability:Maximum
			.. collideWith = Category:Solid ^ Category:Shield

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Smoke(splatter=0.5, shadow=0.5)
			Hear(Meteorite:LaunchSound)
			Sing(Meteorite:Sound)
			ExpireAfterLifetime

			// we're only using the avatar for the bloom
			// depth+1 to place avatar behind the particles - the bloom will surround them
			Sprite(bloom=3, depth=depth+1) {
				// passthroughSiblings=false so the Grapple can immediately collide with a sibling like a Meteor even when it is spawned inside of the Meteor
				Collider(passthroughSiblings=false) {
					Shape:Circle
				}
			}

			on Hurt {
				Strobe(shine=1.0)
			}

			on BeforeCollide that {
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" nudged ")
						NameBlock(victim)
						%(" to their bitter end ")
					}

				}

				// Specifically don't split on grabbers (e.g. Grapple) so they can ride the Meteorite
				if !(that.Category & Category:Grabber) {
					MeteoriteSplit
				}
			}

			// Wait for the meteorite to split before proceeding
			await MeteoriteSplit

			await Spray(duration=0, count=2, spray=0.02revs) {
				.. parent=projectile // set the parent to projectile before we overwrite projectile with a new spawn
				Spawn projectile {
					.. lifetime=1.0s, radius=0.5*radius

					LaunchBody
					PrepareForCollision
					PropulsiveMotion
					Smoke(splatter=0.5, shadow=0.5)
					Sing(Meteorite:SubprojectileSound)
					ExpireAfterLifetime

					// we're only using the avatar for the bloom
					// depth+1 to place avatar behind the particles - the bloom will surround them
					Sprite(bloom=3, depth=depth+1) {
						Collider {
							Shape:Circle
						}
					}

					on Hurt {
						Strobe(shine=1.0)
					}

					on AfterCollide that {
						if that.Team != owner.Team {
							Attack(that)

							that.Tombstone victim {
								NameBlock(owner)
								%(" gently nudged ")
								NameBlock(victim)
								%(" to their bitter end")
							}
						}
					}
				}
			}

			Expire
		}
	}
}

sound Meteorite:LaunchSound(duration=0.33s) {
	Oscillator(wave=$square, freq=[20,1], harmonics=[1, 2, 3, 4, 5, 6, 7, 8])
	HighPass(freq=150)
	LowPass(freq=300)
	Envelope(attack=0.1s, sustain=0s)
}

sound Meteorite:Sound(duration=2s, cutoff=0.25s) {
	Oscillator(wave=$square, freq=[1,10], harmonics=[1, 1.5, 2, 2.1, 2.16, 3.5, 6.7, 8.2])
	HighPass(freq=150)
	LowPass(freq=200)
	Envelope(attack=0.16s, sustain=0.5s)
}

sound Meteorite:SubprojectileSound(duration=2s, cutoff=0.25s) {
	Oscillator(wave=$square, freq=[1,10], harmonics=[1, 1.5, 2, 2.1, 2.16, 3.5, 6.7, 8.2])
	HighPass(freq=225)
	LowPass(freq=300)
	Envelope(attack=0.16s, sustain=0.5s)
}
[[abilities/orbiter.easel]]
.. glyph=BoomerangSun:Glyph, color=#ff00ff, damage=25.0, lifesteal=0.3, cooldown=9.0s

pub symbol WantOrbiter

pub fn OrbiterOption(.. ui) {
	SlotOption<WantOrbiter> {
		H1 { %("Orbiter") }

		P {
			%("Summon a powerful energy sphere that orbits you at a fixed range. Keep your foes at this ideal distance and catch them in your burning orbit.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.OrbiterAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		Spawn projectile {
			.. parent=unit
			.. lifetime=4s, dissipation=30, ownerColor=Alliance:Self
			.. radius=0.24, speed=48, bounceSpeed=5
			.. luminous=1.0, depth=Depth:Projectile
			.. density=1.5, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Smoke(luminous=1, splatter=0.2)
			Sing(Orbiter:Sound)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			RayEmitter(glare=0.5, luminous=0.5, dissipation=60)
			Homing(unit, turnProportion=0.04875)
			on BeforeCollide that {
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" caught ")
						NameBlock(victim)
						%(" in their burning orbit ")
					}
				}
			}
			on AfterCollide that {
				if that.Durability >= this.Durability {
					if that.Category & Category:Obstacle {
						if Speed > bounceSpeed {
							Speed = bounceSpeed
						}
					} else {
						Strobe(growth=1.0, shine=0.5)
						Puff(count=10, splatter=1)
						Hear(Orbiter:HitSound)
						Expire
					}
				}
			}
		}
	}
}

sound Orbiter:Sound(duration=4s, cutoff=0.5s) {
	BrownNoise
	BandPass(freq=820, q=15)
	Envelope(attack=0.25s, sustain=0s)
	Output

	Oscillator(wave=$sine, freq=205, harmonics=[1, 1.5, 2, 2.75, 4, 5.5])
	LowPass(freq=100)
	Tremolo(volumeModulation=0.6) {
		Oscillator(freq=7)
	}
	Envelope(attack=0.25s, sustain=0s)
}

sound Orbiter:HitSound(duration=0.33s) {
	Oscillator(wave=$square, freq=[100,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=250)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/overload.easel]]
.. glyph=DeadlyStrike:Glyph, color=#ff9900
.. damage=30, impulse=1400, selfDamage=10, lifesteal=0.3, cooldown=5s, aoe=4.0

pub symbol WantOverload

pub fn OverloadOption(.. ui) {
	SlotOption<WantOverload> {
		H1 { %("Overload") }

		P {
			%("Channel your immense power beyond the boundaries of safety, culminating in a formidable explosion that sends your adversaries hurtling away with forceful abandon. ")
		}

		P {
			SlotEffect("Density Surge", icon="fas fa-weight-hanging") {
				%("The surge of energy amplifies your mass, making you resistant to knockback.")
			}
			SlotEffect("Excessive Power", icon="fas fa-heart-broken") {
				%("The unchecked ferocity of this detonation also deals " + selfDamage + " damage to yourself.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.OverloadAbility(unit, owner, btn) {
	on BotAttacking target {
		if Cooldown == 0 && Distance(unit.Pos, target) <= aoe {
			BotUseAbility
		}
	}

	Incantation {
		.. radius=1.0, damage=damage * unit.DamageModifier
		.. dissipation=30, shine=1.0, bloom=3.0, luminous=1.0, depth=Depth:Projectile

		on Interrupt interruptor {
			if interruptor & Interruptor:Self {
				StopIncantation
			}
		}

		CooldownRate(-1)
		SpeedModifier(-1)
		DensityModifier(5)

		on BotChannelling target {
			if Distance(unit.Pos, target) <= aoe {
				BotKeepChannelling
			}
		}

		Sing(Overload:ChargingSound)
		await ChargeForDuration(0.5s) {
			ChargingIndicator
			hook ChargeProportion {
				Aoe:Indicator(aoe * Mix(ChargeProportion,0.75,1.0), color=Fade(color, 0.95))
			}
		}

		unit.TakeDamage(selfDamage, minHealth=1)
		SeverTethers

		Puff(count=10, splatter=Splatter:Outwards(26), feather=1)
		Explosion(aoe, bloom=5.0, shine=1.0)
		Hear(Overload:ExplodeSound)

		Aoe:ForEach that {
			if that.Team != owner.Team {
				Aoe:ImpulseAttenuated(that, attenuate=0.5)
				Aoe:Destroy(that)
				Attack(that)

				that.Tombstone victim {
					NameBlock(owner)
					%(" was too much for ")
					NameBlock(victim)
					%(" to handle")
				}
			}
		}
	}
}

sound Overload:ChargingSound(duration=0.5s) {
	Vibrato(freqModulation=[25,100]) {
		Oscillator(freq=[25,100])
	}
	Oscillator(wave=$triangle, freq=[50,200], harmonics=[1,1.25,1.5,1.75])
	Envelope(attack=0.49s, sustain=0s)
	Gain(volume=0.25)
}

sound Overload:ExplodeSound(duration=1s) {
	Vibrato(freqModulation=1000) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=40)
	LowPass(freq=[313,0])
	Envelope(attack=0.01, sustain=0s)
	Gain(volume=0.5)
	Output

	Vibrato(freqModulation=[300,100]) {
		Oscillator(freq=[313,100])
	}
	Oscillator(wave=$triangle, freq=[100,30], harmonics=[1,1.33,1.5])
	Tremolo(volumeModulation=0.2) {
		Oscillator(freq=3)
	}
	Envelope(attack=0.01, sustain=0s)
	Gain(volume=0.25)
	Output
}
[[abilities/phaseShift.easel]]
.. glyph=Resonance:Glyph, color=#ff00dd, maxDuration=0.75s, cooldown=5s

pub symbol WantPhaseShift

pub fn PhaseShiftOption(.. ui) {
	SlotOption<WantPhaseShift> {
		H1 { %("Phase Shift") }

		P {
			%("Press and hold to momentarily vanish from the world, becoming impervious to harm as you transcend the mortal plane.")
		}

		P {
			SlotEffect("Ethereal Exhaustion", icon="fas fa-hourglass-half") {
				%("Cooldown increases the longer you stay in Phase Shift.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.PhaseShiftAbility(unit, owner, btn) {
	on BotDeflecting {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. radius=1.0, dissipation=15, shine=1, luminous=1, depth=Depth:Projectile

		const birth = Tick

		on BotChannelling {
			const channelDuration=0.5s

			let age = Tick - birth
			if age < channelDuration {
				BotKeepChannelling
			}
		}

		CooldownRate(-1)
		SpeedModifier(-1)
		Vulnerability(-1)
		Tangibility(Category:None)
		FilterCategoriesModifier(Category:All ^ Category:Aoe)
		Vanished(true)
		Invisibility(true)
		SeverTethers
		Speed = 0

		Puff(count=10, color=#111111, fade=1, flicker=1, splatter=Splatter:Outwards(12.0), feather=1)
		Hear(PhaseShift:Sound)

		once Expire {
			Puff(count=10, color=#111111, fade=1, flicker=1, splatter=Splatter:Outwards(12.0), feather=1)
			Hear(PhaseShift:Sound)
		}

		on<coolup> Tick {
			Cooldown += 5
		}

		once Sleep(maxDuration) {
			StopIncantation
		}

		await ability.ReleaseCommand
	}
}

sound PhaseShift:Sound(duration=0.25s) {
	Oscillator(wave=$sine, freq=[60,40], harmonics=[1,1.5])
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.25)
}
[[abilities/reflect.easel]]
.. glyph=ShieldReflect:Glyph, color=#3366ff, cooldown=10.0s, lifetime=2.0s, slowProportion=0.5
.. easeInFraction=0.05

pub symbol WantReflect

pub fn ReflectOption(.. ui) {
	SlotOption<WantReflect> {
		H1 { %("Reflect") }

		P {
			%("Forge a luminous barrier of shimmering energy that repels enemy projectiles and may even reflect them back upon their caster. Beware, the shield is powerless against the pervasive force of area-of-effect spells.")
		}

		P {
			SlotEffect("Heavy Protection", icon="fas fa-snowflake") {
				%("The weight of the shield slows you down by " + (slowProportion * 100) + "%.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.ReflectAbility(unit, owner, btn) {
	on BotDeflecting {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		ability.Subspawn shield {
			.. dissipation=10, radius=2.1, density=0.0, restitution=0.0
			.. luminous=1.0, depth=Depth:Shield
			.. categories=Category:Shield, durability=Durability:Shield, collideWith=Category:Projectile, ccd=true

			PrepareForCollision
			TurnRateModifier(-0.9)
			Sing(Reflect:Sound)
			ExpireAfterLifetime

			Collider(unit) { // Attach this Collider to the unit
				Shape:Sector(angleOffset=-0.25rev, arc=0.5rev)
			}

			on Hurt {
				Strobe(dissipation=10, shine=1.0, growth=0.25)
			}

			on BeforeCollide that {
				if that.Category & Category:Projectile {
					Hear(Reflect:HitSound)
					if that.Team != owner.Team {
						that.Velocity:RedirectTowards(unit.Pos, speedFactor=-1)
					}
				}
			}

			await Tween(duration=lifetime, initial=0, final=1) a {
				.. fade = a * 0.5, color=color.Fade(fade)
				.. ease = Min(1, a/easeInFraction), radius=radius*ease

				SpeedModifier(a.Mix(-slowProportion, 0))

				if unit.Vanished {
					delete Sprite

				} else {
					Sprite(unit, bloom=5.0, flicker=0.1, shadow=0.25) {
						Shape:Sector(angleOffset=-0.25rev, arc=0.5rev)
					}
				}
			}
		}
	}
}

sound Reflect:Sound(duration=2s) {
	Oscillator(wave=$sine, freq=90)
	Envelope(attack=0.1s, sustain=0s)
	Gain(volume=0.5)
}

sound Reflect:HitSound(duration=0.5s) {
	Vibrato(freqModulation=90) {
		Oscillator(freq=180)
	}
	Oscillator(wave=$sine, freq=90)
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.5)
}
[[abilities/refract.easel]]
.. glyph=ArcingBolt:Glyph, color=#00ff7f
.. damage=15, lifesteal=0.3, cooldown=1.5s, bonusProportion=1.0, slowProportion=0.5, bonusDuration=1s

pub symbol WantRefract

pub fn RefractOption(.. ui) {
	SlotOption<WantRefract> {
		H1 { %("Refract") }

		P {
			%("Invoke a vigilant burst of energy that obeys the whims of your will, allowing you to redirect Refract's path of destruction towards your enemies.")
		}

		P {
			SlotEffect("Refractable Path", icon="fas fa-arrows") {
				%("Hold down the button to launch, then release the button to redirect towards your cursor. ")
			}

			SlotEffect("Radiance Unleashed", icon="fas fa-star-exclamation") {
				%("After redirection, Refract grows in power, ramping up to " + (bonusProportion+1) + "x bonus damage after " + (bonusDuration / TicksPerSecond) + " second, so take an indirect path for maximum effect.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.RefractAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		CooldownRate(-1)

		Spawn projectile {
			.. parent=unit
			.. radius=0.28, speed=32, acceleration=32, alignHeadingToVelocity=true
			.. lifetime=2s, dissipation=15
			.. ownerColor=Alliance:Self, luminous=1.0, depth=Depth:Projectile
			.. density=83, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium

			const birth = Tick

			on BotChannelling {
				const channelDuration=0.75s

				let age = Tick - birth
				if age < channelDuration {
					BotKeepChannelling
				}
			}

			LaunchBody(speed=24)
			PrepareForCollision
			PropulsiveMotion
			Sing(Refract:Sound)
			SpeedModifier(-slowProportion)
			ExpireAfterLifetime

			once Expire {
				// End the incantation even if the owner is still holding down the button
				// so the cooldown starts ticking again
				StopIncantation
			}

			Collider {
				Shape:Circle
			}

			on<accelerate> PhysicsStart {
				if speed < Speed {
					Speed = Min(speed, Speed + acceleration / TicksPerSecond)
				}
			}

			RayEmitter<ray1>(radius)
			RayEmitter<ray2>(radius * 0.5, bloom=0, glare=0, fade=1, flutter=Flutter:Helix(radius=0.6, period=9))

			let releasedTick = false
			once ability.ReleaseCommand {
				Velocity:RedirectTowards(Pointer, speed=16)
				releasedTick = Tick
				delete SpeedModifier
			}

			let canHurtSelf = false
			on BeforeCollide that {
				if canHurtSelf || that.Team != owner.Team {
					const bonusMultiplier = 1 + (releasedTick ? (bonusProportion * ((Tick - releasedTick) / bonusDuration).Min(1)) : 0)
					Attack(that, damage * bonusMultiplier)

					that.Tombstone victim {
						NameBlock(owner)
						%(" illuminated ")
						NameBlock(victim)
						if releasedTick {
							%(" with twisted magic ")
						}
					}
				}
			}
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=1.0, shine=0.5)
					Explosion(2)
					Puff(count=10, splatter=1)
					Hear(Refract:HitSound)
					Expire
				}
			}
		}

		await ability.ReleaseCommand
	}
}

sound Refract:Sound(duration=2s) {
	BrownNoise
	BandPass(freq=1800, q=1)
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.1)
	Output

	Vibrato(freqModulation=300) {
		Oscillator(freq=1900)
	}
	Oscillator(wave=$sine, freq=900, harmonics=[1,1.5])
	LowPass(freq=200)
	Tremolo(volumeModulation=0.6) {
		Oscillator(freq=8)
	}
	Envelope(attack=0.5s, sustain=0s)
}

sound Refract:HitSound(duration=0.5s) {
	Oscillator(wave=$square, freq=[80,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=300)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/repeater.easel]]
.. glyph=SonicLightning:Glyph, color=#00ff00
.. damage=12, lifesteal=0.3, cooldown=9s
.. rangedBonus=1, rangedDuration=0.4s
.. secondHitBonus=0.33, buffDuration=5s

pub symbol WantRepeater

signal ability.RepeaterMiss // signal this on the ability, not the projectile, because repeater projectile will have expired by the time this is sent

pub fn RepeaterOption(.. ui) {
	SlotOption<WantRepeater> {
		H1 { %("Repeater") }

		P {
			%("Upon striking an enemy's soul with the harmonious energy of Repeater, the resulting symphony allows you to immediately unleash another blow, weaving an unyielding chain of attacks.")
		}

		P {
			SlotEffect("Harmonic Resonance", icon="fas fa-undo") {
				%("Each time Repeater hits, its cooldown resets, allowing you to fire it again immediately. ")
				%("Hitting the same enemy a second time grants " + (secondHitBonus * 100.0) + "% bonus damage. ")
			}
			SlotEffect("Soaring Crescendo", icon="fas fa-star-exclamation") {
				%("Damage increases with range, building up to " + (rangedBonus+1) + "x bonus damage after " + (rangedDuration / TicksPerSecond) + " seconds.")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.RepeaterAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		TurnRateModifier(-1.0)
		await ChargeForDuration(3) {
			ChargingIndicator
		}

		Spawn projectile {
			.. parent=unit
			.. lifetime=1s, dissipation=18
			.. maxStacks=2
			.. radius=0.16, speed=64
			.. luminous=1.0, depth=Depth:Projectile
			.. density=14, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium
			.. collideWith = Category:Solid ^ Category:Projectile

			const birth = Tick

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Smoke(shadow=0.5, radius=4.0*radius, interval=2)
			RayEmitter(0.5*radius, dissipation=12)
			Sing(Repeater:Sound)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			let hit = false
			once Expire {
				if !hit {
					RepeaterMiss
				}
			}

			let canHurtSelf = false
			on BeforeCollide that {
				if canHurtSelf || that.Team != owner.Team {
					// Only reset on units that are owned by a owner, not neutrals
					if (that.Category & Category:Hero) && that.Team && (that.Team != owner.Team) {
						hit = true
						Cooldown = 0
						Hear(Repeater:SuccessSound)
						that.StackBuff<repeater>(cleansable=true, maxStacks=1) stacks {
							ExpireAfterLifetime(buffDuration)
							BloomIndicator(that, audience=owner)

							const secondHitMultiplier = 1 + stacks * secondHitBonus
							const rangedMultiplier = 1 + rangedBonus * ((Tick - birth) / rangedDuration).Min(1.0)
							Attack(that, damage * rangedMultiplier * secondHitMultiplier)

							once RepeaterMiss { // miss once and the buff expires too
								Expire
							}

							that.Tombstone victim {
								NameBlock(owner)
								%(" orchestrated ")
								NameBlock(victim)
								%("'s final refrain")
								if stacks > 0 {
									%(" again and again")
								}
							}
						}
					} else {
						Attack(that)
					}
				}
			}
			on AfterCollide that {
				if that.Category & Category:Shield {
					canHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=1, shine=1.0)
					Puff(count=5, splatter=1)
					Expire
				}
			}
		}
	}
}

sound Repeater:Sound(duration=1s) {
	BrownNoise
	BandPass(freq=2000, q=3)
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.5)
	Output

	Oscillator(wave=$triangle, freq=2000, harmonics=[1,1.5])
	LowPass(freq=1000)
	Tremolo(volumeModulation=0.8) {
		Oscillator(freq=15)
	}
	Envelope(attack=0.1s, sustain=0s)
	Gain(volume=0.5)
}

sound Repeater:SuccessSound(duration=0.25s) {
	Oscillator(wave=$square, freq=4000, harmonics=[1,1.5])
	Tremolo(volumeModulation=0.8) {
		Oscillator(freq=15)
	}
	Envelope(attack=0.01s, sustain=0s)
	Gain(volume=0.1)
}
[[abilities/repulsor.easel]]
.. glyph=LightningHelix:Glyph, color=#ffaa00, damage=0, cooldown=9s, recoilSpeed=40

pub symbol WantRepulsor

pub fn RepulsorOption(.. ui) {
	SlotOption<WantRepulsor> {
		H1 { %("Repulsor") }

		P {
			%("Emit an intense beam of energy which drives your foes backward. Exercise caution, as its fierce recoil propels you backward too, either catapulting you into peril or hastening your retreat to safety. ")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.RepulsorAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		TurnRateModifier(-1.0)
		await ChargeForDuration(6) {
			ChargingIndicator
		}
		unit.Velocity += -recoilSpeed * Direction(Heading)

		Spawn projectile {
			.. parent=unit
			.. lifetime=0.5s, dissipation=30 
			.. radius=0.2, speed=240.0
			.. luminous=1.0, depth=Depth:Projectile
			.. density=12, ccd=true
			.. categories=Category:Projectile, durability=Durability:High
			.. collideWith = Category:Solid ^ Category:Projectile

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Sing(Repulsor:Sound)
			RayEmitter(fade=1)
			ExpireAfterLifetime

			Collider {
				Shape:Circle
			}

			on BeforeCollide that {
				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" repulsed ")
						NameBlock(victim)
						%(" to the realm of no return ")
					}
				}
			}
			on AfterCollide that {
				if that.Durability >= this.Durability {
					Strobe(shine=0.5)
					Puff(count=5, splatter=1)
					Expire
				}
			}
		}
	}
}

sound Repulsor:Sound(duration=0.3s, cutoff=0.3s) {
	Oscillator(wave=$sawtooth, freq=[4500,5000], harmonics=[1,1.33,1.5,1.78,2,2.67,3,3.56])
	Envelope(attack=0.001s, sustain=0s)
}
[[abilities/reverberate.easel]]
.. glyph=Aura:Glyph, color=#ff4400

pub symbol WantReverberate

pub fn ReverberateOption(.. ui) {
	SlotOption<WantReverberate> {
		H1 { %("Reverberate") }

		P {
			Span(italic=true) { %("Passive ability. ") }
			%("Imbue every atom in your body with an invisible, yet powerful, sonic resonance. Even the slightest contact with your vibrating form sends enemies reeling, forcefully replled by the resounding shockwave that pulsates from your very being.")
		}
	}
}

pub fn ability.ReverberateAbility(unit, owner, btn) {
	NoIncantation {
		on unit.AfterCollide that {
			if (that.Category & Category:Hero) && that.Team != owner.Team {
				Aoe:Impulse(that, 100)
				Hear(Reverberate:Sound)

				that.Tombstone victim {
					NameBlock(owner)
					%(" reverberated ")
					NameBlock(victim)
					%(" into unending silence ")
				}
			}
		}
	}
}

sound Reverberate:Sound(duration=0.2s) {
	Vibrato(freqModulation=80) {
		Oscillator(freq=240)
	}
	Oscillator(wave=$square, freq=80)
	LowPass(freq=120)
	Envelope(attack=0.001s, sustain=0s)
	Gain(volume=0.1)
}
[[abilities/saber.easel]]
.. glyph=WaveStrike:Glyph, color=#6600ff, damage=0, cooldown=7.5s, lifetime=1s, length=7.0

pub symbol WantSaber

pub fn SaberOption(.. ui) {
	SlotOption<WantSaber> {
		H1 { %("Lightsaber") }

		P {
			%("Wield a formidable saber forged from pure light. Its incandescent blade can expertly parry incoming projectiles and forcefully knock back your enemies with each swift and decisive strike. ")
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.SaberAbility(unit, owner, btn) {
	on BotAttacking target {
		if Cooldown == 0 && Distance(target, unit.Pos) <= length {
			BotUseAbility
		}
	}

	Incantation {
		on Interrupt interruptor {
			if interruptor & Interruptor:Self {
				StopIncantation
			}
		}

		on BotChannelling target {
			if Distance(target, unit.Pos) <= length {
				BotKeepChannelling(spin=true)
			}
		}

		Subspawn saber {
			.. parent=unit
			.. dissipation=10, luminous=1.0
			.. radius=0.25
			.. ccd=true
			.. categories=Category:Shield, durability=Durability:Shield
			.. depth=Depth:Saber
			.. fade=1, shadow=0.25, luminous=1, glare=1, glareAlpha=1, bloom=4, bloomAlpha=1

			PrepareForCollision
			SynchronizeBody
			Sing(Saber:Sound)
			SpeedModifier(-0.25)
			TurnRateModifier(-0.95)

			// Main saber collider is actually attached to the unit's body, which means it will transmit forces back onto the unit (e.g. recoil)
			Collider(unit, collideWith=Category:Hero, density=2.5) {
				// Deflector is attached to the saber's independent body so projectiles cannot knock the unit back through the saber
				Collider<deflector>(collideWith=Category:Projectile, density=5.0) {
					// Sprite is attached to the unit (not the independent deflector body) so it does not visually lag behind
					Sprite(unit, shadow=) {
						Shape:Capsule(extent=length/2.0, posOffset=@(extent, 0))
					}
				}
			}
			
			SwoopEmitter(radius=length, depth=depth+1)

			on Movement:Turned step {
				// A strong swing will detach any tethers
				if Abs(step) > 0.05rev {
					SeverTethers
				}
			}

			on Hurt {
				Strobe(dissipation=10, shine=1.0)
			}

			on BeforeCollide that { // Main collider hits units
				Hear(Saber:HitSound)

				if that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" slashed ")
						NameBlock(victim)
						%(" into bite-sized pieces ")
					}

					await Sleep(0.25s)
					StopIncantation
				}
			}

			on BeforeCollide<deflector> that { // Secondary collider hits projectiles only
				Hear(Saber:HitSound)
				if that.Category & Category:Destructible { that.Expire }
			}
		}

		await Sleep(lifetime)
	}
}

sound Saber:Sound(duration=5s) {
	Vibrato(freqModulation=1) {
		Oscillator(freq=[5,4])
	}
	Oscillator(wave=$square, freq=15.3, harmonics=[1,2,4,8,16])
	LowPass(freq=100)
	Tremolo(volumeModulation=0.4) {
		Oscillator(freq=7)
	}
	Envelope(attack=0.15s, sustain=0s)
	Gain(volume=0.25s)
}

sound Saber:HitSound(duration=0.5s) {
	Vibrato(freqModulation=100) {
		Oscillator(freq=200)
	}
	Oscillator(wave=$sine, freq=100)
	LowPass(freq=100)
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/spiritArmor.easel]]
.. glyph=WingedShield:Glyph, color=#9900ff, armorProportion=0.15

pub symbol WantSpiritArmor

pub fn SpiritArmorOption(.. ui) {
	SlotOption<WantSpiritArmor> {
		H1 { %("Spirit Armor") }

		P {
			%("Enshroud yourself in Spirit Armor, a divine protection that emanates from your very being. Feel as the blows of your enemies are blunted by the armor's divine intervention, emboldening you to face the trials of battle without fear. ")
		}

		P {
			SlotEffect("Divine Protection", icon="fas fa-shield") {
				%("Permently reduce damage received by " + (armorProportion * 100) + "%. Applies to all forms of damage, including void damage.")
			}
		}
	}
}

pub fn ability.SpiritArmorAbility(unit, owner, btn) {
	NoIncantation {
		Vulnerability(-armorProportion)
	}
}
[[abilities/spiritBomb.easel]]
.. glyph=MightyForce:Glyph, color=#ff0099, damage=0, cooldown=5s, slowDuration=1.5s, slowProportion=0.9

pub symbol WantSpiritBomb

// Constants for the bot
const LeashRange = 12
const LeashSlack = 4

pub fn SpiritBombOption(.. ui) {
	SlotOption<WantSpiritBomb> {
		H1 { %("Spirit Bomb") }

		P {
			%("Summon forth a malleable speck of energy, bending it to your will as you steer it relentlessly towards your adversaries. ")
		}

		P {
			SlotEffect("Purposeful Path", icon="fas fa-arrows") {
				%("Move your cursor to guide the path of Spirit Bomb. You are unable to move while channelling Spirit Bomb.")
			}
			SlotEffect("Mindful Ignition", icon="fas fa-bullseye") {
				%("Cast Spirit Bomb again to detonate at exactly the right moment. ")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.SpiritBombAbility(unit, owner, btn) {
	on BotAttacking target {
		if Cooldown == 0 && Distance(target, unit.Pos) <= LeashRange {
			BotUseAbility
		}
	}

	Incantation {
		.. lifetime=2.25s

		SpeedModifier(-0.95)

		Spawn projectile {
			.. parent=unit
			.. dissipation=20, impulse=570, radius=0.4, aoe=2.25, speed=17.5, turnProportion=0.012
			.. ownerColor=true, luminous=1.0, depth=Depth:Projectile
			.. density=1.5, ccd=true
			.. categories=Category:Projectile, durability=Durability:Medium

			let leash = LeashRange
			on BotChannelling target {
				const distance = Distance(projectile.Pos, target)
				leash = Min(leash, distance) // Tighten the leash as the spirit bomb gets closer
				if distance > aoe && distance < leash + LeashSlack { // Keep channelling until within explosion range or until we've missed by too much
					BotKeepChannelling
				}
			}

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Bloom(bloom=4, bloomAlpha=1.0)
			Smoke(dissipation=5, splatter=0.5, feather=1, glare=0.2)
			Sing(SpiritBomb:Sound)
			ExpireAfterLifetime

			hook Pointer {
				Homing(Pointer, turnRate=0.006rev)
			}

			Collider {
				Shape:Circle
			}

			on AfterCollide that {
				if that.Durability >= this.Durability {
					Strobe(growth=0.5, shine=1.0)
					Puff(count=10, splatter=1)
					Expire
				}
			}

			once Interrupt {
				Expire
			}

			await Tween(duration=1.0s, initial=0.5, final=1.0) factor {
				.. aoe = aoe * factor

				Aoe:Indicator(color=Fade(color, 0.95))
				once Expire {
					Puff(count=10, splatter=Splatter:Outwards(10))
					Explosion(aoe)
					Hear(SpiritBomb:ExplodeSound)

					Aoe:ForEach that {
						if that.Team != owner.Team {
							Attack(that)
							Aoe:ImpulseAttenuated(that, impulse=, attenuate=0.75)
							Aoe:Destroy(that)

							if that.Category & Category:Hero {
								that.ReplaceBuff<stun>(cleansable=true) {
									ExpireAfterLifetime(slowDuration)
									SpeedModifier(-slowProportion, that)
									Smoke(that,
										color=#4ff4, fade=1, feather=0.5,
										radius=1.0, dissipation=20, depth=Depth:Particle,
										flutter=$perimeter)
								}
							}

							that.Tombstone victim {
								NameBlock(owner)
								%(" banished ")
								NameBlock(victim)
								%(" to the spirit world ")
							}
						}
					}

					StopIncantation
				}
			}
		}

		await Sleep(lifetime)
	}
}

sound SpiritBomb:Sound(duration=2s) {
	BrownNoise
	BandPass(freq=1800, q=1)
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.25)
	Output

	Vibrato(freqModulation=100) {
		Oscillator(freq=2100)
	}
	Oscillator(freq=900, harmonics=[1,1.5])
	LowPass(freq=225)
	Tremolo(volumeModulation=0.3) {
		Oscillator(freq=11)
	}
	Envelope(attack=0.5s, sustain=0s)
}

sound SpiritBomb:ExplodeSound(duration=0.75s) {
	Vibrato(freqModulation=2000) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=40)
	LowPass(freq=[450,0])
	HighShelf(freq=[112,0], db=-6)
	Peaking(freq=[56,225], q=0.5, db=12)
	Envelope(attack=0.01s, decay=0.07s, sustain=0s, sustainVolume=0.2)
	Output

	Vibrato(freqModulation=100) {
		Oscillator(freq=2100)
	}
	Oscillator(freq=900, harmonics=[1,1.5])
	LowPass(freq=200)
	Tremolo(volumeModulation=0.3) {
		Oscillator(freq=[11,0])
	}
	Envelope(attack=0.01s, sustain=0s)
}
[[abilities/supernova.easel]]
.. glyph=CrownedExplosion:Glyph, color=#ff9a00, damage=0, cooldown=7.5s, explodeDelay=0.3s

pub symbol WantSupernova

pub fn SupernovaOption(.. ui) {
	SlotOption<WantSupernova> {
		H1 { %("Supernova") }

		P {
			%("Launch a condensed sphere of pulsating energy which, after a brief delay, explodes with the fury of a supernova, flinging your enemies towards the edges of the universe.")
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.SupernovaAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. impulse=710.0, aoe=4.0
			.. radius=0.1, speed=24.0
			.. lifetime=65, dissipation=30
			.. luminous=1.0, depth=Depth:Projectile
			.. density=5.0, ccd=true
			.. categories=Category:Projectile, collideWith=Category:None

			LaunchBody
			DriftingMotion
			RayEmitter(shadow=0.5)
			Sing(Supernova:Sound)

			once<deploy> Sleep(Velocity:TicksTo(Pointer).Min(lifetime)) {
				Speed = 0

				await Tween(duration=explodeDelay, initial=1.0, final=0.0) factor {
					Aoe:Indicator(aoe * factor, color=Fade(color, 0.95))
				}

				Expire
			}

			once Expire {
				Puff(count=10, splatter=Splatter:Outwards(26))
				Explosion(aoe)
				Hear(Supernova:ExplodeSound)

				Aoe:ForEach that {
					if that.Team != owner.Team {
						Attack(that)
						Aoe:ImpulseAttenuated(that, attenuate=0.4)
						Aoe:Destroy(that)

						that.Tombstone victim {
							NameBlock(owner)
							%(" launched ")
							NameBlock(victim)
							%(" to the edge of the universe ")
						}
					}
				}
			}
		}
	}
}

sound Supernova:Sound(duration=1s) {
	Vibrato(freqModulation=1000) {
		Oscillator(freq=1000)
	}
	Oscillator(wave=$triangle, freq=[900,1000])
	LowPass(freq=450)
	Tremolo(volumeModulation=0.6) {
		Oscillator(freq=7)
	}
	Envelope(attack=0.1s, sustain=0s)
}

sound Supernova:ExplodeSound(duration=1.25s) {
	Vibrato(freqModulation=1000) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=40)
	LowPass(freq=[300,0])
	LowShelf(freq=80, db=12)
	Envelope(attack=0.01s, decay=0.07s, sustain=0s, sustainVolume=0.5)
}
[[abilities/swap.easel]]
.. glyph=BodySwapping:Glyph, color=#ffaa33, damage=0, cooldown=10s

pub symbol WantSwap

pub fn SwapOption(.. ui) {
	SlotOption<WantSwap> {
		H1 { %("Swap") }

		P {
			%("By weaving an ethereal grapple that bridges the distance between you and your enemy, you can trade places, putting them in the danger you were previously in while you take their place on stable ground. ")
		}

		P {
			SlotEffect("Ethereal Interchange", icon="fas fa-exchange") {
				%("Swap places with enemies, obstacles or meteors. If you miss, you will be teleported instead.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.SwapAbility(unit, owner, btn, btnIndex?, btnSize) {
	hook IsInLava {
		CooldownRate(IsInLava ? 1.0 : 0.0)
	}

	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		Spawn projectile {
			.. parent=unit
			.. lifetime=45, dissipation=12
			.. radius=0.5, aoe=3.2, speed=64.0
			.. feather=0.5, shine=0.2, glare=0.7, luminous=1.0, depth=Depth:Projectile
			.. density=100, durability=Durability:High, ccd=true
			.. categories=Category:Projectile
			.. collideWith = Category:Shield | Category:Projectile
			.. sense = Category:Hero | Category:Obstacle

			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			ExpireWith(unit)
			Sing(Swap:Sound)
			ExpireAfterLifetime(Velocity:TicksTo(Pointer).Min(lifetime))

			Collider {
				Shape:Circle(radius=1.0)
			}

			Smoke(
				color=#75e7ff, dissipation=30, splatter=0.2, feather=0.3,
				radius=radius*0.5,
				flutter=Flutter:Helix(radius=0.5, period=20))
			Tether(ancestor=unit, taper=0.7, shadow=0.5)

			on BeforeCollide that {
				if that.Durability >= this.Durability {
					Strobe(growth=0.5, shine=1.0)
					Expire
				}
			}

			await Expire

			let home = unit?.Pos
			let away = projectile?.Pos
			if !(home && away) { return }

			projectile.Puff(count=10, splatter=Splatter:Outwards(20))
			unit.Puff(count=10, splatter=Splatter:Outwards(20))
			Explosion(aoe)

			Aoe:ForEach(filter = Category:Aoe | Category:Projectile) that {
				if that.Team != owner.Team {
					let delta = that.Pos - away
					that.Pos = home + delta
					Attack(that)

					that.Tombstone victim {
						NameBlock(owner)
						%(" translocated ")
						NameBlock(victim)
						%(" to their final resting place ")
					}
				}
			}

			unit.Pos = away
			CleanseBuffs
			SeverTethers
		}
	}
}

sound Swap:Sound(duration=0.75s, cutoff=0.25s) {
	Vibrato(freqModulation=[3600,4200]) {
		Oscillator(freq=30)
	}
	Oscillator(wave=$triangle, freq=[4800,7200], harmonics=[1, 1.33, 1.5])
	Tremolo(volumeModulation=0.1) {
		Oscillator(freq=5)
	}
	Envelope(attack=0.05s, sustain=0s)
	Gain(volume=0.1)
}
[[abilities/teleport.easel]]
.. glyph=Teleport:Glyph, color=#2200ff, cooldown=12.0s, teleportDelay=0.25s, interruptCooldown=0.75s, maxDistance=24

pub symbol WantTeleport

pub fn TeleportOption(.. ui) {
	SlotOption<WantTeleport> {
		H1 { %("Teleport") }

		P {
			%("Master the art of instantaneous travel with Teleport, allowing you to transport yourself to a chosen destination after " + (teleportDelay / TicksPerSecond) + " seconds of concentration. ")
		}

		P {
			SlotEffect("Interruptible", icon="fas fa-hand-paper") {
				%("Any disturbance during the teleportation process will cause it to fail, forcing you to wait for " + (interruptCooldown / TicksPerSecond) + "s before attempting another escape. ")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.TeleportAbility(unit, owner, btn) {
	hook IsInLava {
		CooldownRate(IsInLava ? 1.0 : 0.0)
	}

	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. radius=1.0, indicatorRadius=3.0
		.. luminous=1.0, depth=Depth:Projectile, dissipation=20

		const target = Pointer

		SpeedModifier(-1)
		TurnRateModifier(-1)
		CooldownRate(-1)

		on Interrupt interruptor {
			if interruptor & Interruptor:NotSelf {
				Cooldown = interruptCooldown
				StopIncantation
			}
		}

		await ChargeForDuration(teleportDelay) {
			Sing(Teleport:ChargingSound)
			hook ChargeProportion {
				Sprite(crater=0.7, bloom=3, feather=0.5, shadow=0.25, flicker=ChargeProportion.Mix(0.0, 0.5)) {
					Shape:Circle(radius=ChargeProportion.Mix(indicatorRadius, radius))
				}
			}
		}

		Hear(Teleport:DepartingSound)
		CleanseBuffs
		SeverTethers

		ApplyTeleport(target, maxDistance=, blockFilter=Category:Shield, against=Alliance:Enemy)

		Hear(Teleport:ArrivingSound)
		Explosion(indicatorRadius, crater=0.7)
	}
}

fn body.ApplyTeleport(target, .. maxDistance=null, owner, against=Alliance:All, blockFilter=Category:None) {
	let step = target - body.Pos
	let direction = Direction(step)
	let distance = Length(step).Min(maxDistance)

	if blockFilter {
		let [found,foundDistance] = QueryColliders.WhereCategory(blockFilter).WhereAlliance(owner, against).FindNearestAlongRay(body, direction, maxDistance=distance)
		distance = Min(distance, foundDistance)
	}

	body.Pos = body.Pos + distance * direction
}

sound Teleport:ChargingSound(duration=0.5s) {
	BrownNoise
	BandPass(freq=[100,400], q=10)
	Envelope(attack=0.45s, sustain=0s)
	Gain(volume=0.25)
}

sound Teleport:DepartingSound(duration=0.1s) {
	BrownNoise
	BandPass(freq=800, q=10)
	Envelope(attack=0.03s, sustain=0s)
	Gain(volume=0.5)
}

sound Teleport:ArrivingSound(duration=0.25s) {
	BrownNoise
	BandPass(freq=1100, q=10)
	Envelope(attack=0.03s, sustain=0s)
}
[[abilities/trifire.easel]]
.. glyph=TripleScratches:Glyph, color=#ff0088
.. damage=24.0, numBolts=3, buffDuration=4s
.. lifesteal=0.3, cooldown=1.5s

pub symbol WantTrifire

pub fn TrifireOption(.. ui) {
	SlotOption<WantTrifire> {
		H1 { %("Trifire") }

		P {
			%("Summon a trinity of scorching flames upon your enemies, engulfing them in a long-lasting burn. The bolts spread outwards, making it challenging for foes to avoid from afar, while up close, the combined power of all three overwhelms even the toughest of adversaries.")
		}

		P {
			SlotEffect("Stacking Burn", icon="fas fa-flame") {
				const boltDps = damage / (buffDuration / TicksPerSecond) / numBolts
				%("Each bolt of Trifire will add another stack of " + boltDps + " damage per second to your enemy. ")
				%("You must hit them with Trifire at least once every " + (buffDuration / TicksPerSecond) + " seconds to keep the fire burning. ")
			}
		}

		SlotStats {
			SlotStat("Damage", icon="fas fa-sword") { %(damage) }
			SlotStat("Lifesteal", icon="fas fa-heart") { %((lifesteal * 100.0) + "%") }
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.TrifireAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. damage = damage * unit.DamageModifier

		await Spray(duration=0, count=numBolts, spray=0.03revs) headingOffset index {
			.. damage = damage / count

			Spawn projectile {
				.. parent=unit
				.. lifetime=2.25s, dissipation=20
				.. radius = index <= 0 ? 0.20 : 0.12
				.. speed = index <= 0 ? 24 : 20
				.. density=13.9, ccd=true
				.. durability = Durability:Medium
				.. luminous=1.0, depth=Depth:Projectile
				.. categories=Category:Projectile, collideWith=Category:Solid

				LaunchBody(headingOffset=, speed=24)
				PrepareForCollision
				PropulsiveMotion(0.03)
				Sing(Trifire:Sound)
				ExpireAfterLifetime

				Collider {
					Shape:Circle
				}

				RayEmitter(dissipation=8)

				let canHurtSelf = false
				on BeforeCollide that {
					if canHurtSelf || that.Team != owner.Team {
						Attack(that, damage=0) // All damage is done by Poison, not this - this is to do other things like interrupt the enemy
						if that.HasHp {
							that.StackBuff<burning>(cleansable=true, maxStacks=that.Category & Category:Hero ? 99 : 0) stacks {
								ExpireAfterLifetime(buffDuration)
								Poison(that, damage * (stacks + 1), buffDuration)
								Smoke(that,
									radius=1.0, depth=Depth:Particle,
									color=color.WithOpacity(0.1 + stacks * 0.07), fade=1,
									flutter=$perimeter, splatter=Splatter:Outwards(12))

								that.Tombstone victim {
									NameBlock(owner)
									%(" ignited ")
									NameBlock(victim)
									if stacks > 0 {
										%(" and watched them burn ")
									}
								}
							}
						}
					}
				}
				on AfterCollide that {
					if that.Category & Category:Shield {
						canHurtSelf = true // Can bounce off shield to hurt self
					}
					if that.Durability >= this.Durability {
						Strobe(shine=1.0)
						Puff(count=5, splatter=1, dissipation=30)
						Hear(Trifire:HitSound)
						Expire
					}
				}
			}
		}
	}
}

sound Trifire:Sound(duration=1s) {
	BrownNoise
	BandPass(freq=735, q=[5,15])
	Envelope(attack=0.25s, sustain=0s)
	Gain(volume=0.33)
}

sound Trifire:HitSound(duration=0.33s) {
	Oscillator(wave=$square, freq=[100,0], harmonics=[1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2])
	LowPass(freq=250)
	Envelope(attack=0.01s, decay=0.1s, sustainVolume=0.3, sustain=0s)
}
[[abilities/vanish.easel]]
.. glyph=Hidden:Glyph, color=#00ff88, lifetime=4s, cooldown=10s, fastProportion=0.8

pub symbol WantVanish

pub fn VanishOption(.. ui) {
	SlotOption<WantVanish> {
		H1 { %("Vanish") }

		P {
			%("With a whisper to the shadows, you vanish from sight, your movements becoming as swift as the night. Seize the element of surprise and confront your foe from an unanticipated direction. ")
		}

		P {
			SlotEffect("Shrouded Surge", icon="fas fa-running") {
				%("Move " + (fastProportion * 100) + "% faster for " + (lifetime / TicksPerSecond) + " seconds. ")
			}
			SlotEffect("Invisibility", icon="fas fa-eye") {
				%("For the duration of this spell, you are invisible.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.VanishAbility(unit, owner, btn) {
	hook IsInLava {
		CooldownRate(IsInLava ? 1.0 : 0.0)
	}

	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. radius=1.0
		.. dissipation=60, shine=0, bloom=0, luminous=0, depth=Depth:Buff

		CooldownRate(-1)
		CleanseBuffs
		SeverTethers
		SpeedModifier(fastProportion)
		Vanished(true)
		Sing(Vanish:Sound)

		Puff(count=10, color=#111111, fade=1, feather=0.2, splatter=Splatter:Outwards(5.0))
		Smoke(color=#181818, fade=1, feather=0.2, splatter=Splatter:Outwards(5.0), audience=unit.Team)
		once Expire {
			Puff(count=10, color=#111111, fade=1, feather=0.2, splatter=Splatter:Outwards(5.0))
		}

		once Interrupt {
			StopIncantation
		}

		await Sleep(lifetime)
	}
}

sound Vanish:Sound(duration=4s) {
	BrownNoise
	BandPass(freq=[400,100], q=10)
	Envelope(attack=0.5s, sustain=0s)
}
[[abilities/voidRush.easel]]
.. glyph=Sprint:Glyph, color=#8800ff, lifetime=3.0s, cooldown=10.0s, fastProportion=0.8

pub symbol WantVoidRush

pub fn VoidRushOption(.. ui) {
	SlotOption<WantVoidRush> {
		H1 { %("Void Rush") }

		P {
			%("Tap into the dark energies of the void to quicken your movements while also rendering yourself immune to its malevolent effects.")
		}

		P {
			SlotEffect("Void Surge", icon="fas fa-running") {
				%("Move " + (fastProportion * 100) + "% faster for " + (lifetime / TicksPerSecond) + " seconds. ")
			}
			SlotEffect("Void Immunity", icon="fas fa-stars") {
				%("For the duration of this spell, you are immune to damage from the void. ")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.VoidRushAbility(unit, owner, btn) {
	hook IsInLava {
		CooldownRate(IsInLava ? 1.0 : 0.0)
	}

	on BotRecovering {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		.. dissipation=60, ownerColor=true, depth=Depth:Projectile
		.. shine=0.3, bloom=1.5, luminous=1.0

		CleanseBuffs
		SeverTethers

		unit.SpawnBuff {
			LavaDamageModifier(-1.0)
			Sing(VoidRush:Sound)
			CooldownRate(-1)
			SpeedModifier(fastProportion)

			await Tween(duration=lifetime, initial=1.0, final=0.0) factor {
				unit.Smoke(
					radius=1.0, depth=Depth:Buff,
					color=color.WithOpacity(factor), fade=1,
					feather=0.0, shadow=0.25,
					splatter=Splatter:Outwards(5.0))
			}

			Expire
		}
	}
}

sound VoidRush:Sound(duration=3s) {
	BrownNoise
	BandPass(freq=[960,850], q=10)
	Envelope(attack=0.25s, sustain=0s)
}
[[abilities/whirlwind.easel]]
.. glyph=Snowflake1:Glyph, color=#44ffff, cooldown=7.5s, slowProportion=0.5, buffDuration=2.0s

pub symbol WantWhirlwind

pub fn WhirlwindOption(.. ui) {
	SlotOption<WantWhirlwind> {
		H1 { %("Whirlwind") }

		P {
			%("Summon a bone-chilling vortex that engulfs your enemies, impeding their movements with its icy grip while blowing away incoming attacks with the might of the winds.")
		}

		P {
			SlotEffect("Chilling Blow", icon="fas fa-snowflake") {
				%("Enemies caught in your whirlwind will be slowed " + (slowProportion * 100) + "% for " + (buffDuration / TicksPerSecond) + " seconds.")
			}
		}

		SlotStats {
			SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
		}
	}
}

pub fn ability.WhirlwindAbility(unit, owner, btn) {
	on BotAttacking {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

	Incantation {
		TurnRateModifier(-1.0)

		await ChargeForDuration(6) {
			ChargingIndicator
		}

		Spawn projectile {
			.. parent=unit
			.. lifetime=2s, dissipation=20 
			.. radius=2.4, density=1, speed=12.0
			.. luminous=0, glare=0.7, glareAlpha=0.4, bloom=0, feather=0.5, depth=Depth:Projectile
			.. categories=Category:Projectile, collideWith=Category:None, sense=Category:Hero

			ExpireAfterLifetime
			LaunchBody
			PrepareForCollision
			PropulsiveMotion
			Sing(Whirlwind:Sound)
			Bloom(bloom=4, luminous=0.5)
			Smoke(
				count=2, radius=1.2, splatter=1.3,
				color=#4ff4, fade=1,
				flutter=Flutter:Swirl(radius=0.8, period=13))

			Collider {
				Shape:Circle
			}

			on BeforeCollide that {
				if (that.Category & Category:Hero) && that.Team != owner.Team {
					// spawn buff with separate lifetime from projectile
					that.ReplaceBuff<cold>(cleansable=true) {
						ExpireAfterLifetime(buffDuration)
						SpeedModifier(-slowProportion, that)
						Smoke(that,
							color=#4ff4, fade=1, feather=0.5,
							radius=1.0, dissipation=20, depth=Depth:Particle,
							flutter=$perimeter)

						that.Tombstone victim {
							NameBlock(owner)
							%(" took ")
							NameBlock(victim)
							%("'s breath away")
						}
					}

					Strobe(shine=1.0, growth=0.1)
				}
			}

			Wind(0.3, radius=)
		}
	}
}

sound Whirlwind:Sound(duration=5s, cutoff=0.25s) {
	BrownNoise
	BandPass(freq=240, q=0.7)
	LowShelf(freq=80, db=12)
	Envelope(attack=0.5s, sustain=0s)
	Gain(volume=0.25)
}
[[about.easel]]
pub page fn owner.AboutPage {
	Section {
		H1 {
			%("About Acolyte Fight")
		}
		P {
			Span(bold=true) { %("Acolyte Fight") }
			%(" was created by ")
			Span(bold=true) { %("raysplaceinspace") }
		}
	}
}
[[accumulators/digitCard.easel]]
pub fn DigitCard(ui, heading=null) .. ui {
	Card(align=$center) ui {
		%(heading)
		%(LineBreak)
		Span(scale=4, bold=true) {
			delve()
		}
	}
}
[[accumulators/league.easel]]
const Leagues = GenerateLeagues()

fn GenerateLeagues {
	return {
		grandmaster = { name="Grandmaster", glyph=StarsStack:Glyph, color=#00ffff, minRating=2100 }
		master = { name="Master", glyph=Rank3:Glyph, color=#00b7ff, minRating=1800 }
		diamond = { name="Diamond", glyph=Rank2:Glyph, color=#0066ff, minRating=1600 }
		platinum = { name="Platinum", glyph=Rank1:Glyph, color=#ff0088, minRating=1500 }
		gold = { name="Gold", glyph=Sergeant:Glyph, color=#ffd600, minRating=1300 }
		silver = { name="Silver", glyph=Corporal:Glyph, color=#f1f1f1, minRating=1200 }
		bronze = { name="Bronze", glyph=Private:Glyph, color=#ff7300, minRating=1100 }
		wood = { name="Wood", glyph=Person:Glyph, color=#42e900, minRating=0 }
	}
}

pub fn FindLeague(rating) {
	let last = null
	for kv in Leagues {
		let [id, league] = kv

		if rating >= league.minRating {
			return league
		} else {
			last = league
		}
	}
	return last
}
[[accumulators/numGames.easel]]
pub accumulator owner.NumGames
pub accumulator owner.NumGames:Session

pub fn NumGames:Accumulate {
	for human in (QueryPlayers.WhereIsHuman(true).FindAll) {
		human.Accumulate<NumGames>(1, showOnLeaderboard=true)

		human.Accumulate<NumGames:Session>(1)
		let numGames:session = human.NumGames:Session
		human.AccumulateLater<NumGames:Session>(-numGames:session, after=1h, key=$session)
	}
}
[[accumulators/numOutlasts.easel]]
pub accumulator owner.NumOutlasts
pub accumulator owner.NumOutlasts:Session

pub fn NumOutlasts:Accumulate(ranking) {
	let numPlayers = Length(ranking)
	for i in Range(0,numPlayers) {
		let self = ranking[i]
		if !self.IsHuman { continue }

		let numOutlasts = 0
		for j in Range(i+1,numPlayers) {
			let opponent = ranking[j]
			if opponent && opponent.IsHuman && opponent.UserId != self.UserId && opponent.Team != self.Team {
				numOutlasts += 1
			}
		}

		// Lifetime
		self.Accumulate<NumOutlasts>(numOutlasts, showOnLeaderboard=true)

		// Session
		self.Accumulate<NumOutlasts:Session>(numOutlasts)
		let numOutlasts:session = self.NumOutlasts:Session
		self.AccumulateLater<NumOutlasts:Session>(-numOutlasts:session, after=1h, key=$session)
	}
}
[[accumulators/numWins.easel]]
pub accumulator owner.NumWins
pub accumulator owner.NumWins:Session

pub fn NumWins:Accumulate(ranking) {
	let winningTeam = ranking[0]?.Team
	if !winningTeam { return }

	for human in (QueryPlayers.WhereIsHuman(true).FindAll()) {
		if human.Team == winningTeam {
			// Lifetime
			human.Accumulate<NumWins>(1, showOnLeaderboard=true)

			// Session
			human.Accumulate<NumWins:Session>(1)
			let numWins:session = human.NumWins:Session
			human.AccumulateLater<NumWins:Session>(-numWins:session, after=1h, key=$session)
		}
	}
}
[[accumulators/rating.easel]]
const K = 10 // Learning rate - how quickly does the rating get updated
const R = 2 * 400 // This is the 2 * the difference in points required for a player to be expected to win 76% of the time against another player
const SustainPower = 1 // When a Grandmaster fights a Newbie, suppress impact on the Grandmaster's rating by this power
const MaxActivityBonus = 100

pub accumulator owner.Rating(rating=1000)
pub accumulator owner.UnrankedRating(unranked=1000)
pub accumulator owner.ActivityBonus

pub signal owner.Rating:OnChange(rating, delta)

pub fn Rating:Accumulate(ranking) {
	let numPlayers = Length(ranking)
	for i in Range(0,numPlayers) {
		let me = ranking[i]
		if !me.IsHuman { continue }

		let selfUnranked = me.Unranked
		let selfRating = selfUnranked ? me.UnrankedRating : me.Rating
		let adjustment = 0

		for j in Range(0,numPlayers) {
			if i == j { continue }

			let opponent = ranking[j]
			if !opponent.IsHuman { continue }
			else if me.Team == opponent.Team { continue }
			else if me.UserId == opponent.UserId { continue }

			let opponentUnranked = opponent.Unranked
			let opponentRating = opponentUnranked ? opponent.UnrankedRating : opponent.Rating

			const score = i < j ? 1 : 0 // win == 1, loss == 0
			const diff = opponentRating - selfRating
			const winProbability = 1 / (1 + 10 ** (diff / R))
			const sustainFactor = (1 - winProbability) ** SustainPower
			adjustment += sustainFactor * K * (score - winProbability)
		}

		if selfUnranked {
			me.Accumulate<UnrankedRating>(adjustment)

		} else {
			let delta = adjustment
			if delta != 0 {
				me.Accumulate<Rating>(adjustment, showOnLeaderboard=true)
				me.AccumulateLater<Rating>(0, after=30d, showOnLeaderboard=false, key=$activity)

				let activityBonus = me.ActivityBonus
				if activityBonus < MaxActivityBonus {
					me.Accumulate<ActivityBonus>(1)
					me.AccumulateLater<ActivityBonus>(-1, after=30d)

					delta += 1
					me.Accumulate<Rating>(1)
					me.AccumulateLater<Rating>(-1, after=30d)
				}

				me.Rating:OnChange(rating = selfRating + delta, delta=)
			}
		}
	}
}

pub fn owner.Rating:AnnounceChange(rating, delta) {
	Transmission<ratingAdjustment> {
		P {
			%("Your rating is now ")

			Span(bold=true) {
				%(FindLeague(rating).name + " " + FormatToFixed(rating,0))
			}

			let color = delta > 0 ? #4f0 : #f04
			%(" (")
			Span(bold=true, color=) {
				%(Rating:FormatDelta(delta))
			}
			%(")")
		}
	}
}

fn Rating:FormatDelta(delta) {
	let formatted = Abs(delta) < 1 ? FormatToPrecision(delta, 1) : FormatToFixed(delta, 0)
	if delta >= 0.0 {
		formatted = "+" + formatted
	}
	return formatted
}
[[accumulators/unranked.easel]]
pub preference owner.Unranked

pub fn this.UnrankedTool(owner, placement?) {
	let rating = owner.Rating
	if rating == 0 { return } // Don't show the button to new players

	hook Unranked {
		Toolbar<unrankedTool>(placement=) {
			if Unranked {
				Button(onPress=$toggleUnranked, tooltip="Unranked Mode", tier=$tertiary) {
					Icon("fas fa-gamepad")
				}
			} else {
				Button(onPress=$toggleUnranked, tooltip="Ranked Mode", tier=$tertiary) {
					Icon("fas fa-trophy-alt")
					Blank(chars=0.5)
					Span(bold=true) { %(FindLeague(rating).name) }
					%(" ")
					Span(bold=false) { %(FormatToFixed(rating, 0)) }
				}
			}
		}
	}

	on ButtonPress($toggleUnranked) {
		Unranked = !Unranked
	}
}
[[aliases.easel]]
pub alias body = unit | projectile | shield | saber | obstacle | zone | turf
pub alias life = unit | obstacle
[[buffs/categories.easel]]
pub meld this.FilterCategoriesModifier(filter, @unit) = (modifiers) => {
	let categories = Category:All
	for modifier in modifiers {
		categories &= modifier
	}
	return categories
}
pub meld this.AlsoCategoriesModifier(also, @unit) = (modifiers) => {
	let categories = Category:None
	for modifier in modifiers {
		categories |= modifier
	}
	return categories
}
[[buffs/cooldownRate.easel]]
pub meld this.CooldownRate(modifier, @ability) = (modifiers) => BuffMultiplier(modifiers)
pub meld this.UnitCooldownRate(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/damageModifier.easel]]
pub meld this.DamageModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/densityModifier.easel]]
pub meld this.DensityModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/invisibility.easel]]
// While vanished, some things are still visible (e.g. buffs)
pub meld this.Vanished(invisibility, @body) = (modifiers) => modifiers.Any

// While invisible, everything is invisible
pub meld this.Invisibility(invisibility, @body) = (modifiers) => modifiers.Any
[[buffs/lavaDamageModifier.easel]]
pub meld this.LavaDamageModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/relay.easel]]
pub meld this.Relay(surrogate, @unit) = (surrogates) => surrogates[0]
pub meld this.RelayProportion(proportion, @unit) = (proportions) => proportions.Min ?? 1.0
[[buffs/sizeModifier.easel]]
pub meld this.SizeModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/speedModifier.easel]]
pub meld this.SpeedModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/tangibility.easel]]
pub meld this.Tangibility(filter=Category:None, @unit) = (modifiers) => {
	let tangibility = Category:All
	for modifier in modifiers {
		tangibility &= modifier
	}
	return tangibility
}
pub meld this.SenseAlso(senseAlso=Category:None, @unit) = (modifiers) => {
	let senseAlso = Category:None
	for modifier in modifiers {
		senseAlso |= modifier
	}
	return senseAlso
}
[[buffs/turnRateModifier.easel]]
pub meld this.TurnRateModifier(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[buffs/unkillable.easel]]
pub meld this.Unkillable(unkillable, @life) = (unkillable) => unkillable.Any
[[buffs/vulnerability.easel]]
pub meld this.Vulnerability(modifier, @unit) = (modifiers) => BuffMultiplier(modifiers)
[[constants.easel]]
pub const Alliance:None             = 0b0000
pub const Alliance:All              = 0b1111
pub const Alliance:Friendly         = 0b0011
pub const Alliance:NotFriendly      = 0b1100

pub const Alliance:Self             = 0b0001
pub const Alliance:Ally             = 0b0010
pub const Alliance:Enemy            = 0b0100
pub const Alliance:Neutral          = 0b1000

pub const Utility:None=-1
pub const Utility:Minimum=0
pub const Utility:Low=25
pub const Utility:Medium=50
pub const Utility:High=75
pub const Utility:Maximum=100

pub const Category:None             = 0b00000000000000000000000000000000
pub const Category:All              = 0b11111111111111111111111111111111
pub const Category:Solid            = 0b00000000000000001111111111111111 // by default, the last (lowest) 16 bits are used for physics

// Physical attributes - setting any one of these will cause other entities to collide with us
pub const Category:Hero             = 0b00000000000000000000000000000001
pub const Category:Projectile       = 0b00000000000000000000000000000010
pub const Category:Obstacle         = 0b00000000000000000000000000000100
pub const Category:Shield           = 0b00000000000000000000000000001000
pub const Category:Turf             = 0b00000000000000000000000000010000
pub const Category:Zone             = 0b00000000000000000000000000100000
pub const Category:Massive          = 0b00000000000000000000000001000000 // Meteors or beams destroy everything

// Non-physical attributes - setting these won't cause other entities to collide with us (by default)
pub const Category:Grabber          = 0b00000000000000010000000000000000 // This is a grapple
pub const Category:CanGrab          = 0b00000000000000100000000000000000 // Grapple can hold onto this
pub const Category:HurtByLava       = 0b00000000000001000000000000000000 // Can be hurt by lava
pub const Category:Aoe              = 0b00000000000010000000000000000000 // Affected by area-of-effect
pub const Category:AlwaysBlow       = 0b00000000000100000000000000000000 // Always affected by whirlwind, even when on the same team
pub const Category:Destructible     = 0b00000000001000000000000000000000 // Destroyed by explosions
pub const Category:Ghost            = 0b10000000000000000000000000000000 // A unit for a dead player

pub const CloseEnough=0.0001

pub const Depth:Default=100
pub const Depth:Indicator=10
pub const Depth:Particle=30
pub const Depth:Projectile=50
pub const Depth:Shield=80
pub const Depth:Unit=110
pub const Depth:Charger=120
pub const Depth:Label=130
pub const Depth:Buff=140 // Buff underneath unit to avoid color washout
pub const Depth:Saber=150
pub const Depth:Obstacle=160
pub const Depth:Tether=180
pub const Depth:Aim=210
pub const Depth:Bloom=220 // Bloom underneath everything to avoid color washout
pub const Depth:Zone=230
pub const Depth:Turf=240

pub const Durability:Minimum=-100
pub const Durability:Shield=-50
pub const Durability:None=0
pub const Durability:Low=25
pub const Durability:Medium=50
pub const Durability:High=75
pub const Durability:Maximum=100
[[core/attack.easel]]
pub signal this.Hurt

const DamageMitigationInterval = 2s
const UnmitigatedDamageProportion = 0.25
field unit.DamagePerAttacker
field unit.CurrentAttacker

pub prop unit.NumAttackers

pub fn Attack(that, damage, .. lifesteal?, minHealth?, noHurt?, noRelay?, noInterrupt?, noLavasteal?, unit?) {
    if !that { return 0 }

	let loss = damage > 0 ? that.TakeDamage(that.MitigateDamage(damage, attacker=unit)) : 0

    if unit && lifesteal > 0.0 && loss > 0.0 && (that.Category & Category:Hero) && that.Owner && that.Owner != unit.Owner {
        // Lifesteal back to owner, but only if the target is owned by another enemy player
        unit.Heal(loss * lifesteal)
    }

    if !noHurt && (loss > 0 || damage == 0) {
        // Send hurt event if either was actually hurt, or if this was not meant to hurt (maybe just a knockback-only spell)
        that.Hurt
    }

    if !noInterrupt {
        that.Interrupt
    }
    
    if !noLavasteal && unit && (that.Category & Category:HurtByLava) && that.Owner {
        that.LavaLifestealer = unit
    }

	return loss
}

// If an acolyte gets attacked by multiple enemies at once, only the one who does the most damage will do full damage.
fn unit.MitigateDamage(damage, attacker) {
    if (!(damage > 0 && unit && attacker && (unit.Category & Category:Hero) && (attacker.Category & Category:Hero))) {
        // Do not waste computation on non-heroes or zero damage
        return damage
    }

    const damagePerAttacker = unit.DamagePerAttacker ??= {}

    const incumbentDamage = damagePerAttacker[unit.CurrentAttacker] ?? 0
    const previousDamage = damagePerAttacker[attacker]
    if !previousDamage {
        unit.NumAttackers += 1
    }
    const newDamage = previousDamage + damage

    let acceptedDamage = UnmitigatedDamageProportion * damage
    if newDamage > incumbentDamage {
        acceptedDamage = Max(acceptedDamage, newDamage - incumbentDamage)
        unit.CurrentAttacker = attacker
        unit.TimeoutDamageMitigationAfter(DamageMitigationInterval)
    }
    damagePerAttacker[attacker] = newDamage

    return acceptedDamage
}

behavior fn unit.TimeoutDamageMitigationAfter(timeout) {
    await Sleep(timeout)
    delete unit.DamagePerAttacker
    delete unit.CurrentAttacker
    unit.NumAttackers = 0
}
[[core/buff.easel]]
pub signal unit.CleanseBuffs

field unit.PreviousBuff<Id>
field unit.PreviousBuffOwner<Id>
field unit.PreviousBuffStacks<Id>

pub fn unit.SpawnBuff(.. cleansable=false) .. *buff {
	return Subspawn buff {
		if cleansable {
			Buff:Cleansable(unit)
		}
		delve(.. buff)
	}
}

pub fn unit.ReplaceBuff<Id>(.. cleansable=false) .. *buff {
	unit.PreviousBuff<Id>.Despawn

	return Subspawn buff {
		if cleansable {
			Buff:Cleansable(unit)
		}
		unit.PreviousBuff<Id> = buff
		delve(.. buff)
	}
}

pub fn unit.StackBuff<Id>(.. maxStacks=null, owner?=null, cleansable=false) stacks .. *buff {
	let stacks = 0
	if unit.PreviousBuff<Id>.Despawn {
		if unit.PreviousBuffOwner<Id> == owner {
			stacks = Min(maxStacks, (unit.PreviousBuffStacks<Id> ?? 0) + 1)
		}
	}

	return Subspawn buff {
		if cleansable {
			Buff:Cleansable(unit)
		}

		unit.PreviousBuff<Id> = buff
		unit.PreviousBuffStacks<Id> = stacks
		unit.PreviousBuffOwner<Id> = owner
		delve(stacks, .. buff)
	}
}

fn buff.Buff:Cleansable(unit) {
	if unit {
		once CleanseBuffs {
			Despawn
		}
	}
}

pub fn BuffMultiplier(modifiers) {
	let increase = 0
	let decrease = 0
	for modifier in modifiers {
		if modifier > 0 {
			increase = Max(increase, modifier)
		} else if modifier < 0 {
			decrease = Min(decrease, modifier)
		}
	}
	return (1 + increase) * Max(0, 1 + decrease)
}
[[core/cooldown.easel]]
pub prop ability.Cooldown

pub behavior fn ability.CooldownTicker(.. unit) {
	Cooldown ??= 0
	loop {
		await Tick
		let cooldown = Cooldown
		if cooldown > 0 {
			cooldown -= CooldownRate * UnitCooldownRate
			Cooldown = Max(0, cooldown)

		} else {
			// Nothing to do, wait until the cooldown changes
			await Cooldown
		}
	}
}
[[core/health.easel]]
pub prop life.Hp
pub prop life.MaxHp

pub signal life.BeforeOutOfHealth

pub fn life.HasHp {
	return life.MaxHp > 0
}

pub fn life.HpProportion {
	return life.Hp / life.MaxHp
}

pub fn life.Health(maxHp=100.0) {
	Hp = maxHp * ((life.Hp ?? maxHp) / (life.MaxHp ?? maxHp))
	MaxHp = maxHp

	hook life.Hp {
		await ReapStart
		while Unkillable {
			await Unkillable
		}
		if Hp <= 0.0 {
			BeforeOutOfHealth
			Expire
			break
		}
	}
}

// Returns the amount of damage applied
pub fn that.TakeDamage(damage, .. minHealth?=0, noRelay?) {
	let loss = 0
	if HasCommenced && that.Hp {
		if damage <= 0.0 { return loss }

		// Armor
		let damage = (damage * that.Vulnerability).Min(that.Hp - minHealth)
		if damage <= 0.0 { return loss }

		// Relay damage, e.g. to a linked enemy
		if !noRelay {
			let surrogate = that.Relay
			if surrogate {
				let relayDamage = damage * that.RelayProportion
				loss += surrogate.TakeDamage(relayDamage, noRelay=true)

				damage -= relayDamage
				if damage <= 0.0 { return loss }
			}
		}

		// Apply damage to target
		that.Hp -= damage
		loss += damage
	}
	return loss

}

pub fn that.Heal(heal) {
	if that?.MaxHp {
		let newHp = Min(that.MaxHp, that.Hp + heal)
		if newHp > that.Hp {
			that.Hp = newHp
		}
	}
}
[[core/healthbar.easel]]
symbol HealthbarFork
symbol BackgroundSprite
symbol FillSprite
symbol HintSprite

pub behavior fn this.Healthbar(life, .. body, height=0.2, width, verticalOffset, advent=3s, backgroundColor=#0008, depth=Depth:Indicator) {
	if !(life && body && life.MaxHp && height > 0.0 && width > 0.0) {
		// Zero-sized healthbar means no healthbar
		delete Healthbar
		return
	}

	.. strobe=false, noRotation=true

	let up = verticalOffset
	let right = width / 2.0
	let left = -right

	// Before start of game
	await ReadyToBegin

	if !HasCommenced {
		loop {
			await TickEnd

			let proportion = CommenceTick ? (CommenceTick - Tick) / Max(1,advent) : 1.0
			if proportion <= 0 {
				break // The game has started
			}

			Sprite<FillSprite>(body, color=proportion.Mix(#8f8, #fff)) {
				Line(cap=true, radius=height, points=[@(left,up), @(right,up)])
			}
		}
	}

	// During game
	Sprite<BackgroundSprite>(color=backgroundColor, depth=depth+1) {
		Line(cap=true, radius=height, points=[@(left,up), @(right,up)])
	}

	let indicatorHp = life.Hp
	loop {
		await TickEnd

		// Render
		let hp = life.Hp
		let proportion = hp / life.MaxHp
		let hintProportion = indicatorHp / life.MaxHp
		let color = proportion.BlendHue(#f04, #0f0)
		let hintColor = hintProportion > proportion ? #fff : Darken(color, 0.5)

		let mid = left + proportion * width
		let hint = left + hintProportion * width
		if hint > mid {
			// Lost health
			Sprite<FillSprite>(color=) {
				Line(headCap=true, radius=height, points=[@(left,up), @(mid,up)])
			}

			Sprite<HintSprite>(color=hintColor) {
				Line(tailCap=!(hint < right), radius=height, points=[@(mid,up), @(hint,up)])
			}

		} else if hint == mid {
			Sprite<FillSprite>(color=) {
				Line(headCap=true, tailCap=!(mid < right), radius=height, points=[@(left,up), @(mid,up)])
			}
			delete Sprite<HintSprite>

		} else {
			// Gained health
			Sprite<FillSprite>(color=) {
				Line(headCap=true, radius=height, points=[@(left,up), @(hint,up)])
			}

			Sprite<HintSprite>(color=hintColor) {
				Line(tailCap=!(mid < right), radius=height, points=[@(hint,up), @(mid,up)])
			}
		}

		// Update indicatorHp
		let delta = hp - indicatorHp
		if delta == 0.0 {
			// Stop refreshing the healthbar until the health changes
			await life.Hp
		} else {
			if Abs(delta) < 1.0 {
				// Close enough
				indicatorHp = hp
			} else if delta > 0.0 {
				// Adjust upwards slower so lifesteal clearer
				indicatorHp += 0.01 * delta
			} else {
				indicatorHp += 0.025 * delta
			}
		}
	}
}

pub delete fn this.Healthbar {
	delete Sprite<BackgroundSprite>
	delete Sprite<FillSprite>
	delete Sprite<HintSprite>
}
[[core/incantation.easel]]
pub fn ability.NoIncantation(.. unit, owner, glyph, btn) .. {
	CommandBinding(btn, owner=) // Binding still needed so users can Shift+KeyBinding to edit their ability
	CommandIcon(opacity=0.5, color=#333, glyphColor=#aaa .. glyph)
	CommandText("") // Display no text on the button because the player cannot invoke this command

    if !(unit.Category & Category:Ghost) {
		// Ghosts can only edit their abilities, not use them
		delve()
	}
}

pub fn ability.Incantation(.. unit, owner, glyph, color, cooldown, btn) .. *incantation {
	CommandBinding(btn, owner=)

    if unit.Category & Category:Ghost {
		// Ghosts can only edit their abilities, not use them
		CommandIcon(.. glyph color)

	} else {
		CooldownTicker
		Silenceable

		hook Cooldown {
			let cooldown = Cooldown
			let color = color
			let glyphColor = #fff
			if cooldown >= 1s {
				color = #222
				glyphColor = #999
			} else if cooldown > 0.1s {
				color = #777
				glyphColor = #eee
			} else if cooldown > 0s {
				color = #111
				glyphColor = #777
			}

			let text = null
			if cooldown > 1s {
				text = FormatToFixed(cooldown / TicksPerSecond, 0)
			} else if cooldown > 0s {
				text = FormatToFixed(cooldown / TicksPerSecond, 1)
			}

			CommandIcon(.. glyph color glyphColor)
			CommandText(text)
		}
		
		on ability.InvokeCommand {
			RecheckCommenceCountdown
		
			ability.Subscope incantation {
				Incantation:Queue
				if Cooldown == 0 {
					Cooldown = cooldown
					delve()
				}
			}
		}
	}
}

field unit.CurrentIncantation
fn incantation.Incantation:Queue(unit) {
	Interrupt(Interruptor:Self) // This may cancel an existing incantation if it is cancellable, freeing up the queue
	loop {
		let current = unit.CurrentIncantation
		if !Exists(current) { break } // No current incantation, time for us to take over!
		await current.Expire
		await Tick // Wait until the next tick to ensure the incumbent has expired
	}
	unit.CurrentIncantation = incantation
}

pub fn StopIncantation(incantation) {
	incantation.Expire
}
[[core/interrupt.easel]]
pub const Interruptor:None      = 0b00
pub const Interruptor:Self      = 0b01
pub const Interruptor:NotSelf   = 0b10
pub const Interruptor:Any       = 0b11

pub signal unit.Interrupt(interruptor=Interruptor:NotSelf)
[[core/inventory.easel]]
pub prop unit.Inventory
symbol Inventory
symbol Item
preference owner.InventoryInner
symbol None

pub fn this.InventoryToolbar(.. owner, unit, placement=$important, icon="fas fa-shop") {
    const showInventoryDialog = Modal<inventoryDialog> {
        H1 { %("Inventory") }
        PipTabs<Inventory> {
            for item in unit.Inventory {
                PipTab<Item+item>(glyph=item.glyph, color=item.color) {
                    H1 { %(item.name) }
                    P { %(item.description) }
                }
            }
            hook owner.Preference<InventoryInner> {
                Select(owner.Preference<InventoryInner>)
            }
        }
        on Selected<InventoryInner> choice {
            owner.Preference<InventoryInner> = choice
        }
     }
    Toolbar<loadoutTool>(placement=) {
        Button(onPress=showInventoryDialog, icon=, collapsable=true, repeatable=true) {
            %("Inventory")
        }
    }
}

pub fn unit.InventoryService(.. owner) {
    unit.Inventory ??= []
    hook owner.Preference<InventoryInner> {
        // let choice = owner.Preference<InventoryInner> ?? None
        // BuyItem(choice)
        
        owner.Preference<InventoryInner> = None
    }
}

pub fn unit.AddItem(.. name="", description="", glyph=ArcingBolt:Glyph, color=#000) {
    Debug:Log(name)
    unit.Inventory = unit.Inventory.ArrayPush({name, description, glyph, color})
}

[[core/silence.easel]]
pub signal unit.Silence(silence)

pub fn ability.Silenceable(unit) {
	on unit.Silence silence {
		if Cooldown < silence {
			Cooldown = silence
		}
	}
}
[[core/slot.easel]]
pub prop owner.SlotsUneditable(uneditable)

field unit.PreviousAbility<Slot>(ability)

/// Spawns an ability on the unit, and replaces the spawn whenever the slot changes
pub fn unit.SlotAbility<Slot>(.. owner, slotDefault?, btnIndex?, btnSize?) choice .. *ability {
	hook owner.Preference<Slot> {
        // Destroy previous ability
		let previous = unit.PreviousAbility<Slot> ?? null
        let cooldown = previous.Cooldown ?? 0 // capture cooldown so we can assign it to the new ability
		previous.Despawn

        // Create new ability
		unit.PreviousAbility<Slot> = Subspawn ability {
            Cooldown = cooldown
			CommandPlacement(.. btnIndex btnSize)
			delve(owner.Preference<Slot> ?? slotDefault)
		}
	}
}

/// If the slot has no ability, this displays a blank icon for the slot which allows a new ability to be selected instead
pub fn ability.SlotWithoutAbility(.. owner) {
	CommandIcon(opacity=0.5, color=#333, glyphColor=#aaa, glyph=BlankGlyph)
}

/// Attachs a popup to an ability which allows the ability to be changed
pub fn ability.SlotPopup<Slot>(.. owner) .. ui {
	hook SlotsUneditable {
		if SlotsUneditable {
			delete Modal<Slot+slotPopup>
			delete CommandPopup

		} else {
			const showPopup = Modal<Slot+slotPopup>(placement=$bottom) {
				delve()
			}
			CommandPopup(showPopup)
		}
	}
}

/// Adds a SlotEditor pip tab panel to the UI
pub fn this.SlotEditor<Slot>(ui .. btn?, owner, slotDefault?) .. ui {
	PipTabs<Slot> {
		delve()

		if InPageMode && btn {
			// Don't show the rebinding block in-game - it takes too much space
			Right { RebindingBlock }
		}

		hook owner.Preference<Slot> {
			Select(owner.Preference<Slot> ?? slotDefault)
		}
	}
    on Selected<Slot> choice {
        owner.Preference<Slot> = choice
    }
}
/// Adds a SlotEditor dropdown to the UI
pub fn this.SlotDropdown<Slot>(ui .. owner, slotDefault?) .. ui {
	Dropdown<Slot> {
		delve()
		hook owner.Preference<Slot> {
			Select(owner.Preference<Slot> ?? slotDefault)
		}
	}
    on Selected<Slot> choice {
        owner.Preference<Slot> = choice
    }
}

/// Adds an option tab for one particular ability to a SlotEditor - must be called within SlotEditor
pub fn SlotOption<Id>(.. ui, glyph, color) .. ui {
	PipTab<Id> { delve() }
}

pub fn SlotEffect(effect, icon .. ui) .. ui {
	if !IsEmpty(ui) {
		%(LineBreak)
	}
	Span(scale=0.8) {
		Span(bold=true, italic=true, color=#eee) {
			Icon(icon=)
			%(" ")
			%(effect)
			%(": ")
		}
		Span(italic=true, color=#ddd) {
			delve()
		}
	}
}

pub fn SlotStats(.. ui) .. ui {
	Footer {
		Span(scale=0.9) {
			delve()
		}
	}
}

pub fn SlotStat(stat, icon .. ui) .. ui {
	if !IsEmpty(ui) {
		Blank(chars=1)
	}
	Span(color=#eee, tooltip=stat) {
		delve()
		%(" ")
		Icon(icon=)
	}
}

pub fn this.SlotLoadoutTool(tooltip .. owner, placement=null, icon="fas fa-ballot-check") .. ui {
	hook SlotsUneditable {
		if SlotsUneditable {
			delete Modal<loadoutDialog>
			delete Toolbar<loadoutTool>

		} else {
			const showLoadoutDialog = Modal<loadoutDialog> { delve() }
			Toolbar<loadoutTool>(placement=) {
				Button(onPress=showLoadoutDialog, icon=, collapsable=true, repeatable=true) {
					%(tooltip)
				}
			}
		}
	}
}

pub fn this.SlotRandomizeTool(tooltip .. owner, placement=null, icon="fas fa-dice") .. {
	hook SlotsUneditable {
		if SlotsUneditable {
			delete Toolbar<randomizeTool>

		} else {
			Toolbar<randomizeTool>(placement=) {
				Button(onPress=$randomize, icon=, collapsable=true, repeatable=true) {
					%(tooltip)
				}
			}
			on ButtonPress($randomize) {
				delve()
			}
		}
	}
}

glyph BlankGlyph(path="")
[[essence.easel]]
// This signal should NEVER be fired.
pub signal this.Never

// Log function
/*
Example:
Debug:Log("hello")
*/
pub fn this.Debug:Log(message) {
    Transmission<debug> {
        P(scale=0.9) {
            %("DEBUG: " + message)
        }
    }
}

pub fn this.Debug:Warn(message) {
    Transmission<warn> {
        P(scale=0.9, color=#e8e412) {
            %("WARN: " + message)
        }
    }
}

pub fn this.Debug:Error(message) {
    Transmission<error> {
        P(scale=0.9, color=#d62f20, bold=true) {
            %("ERROR: " + message)
        }
    }
}

// LaunchBody with offset
pub fn body.LaunchBodyFrom(
	parent,
	..
    offset?,
	headingOffset?,
	pos=parent.Pos + offset, speed,
	heading = parent.Heading + headingOffset, turnRate?,
	immovable?, ccd?) {

	Body(velocity = Direction(heading) * speed)
}

[[glyphs/andromedaChain.easel]]
pub glyph AndromedaChain:Glyph(
	path="M105.22 18.688l388.717 260.656v-22.5L138.78 18.688h-33.56zm78.75 0l309.967 158.406v-20.97L225.063 18.69H183.97zm103.593 0l-.438 1.28 206.813 70.813V71.03L341.03 18.688h-53.467zM18.875 20.813v15.062L53.47 74.813c5.84 5.452 13.5 5.628 19 .124 5.63-5.636 5.726-13.274.405-19.03l-.094-.094-37.436-35h-16.47zm70.313 25.593c5.78 8.142 7.34 18.392 4.718 27.688 1.283.737 2.51 1.636 3.656 2.72l24.407 22.31c1-.096 1.993-.16 3-.155 7.4.03 14.8 2.816 20.5 8.124.048.046.106.078.155.125l15.594 14.155c.936-13.26-3.613-26.822-13.657-37.063l-35.657-25.468-.625-.47-.53-.53c-6.127-6.126-13.707-9.942-21.563-11.438zM42.03 89.656c.792 9.223 4.696 18.222 11.69 25.22l.56.593.47.655 25.063 35.75c10.533 10.273 24.57 15.027 37.937 13.938l-14.125-16.625-.313-.344.032-.03c-5.307-5.824-7.88-13.28-7.75-20.69L73.374 101c-1.265-1.346-2.294-2.826-3.06-4.375-9.732 2.17-20.308-.296-28.283-6.97zm-23.374 19.75v33.563L254 493.97h22.5L18.656 109.405zm-18.687 5.5l-.095.063.094.124v-.188zm125.093 2.188c-2.567-.044-5.092 1.12-7.5 3.53-4.82 4.824-4.895 10.883-.313 15.75l.156.19.156.186 65.657 77.313c7.524 6.852 17.437 7.026 24.53-.063 7.246-7.242 7.38-17.267.53-24.72l-75.343-68.343-.093-.062-.063-.063c-2.566-2.423-5.15-3.674-7.718-3.718zm83.718 25.5c-1.908.01-3.82.118-5.718.28-5.025.432-10.007 1.426-14.875 2.97l33.032 29.937.28.25.25.25c5.085 5.41 8.232 11.988 9.406 18.845.63.512 1.24 1.055 1.844 1.625l47.344 43.22c.576-.022 1.142-.035 1.72-.032 10.682.055 21.378 4.164 29.78 12.03l.125.095 30.31 27.437c4.5-25.672-3.087-53.023-22.78-72.97l-58.25-41.593-.625-.468-.563-.532c-13.705-13.7-31.568-20.898-49.375-21.313-.635-.015-1.27-.035-1.906-.03zM18.657 189.156v41.094l134.78 263.72h20.97L18.656 189.155zM-.03 192.062l-.657.344.656 1.28v-1.624zm141.75 2.032c-6.78 24.135-.748 51.248 18.093 70.094l.562.593.47.658 40.78 58.156c18.35 18.12 43.006 26.56 66.563 24.53h.03c3.847-.316 7.694-.964 11.5-1.874l-28.468-33.5-.313-.375c-5.702-6.188-9.265-13.6-10.718-21.313-2.044-1.26-3.99-2.746-5.814-4.468l-40.156-49c-8.756-.35-17.42-3.826-24.188-10.22l-.375-.343-.343-.405-27.625-32.53zm140.436 63.97c-5.837-.07-11.635 2.355-16.687 7.405-10.108 10.1-10.294 24.21-.626 34.467l.156.157.156.187L373.78 428.095c14.64 13.607 35.284 14.037 49.345 0 14.228-14.204 14.422-34.882.78-49.438l-.06-.062L299.28 265.78l-.06-.06-.064-.064c-5.266-4.966-11.162-7.525-17-7.594zm-263.5 32.498v57.72L68.53 493.968h19.75L18.657 290.56zm402.031 12.375c-2.976.05-6.112.327-9.656.625H411c-11.373.984-22.724 3.574-33.594 7.782l59.53 53.906.283.25.25.28c7.772 8.26 12.488 18.277 14.155 28.658 4.325 2.11 8.453 4.946 12.25 8.53l29.844 27.344-.064-103.687c-20.602-15.05-45.012-22.958-69.344-23.625l-.5-.03h-.187c-.963-.043-1.945-.05-2.938-.033zm-111.625 77.875c-14.07 37.914-8.72 81.76 15.72 115.375h102.187l-25.408-30.906c-2.534-2.692-4.68-5.572-6.437-8.592-12.428-.866-24.67-6.003-34.406-15.188l-.376-.344-.344-.406-50.938-59.938z",
	credit="https://game-icons.net/lorc/originals/andromeda-chain.html",
)
[[glyphs/angelOutfit.easel]]
pub glyph AngelOutfit:Glyph(
	path="M260.72 29.094c-54.533 0-98.97 21.704-98.97 48.312 0 26.61 44.437 48.28 98.97 48.28 54.53 0 98.967-21.67 98.967-48.28S315.25 29.094 260.72 29.094zm0 13.25c40.07 0 71.81 15.508 71.81 35.062s-31.74 35.47-71.81 35.47c-40.073 0-72.69-15.916-72.69-35.47 0-19.552 32.617-35.064 72.69-35.062zM86.53 57.187c-13.242-.094-32.234 14.59-42.31 37.688-43.3 99.244-9.583 359.695 87.874 351.97-22.002-50.492-43.8-107.983-56.72-168.75 26.337 72.494 72.33 135.58 117.845 120.186-32.017-40.185-66.048-87.265-90.032-140.342 35.016 59.175 85.37 105.853 123.03 85.5-29.742-26.583-61.568-57.524-88.812-93.25 39.647 37.38 87.092 61.34 112.25 37.75-47.69-21.07-94.37-53.67-125.062-89.75-16.312-19.176-28.195-39.39-32.72-60-2.26-10.306-2.508-20.796-.468-30.938.02-.095.043-.186.063-.28.007-.044.022-.083.03-.126 4.05-21.265 15.043-35.413 4.5-45.97-2.484-2.487-5.76-3.66-9.47-3.687zm347.658 0c-3.71.027-6.954 1.2-9.438 3.688-8.176 8.186-3.416 18.564 1.03 32.72 6.153 14.187 7.144 29.566 3.845 44.593-4.524 20.61-16.44 40.824-32.75 60-30.798 36.206-77.67 68.907-125.53 89.968 25.22 23.208 72.482-.71 112-37.97-27.245 35.728-59.07 66.67-88.814 93.25 37.662 20.355 88.016-26.323 123.033-85.498-23.985 53.077-58.016 100.157-90.032 140.343 45.515 15.395 91.478-47.69 117.814-120.186-12.918 60.768-34.686 118.26-56.688 168.75 97.457 7.726 131.142-252.725 87.844-351.97-10.077-23.097-29.07-37.78-42.313-37.686zm-22.22 73.97c-100.397 68.228-200.733 82.462-301.25 5.468 4.02 15.655 13.89 32.733 28.126 49.47 28.922 34 75.48 66.378 121.906 86.31 46.426-19.932 92.984-52.31 121.906-86.31 14.98-17.613 25.138-35.594 28.72-51.907.223-1.02.416-2.027.593-3.032z",
	credit="https://game-icons.net/lorc/originals/angel-outfit.html",
)
[[glyphs/arcingBolt.easel]]
pub glyph ArcingBolt:Glyph(
	path="M291 46.438c29.89 36.34 55.086 74.792 74.156 115.062-49.052-38.586-105.036-68.945-168.78-89.344 40.696 29.09 78.052 61.91 110.624 97.188-37.52-20.55-74.29-31.632-107.438-34.938 33.73 14.255 77.803 44.654 111.063 83.03.626 1.004 1.216 2.002 1.78 3 .03.024.066.042.095.064l-.03.03c-.02-.03-.046-.06-.064-.093-19.063-14.253-54.482-30.81-95.312-40.78-50.3-3.666-101.766.18-154.438 11.624 60.61 5.896 118.714 18.332 172.844 37.97-79.658 6.653-155.155 45.72-217.25 121.47C55.795 329.3 101.74 310.78 143.625 302c40.242-11.185 72.465-12.254 95.563-6.5.04-.004.085.004.125 0l-.032.03c-.03-.007-.06-.022-.093-.03-28.123 2.88-74.114 16.98-115.53 40.688-44.49 40.303-83.695 98.33-97.22 158.78h129.657c22.906-37.08 51.314-68.357 82.78-93.5-6.392 18.97-9.292 37.678-9.218 55.438 12.05-31.583 44.076-73.017 86.72-96.344 11.652 22.34 32.257 39.923 58.437 46.938 49.563 13.28 100.75-16.278 114.03-65.844 4.554-16.994 4.068-34.187-.53-49.97 18.47-69.046-6.238-141.86-56.563-200.842 9.922 38.16 12.75 77.235 5.844 114.47C404.774 140.59 355.627 87.993 291 46.436zm-61.344 410.468l-.03.094.03.03v-.124zm-30.094-322.5c-.03-.012-.064-.02-.093-.03l-.032.03c.04.004.084-.004.125 0zm184.75 110.125c25.482 28.396 40.14 73.42 39.438 101.44 15.463-40.44 16.46-62.094 4.97-96.595 13.306 5.783 24.22 15.16 31.936 26.625 3.704 26.134-8.748 63.216-22.375 79.313 14.565-9.242 26.246-21.02 35-35.375-.19 5.586-.987 11.234-2.5 16.875-10.666 39.81-51.348 63.29-91.155 52.625-35.814-9.597-58.406-43.468-54.813-79.157 35.783 4.916 67.725 25.49 83.375 44.876-9.22-30.88-31.59-60.696-69.968-80.72 11.017-15.548 27.573-26.22 46.092-29.905z",
	credit="https://game-icons:net/lorc/originals/arcing-bolt:html",
)
[[glyphs/atomicSlashes.easel]]
pub glyph AtomicSlashes:Glyph(
	path="M222.25 51.813c-59.778.797-102.472 36.19-97.47 91.593-175.105 173.99-42.24 388.292 82.72 301.281 234.398 24.897 320.07-138.203 253.688-215.875-68.157-127.71-166.197-177.97-238.938-177zm35.28 54c59.782-.537 138.234 35.254 194.314 113.593-32.668-28.783-91.096-41.137-175.594-17.906 233.673-4.713 159.012 242.056-65.813 241.094 23.605-17.352 46.84-45.562 67.563-86.97-141.047 157.87-264.124-48.664-152.094-203.78 6.14 35.83 31.486 79.165 83.5 126.5-75.762-109.73-29.625-171.834 48.125-172.53zm20.314 112.03c-28.427-.322-54.126 19.32-60.375 48.188-7.143 32.992 13.82 65.547 46.81 72.69 32.992 7.14 65.516-13.823 72.658-46.814 7.14-32.99-13.822-65.545-46.813-72.687-4.124-.894-8.22-1.33-12.28-1.376z",
	credit="https://game-icons.net/lorc/originals/atomic-slashes.html",
)
[[glyphs/aura.easel]]
pub glyph Aura:Glyph(
	path="M320.938 13.28c-16.646 34.584-38.466 60.157-63.094 60.157-24.522 0-47.035-25.275-63.656-59.593.366 39.358-9.71 90.884-30.938 105.125-21.228 14.24-49.64-12.002-78.844-32.126 17.455 34.04 42.095 67.5 29.78 92.28-12.21 24.576-59.172 35.96-92.874 35.626 29.338 19.29 78.842 45.803 78.844 74.188.002 28.384-49.504 53.71-78.844 73 33.702-.333 80.663 11.612 92.876 36.187 12.227 24.61-9.03 56.31-33.75 85.563 44.826-15.413 65.142-5.735 85.374 10.812h31.75c-42.74-35.413-72.062-107.828-72.062-191.563-.002-118.62 58.92-214.906 131.406-214.906 72.488 0 131.406 96.29 131.406 214.907 0 83.74-29.317 156.153-72.062 191.563h27.313c19.847-14.62 39.796-25.65 89.687-9.28-26.233-30.264-42.2-62.484-29.97-87.095 12.257-24.665 56.658-36.612 90.533-36.188-29.4-19.297-75.344-44.584-75.344-73 0-28.415 45.943-54.89 75.342-74.187-33.874.424-78.273-10.962-90.53-35.625-12.315-24.78 9.982-58.24 27.437-92.28-29.202 20.12-57.583 46.385-78.845 32.124-21.262-14.263-31.382-66.13-30.938-105.69zm-68.97 93.75c-19.56 2.543-37.343 25.564-37.343 55.407 0 16.447 5.67 30.986 14 41.032l10.156 12.218-15.593 2.937c-10.815 2.035-18.743 7.737-25.53 17.063-6.79 9.325-11.984 22.344-15.626 37.343-6.585 27.128-8.078 60.24-8.31 89.47h36.093l.656 8.656 9.124 122.563h76.187l8.095-122.5.563-8.72h34.375c-.026-29.592-.44-63.166-6.407-90.5-3.295-15.095-8.287-28.096-15.156-37.313-6.87-9.216-15.133-14.897-27.28-16.78l-15.94-2.47 10.064-12.593c7.97-9.996 13.375-24.36 13.375-40.406-.002-31.817-19.884-55.313-41.44-55.313-2.54 0-3.96-.103-4.03-.094h-.03z",
	credit="https://game-icons.net/1x1/lorc/aura.html",
)
[[glyphs/bodySwapping.easel]]
pub glyph BodySwapping:Glyph(
	path="M130.375 18.438c-19.615 0-36.445 9.542-47.594 24-11.147 14.457-17.093 33.652-17.093 54.25 0 17.877 4.543 35.74 12.626 50.124-11.008 4.402-20.228 11.397-27.5 20.125-9.997 11.997-16.583 27.02-21.126 43.5-9.085 32.964-10.125 72.204-10.125 107.594v9.345H61.595l9.968 154.78.563 8.75h116.53l.564-8.75 9.936-154.78h42.063v-9.344c0-35.39-1.04-74.63-10.126-107.592-4.543-16.482-11.13-31.504-21.125-43.5-7.27-8.723-16.504-15.723-27.5-20.125 8.08-14.385 12.624-32.25 12.624-50.125 0-20.598-5.977-39.793-17.125-54.25-11.15-14.458-27.98-24-47.595-24zm247.406 0c-19.614 0-36.444 9.542-47.592 24-11.15 14.457-17.094 33.652-17.094 54.25 0 17.877 4.542 35.74 12.625 50.124-11.01 4.402-20.228 11.397-27.5 20.125-9.998 11.997-16.584 27.02-21.126 43.5-9.086 32.964-10.156 72.204-10.156 107.594v9.345H309l9.938 154.78.562 8.75h116.438l.656-8.624 11.875-154.905h40.155v-9.344c0-35.39-1.07-74.63-10.156-107.592-4.544-16.482-11.13-31.504-21.126-43.5-7.273-8.73-16.493-15.724-27.5-20.125 8.082-14.386 12.625-32.248 12.625-50.125 0-20.598-5.947-39.793-17.095-54.25-11.148-14.458-27.98-24-47.594-24zM130.376 37.124c13.76 0 24.63 6.107 32.813 16.72 8.183 10.61 13.218 25.89 13.218 42.843 0 18.663-6.887 38.59-15.97 49.53l-10.124 12.188 15.594 2.938c12.812 2.408 22.058 8.406 29.688 17.562 6.238 7.487 11.222 17.262 15.062 28.656l-13.22 101.125h-14.75l-12.217-97.312-19.845 163.53-21.03-163.53-18.69 155.938L90.47 211.375l-11.72 97.313H61.812l-12.53-98.563c3.937-12.5 9.17-23.174 15.874-31.22 7.63-9.155 16.907-15.153 29.72-17.56l15.593-2.94-10.126-12.218c-9.083-10.94-15.97-30.836-15.97-49.5 0-16.95 5.037-32.23 13.22-42.843 8.182-10.612 19.02-16.72 32.78-16.72zM457.97 207.313c.888 2.62 1.73 5.307 2.5 8.093 7.436 26.984 9.094 60.96 9.342 93.28l-24.78.002 12.937-101.375zm-120.033 4.062l20.157 155.938 18.97-155.938 20.748 163.53L418 211.376l12.813 102.03-.313 3.908-11.875 154.906H337.03l-9.936-154.783-.563-8.75h-.436l11.844-97.312zM296 212.22l12.75 96.468h-23c.248-32.322 1.906-66.298 9.344-93.282.296-1.074.592-2.137.906-3.187z",
	credit="https://game-icons.net/lorc/originals/body-swapping.html",
)
[[glyphs/boltSaw.easel]]
pub glyph BoltSaw:Glyph(
	path="M118.262 17.338l-.004.002 14.6 33.287L34.74 64.645l46.723 45.552L14.3 183.783l43.804 16.936-9.344 105.706 48.474-8.176 51.393 121.475 26.28-29.786 95.197 94.61 2.335-36.208 112.714 44.967-19.27-43.218 104.538-15.184-42.633-40.883 66.577-72.418-50.224-19.27 8.76-106.876-52.56 8.76L348.946 81.58l-25.695 29.785-89.354-88.77-2.337 39.714-113.298-44.97zm144.8 100.435l52.75 54.9 10.428-26.282 25.125 84.682 19.008-13.43-14.63 63.073 35.02-2.336-50.077 50.225 36.066 17.518.006-.002-.002.005-.004-.002-63.086 14.6 17.443 24.53-79.653-25.698 4.516 32.123-51.422-53.147-11.575 28.618-24.38-82.93-26.116 18.688 17.448-74.754-37.942 2.336 49.354-49.64-35.043-16.938 72.998-16.935-19.215-26.866 76.87 25.113-3.89-27.45zm-23.345 95.846c-14.81 0-18.424 16.9-8.074 37.75 10.35 20.848 30.742 37.747 45.55 37.747 14.81 0 18.424-16.9 8.075-37.748-10.35-20.85-30.742-37.75-45.55-37.75z",
	credit="https://game-icons:net/1x1/lorc/bolt-saw:html",
)
[[glyphs/boomerangSun.easel]]
pub glyph BoomerangSun:Glyph(
	path="M215.2 24.13c-.505.02-1.22.143-2.165.378h-.002c-20.152 5-132.385 52.22-134.738 94.728-2.353 42.51 81.636 64.576 125.324 75.315 43.687 10.74 60.602-8.53 49.423-32.36-11.18-23.83-84.137-28.537-94.14-62.958-9.532-32.807 66.59-75.5 56.298-75.1zm87.593 10.12c-5.402.094-10.28 1.096-14.447 3.203v-.002c-38.1 19.27-15.002 102.82-2.352 145.92 12.65 43.1 37.95 47.953 52.953 26.478s-17.8-86.492 7.06-112.38c24.86-25.887 106.792 23.83 92.378 8.827-12.838-13.362-91.602-72.812-135.592-72.045zm143.68 138.74c-35.658.516-83.103 48.973-109.29 76.278-31.04 32.36-22.655 56.044 3.528 58.25 26.184 2.205 66.342-58.103 101.202-49.424 34.86 8.68 32.51 104.143 38.244 84.136 5.736-20.005 20.444-140.91-15.297-164.156-5.586-3.63-11.784-5.18-18.387-5.084zm-415.54 2.336c-.443.013-.92.873-1.472 2.748-5.884 20.004-21.034 140.77 14.71 164.158 35.744 23.39 97.082-38.244 128.266-70.605 31.183-32.36 22.653-56.483-3.53-58.838-26.182-2.356-66.34 58.102-101.2 49.423-31.594-7.865-32.503-87.007-36.774-86.887zm223.71 44.438c-22.517 0-40.77 18.232-40.77 40.722 0 22.49 18.253 40.72 40.77 40.72 22.516 0 40.77-18.23 40.77-40.72s-18.254-40.722-40.77-40.722zm-64.108 78.61c-7.227.118-14.24 4.564-19.865 12.673-15.003 21.623 17.36 86.64-7.65 112.38-25.006 25.742-106.79-24.418-92.375-9.413 14.414 15.005 111.938 88.697 150.037 69.43 38.098-19.27 14.858-103.41 2.353-146.508-7.815-26.938-20.455-38.76-32.5-38.563zm93.24 24.34c-27.113-.31-36.284 16.04-27.2 35.403 11.18 23.83 83.696 28.39 93.552 62.957 9.856 34.567-74.283 80.314-54.13 75.313 20.15-5 132.384-52.66 134.737-95.317 2.353-42.656-81.785-64.574-125.326-75.312-8.164-2.014-15.376-2.974-21.633-3.045z",
	credit="https://game-icons:net/lorc/originals/boomerang-sun:html",
)
[[glyphs/bubblingBeam.easel]]
pub glyph BubblingBeam:Glyph(
	path="M17.607 15.518v72.9L225.837 278.5 114.91 254.926l144.863 114.262c1.57-15.168 14.386-27 29.97-27 16.642 0 30.136 13.49 30.136 30.134 0 16.64-13.49 30.135-30.136 30.135-10.836 0-20.334-5.722-25.644-14.31l-105.08-2.928 156.667 71.807-124.75 22.85 43.122 15.246h121.036c.962-5.602 2.166-11.124 3.597-16.555-13.39-4.216-23.105-16.73-23.105-31.515 0-18.244 14.79-33.037 33.04-33.037 6.266 0 12.127 1.746 17.12 4.777 5.93-8.855 12.5-17.16 19.61-24.81-4.832-4.24-8.404-9.88-10.07-16.294-3.96 3.357-9.082 5.386-14.68 5.386-12.543 0-22.713-10.167-22.713-22.713 0-12.543 10.167-22.713 22.712-22.713 8.763 0 16.365 4.965 20.153 12.235 5.95-7.925 15.426-13.053 26.1-13.053 12.914 0 24.075 7.504 29.363 18.39 12.128-6.168 24.79-10.725 37.685-13.425v-67.293l-7.635-65.463-38.052 105.1-38.988-164.658-28.673 111.69-93.04-160.578 10.25 119.818L99.375 15.518H17.606zm268.09 241.447c8.683 0 16.033 5.703 18.512 13.568 5.346-4.592 12.292-7.373 19.894-7.373 16.875 0 30.56 13.68 30.56 30.56 0 16.875-13.68 30.56-30.56 30.56-16.744 0-30.337-13.47-30.55-30.167-2.403 1.066-5.058 1.67-7.857 1.67-10.718 0-19.408-8.69-19.408-19.41 0-10.718 8.686-19.408 19.407-19.408zm112.25 25.084c10.72 0 19.41 8.688 19.41 19.41 0 10.717-8.69 19.407-19.41 19.407-10.718 0-19.408-8.687-19.408-19.408 0-10.72 8.686-19.41 19.407-19.41z",
	credit="https://game-icons:net/lorc/originals/bubbling-beam:html",
)
[[glyphs/burningDot.easel]]
pub glyph BurningDot:Glyph(
	path="M53.813 48.094c69.06 40.8 122.263 96.67 124.937 153.312-49.83.664-72.508-14.408-101.97-51 17.725 93.07 55.393 143.855 100.72 156.563-22.006 26.968-60.902 30.456-97.625 25.342 35.897 33.924 95.12 70.913 149.094 84.75-17.05 15.34-38.742 24.516-68 29.157 269.316 114.287 386.556 10.27 295.217-277.376-12.035 25.526-29.11 41.112-60.343 57.5-7.906-55.298-31.41-152.12-95.656-171.75 24.362 41.713 21.98 99.445-4 138.937C268.363 122.72 161.85 54.283 53.813 48.095zm308.28 236.656c26.127-.13 52.073 11.014 70.157 32.72 32.15 38.584 26.96 95.63-11.625 127.78-38.586 32.15-95.632 26.96-127.78-11.625-32.15-38.586-26.962-95.632 11.624-127.78 16.88-14.067 37.303-20.994 57.624-21.095z",
	credit="https://game-icons:net/lorc/originals/burning-dot:html",
)
[[glyphs/burningEye.easel]]
pub glyph BurningEye:Glyph(
	path="M235.094 17.844C60.934 66.176 249.458 163.35 184.72 198.22c-32.796 17.66-86.03 15.048-64.657-73.876-106.688 86.723-75.665 284.316 48.093 349.5-27.153-25.674-44.125-62.01-44.125-102.25 0-77.624 63.128-140.75 140.75-140.75 77.625 0 140.75 63.128 140.75 140.75 0 37.55-14.77 71.708-38.81 96.97 150.706-76.96 122.903-288.475 22.5-342.533 23.96 56.174 11.553 99.36-18.22 123.44C385.64 57.762 174.494 135.013 235.094 17.843zM264.78 249.53c-67.523 0-122.06 54.54-122.06 122.064s54.54 122.062 122.06 122.062c67.523 0 122.064-54.538 122.064-122.062 0-67.522-54.54-122.063-122.063-122.063zm0 53.782c46.983 0 85.283 38.3 85.283 85.282s-38.3 85.25-85.282 85.25c-46.98 0-85.25-38.268-85.25-85.25s38.27-85.28 85.25-85.28zm0 18.688c-36.88 0-66.56 29.712-66.56 66.594 0 36.88 29.68 66.562 66.56 66.562 36.882 0 66.595-29.68 66.595-66.562 0-36.88-29.712-66.594-66.594-66.594zm0 18.656c26.45 0 47.876 21.457 47.876 47.906 0 26.45-21.426 47.875-47.875 47.875-26.447 0-47.905-21.425-47.905-47.875 0-8.41 2.19-16.315 6-23.187 1.84 12.334 12.466 21.813 25.313 21.813 14.14 0 25.593-11.486 25.593-25.625 0-8.62-4.25-16.236-10.78-20.875.59-.022 1.185-.032 1.78-.032z",
	credit="https://game-icons.net/1x1/lorc/burning-eye.html",
)
[[glyphs/cometSpark.easel]]
pub glyph CometSpark:Glyph(
	path="M20.916 15.648c147.945 202 202.556 312.645-3.146 252.438 201.76 82.926 225.515 176.51 49.13 180.76 190.922 51.156 315.057 60.258 377.16 10.43 67.76-54.368 62.6-177.648 13.31-361.6-.002 179.943-88.34 149.935-171.18-39.96 60.246 191.39-81.408 116.353-265.274-42.068zM457.37 97.676v-.008.008zm-79.792 150.84c5.457.054 10.994.79 16.508 2.267 3.763 1.01 7.352 2.34 10.77 3.924-.053-.058-.102-.12-.155-.178 51.248 21.08 79.986 77.264 65.253 132.25-16.008 59.742-77.174 95.054-136.914 79.046-59.29-15.886-94.507-76.24-79.395-135.547 1.144 7.843 3.71 15.465 7.808 22.564 15.038 26.045 46.48 37.745 78.735 32.334 8.387-.382 17.33-2.932 25.75-7.793 22.18-12.807 32.317-36.774 22.642-53.53-9.676-16.76-35.5-19.966-57.682-7.16-7.3 4.214-13.283 9.64-17.697 15.618-3.05-11-3.31-22.928-.14-34.75 7.978-29.778 35.053-49.34 64.518-49.047z",
	credit="https://game-icons.net/lorc/originals/comet-spark.html",
)
[[glyphs/corporal.easel]]
pub glyph Corporal:Glyph(
	path="M255.978 93.103C226.38 140.78 161.383 218.66 106 257.6v52.892c53.113-38.92 105.113-92.537 140.56-145.71l9.44-14.158 9.44 14.16c35.333 53 87.963 106.296 140.56 145.47v-52.593c-56.39-38.937-120.654-116.944-150.022-164.557zm0 108.403C226.38 249.183 161.384 327.066 106 366.01v52.887c53.113-38.92 105.113-92.537 140.56-145.71L256 259.03l9.44 14.158c35.333 53 87.963 106.298 140.56 145.473v-52.594c-56.39-38.937-120.654-116.947-150.022-164.56z",
	credit="https://game-icons.net/1x1/delapouite/corporal.html",
)
[[glyphs/crackedBallDunk.easel]]
pub glyph CrackedBallDunk:Glyph(
	path="M195.938 20.438C96.6 21.47-5.517 164.667 29.813 458.938c7.368-370.195 187-461.348 252.875-248.782-.724.372-1.448.762-2.157 1.156l-80.78-58L248 246.188c-2.173 4.416-3.97 9.074-5.438 13.907L120.22 255.28l119.06 47.814c.304 2.26.674 4.534 1.126 6.812.383 1.928.837 3.83 1.313 5.72l-76.44 85.25L268.157 365c.916 1.003 1.864 1.974 2.813 2.938l-16.97 116 72.97-87.313c4.53.546 9.093.754 13.717.53l78.094 97.595-25.592-122.375c1.513-1.67 2.965-3.387 4.343-5.188l101.095-4.03-82.813-46.75c.43-7.072.143-14.343-.937-21.72l78.063-67.968-94.344 23.75c-2.162-3.464-4.484-6.8-6.97-9.97l30.938-91.063-66.937 61.532c-1.885-.926-3.785-1.803-5.72-2.595C328.46 84.762 264.238 21.238 198.282 20.437c-.78-.01-1.56-.008-2.343 0zM316 220.594c.584-.012 1.168-.005 1.75 0 21.907.178 43.736 12.245 59 31.47l-45.938 25.53-13.187-16.625-5.47-6.908-7.217 5.063-47.907 33.78c-2.07-38.124 20.407-68.303 53.72-71.967 1.74-.192 3.498-.31 5.25-.344zm70.906 47.22c3.957 7.708 6.95 16.112 8.72 25.03 1.7 8.574 2.16 16.875 1.562 24.72l-39.72-6.345-.593-.75-14.28-18.033 44.31-24.625zm-78.437 11.686l29.967 37.844-28.843 55.03c-22.418-10.077-41.54-31.73-49.156-59l48.03-33.874zm44.717 49.97l40.407 6.467c-7.628 23.216-26 39.61-50 42.25-5.258.58-10.54.418-15.78-.375l25.373-48.343z",
	credit="https://game-icons.net/1x1/lorc/cracked-ball-dunk.html",
)
[[glyphs/crossedSlashes.easel]]
pub glyph CrossedSlashes:Glyph(
	path="M174.844 14.875c47.1 42.275 78.124 90.35 95.312 138.063C200.613 126.285 119.028 114.165 32 129.155c96.11-8.437 180.524 13 245.625 47.72 43.035 161.78-70.46 307.352-250.97 192.155 112.67 95.877 201.475 101.817 254.94 60.908 307.477 77.54 238.903-156.1 27.374-260.094-25.886-55.805-69.74-110.694-134.126-154.97zM323 205.345c123.386 90.75 139.423 227.623-38.656 222.436C336.51 385.317 353.196 296.868 323 205.345z",
	credit="https://game-icons.net/lorc/originals/crossed-slashes.html",
)
[[glyphs/crownedExplosion.easel]]
pub glyph CrownedExplosion:Glyph(
	path="M62.807 19.26l90.134 94.617c-7.47 4.86-14.578 10.294-21.243 16.264l-65.623-22.02 32.908 61.53c-8.18 13.58-14.62 28.507-18.923 44.57-4.86 18.13-6.635 36.365-5.67 54.157L21.235 308.38l62.576 7.647c2.362 6.76 5.138 13.354 8.3 19.754L19.187 366.8v95.864l90.562-98.44c6.094 8.002 12.892 15.492 20.334 22.366l-22.56 53.06 61.316-26.072c7.367 3.747 15.082 6.997 23.11 9.707l-42.32 71.25h104.403l-7.083-62.082c9.308.03 18.522-.696 27.567-2.135l34.037 50.45 14.497-65.72c13.49-6.544 26.11-14.82 37.517-24.614l57.032 19.367-23.44-58.245c3.51-5.562 6.714-11.366 9.602-17.385l90.705 63.125V282.977l-75.67 2.757c1.153-7.366 1.815-14.72 2.012-22.023l61.95-35.968-68.333-15.312c-8.706-30.973-25.91-59.104-49.635-80.97l112.818-112.2h-92.88l-42.305 94.758c-6.592-4.318-13.524-8.22-20.777-11.647l-8.18-66.954-39.41 52.36c-11.226-1.748-22.423-2.37-33.457-1.926-14.58.586-28.874 3.028-42.588 7.136l-15.01-73.726H62.808zm184.183 85.11c13.38-.028 26.987 1.692 40.54 5.323 17.33 4.643 33.165 12.047 47.18 21.596l-24.153 54.1 41.023-40.798c8.817 8.017 16.632 16.997 23.328 26.722l-30.863 41.897 50.47-2.345c7.795 23.73 9.918 49.584 5.214 75.565l-61.357 2.236 49.832 34.68c-25.574 56.255-82.33 91.57-143.39 90.422l-7.606-66.68-35.476 59.724c-32.962-10.183-60.193-30.463-79.187-56.5l41.523-45.134-54.834 23.32c-4.775-9.507-8.585-19.513-11.326-29.867l58.7-32.435-62.712-25.29c.874-7.27 2.262-14.567 4.213-21.848 10.62-39.625 35.624-71.486 67.886-91.477l49.668 52.14-13.932-68.437c12.698-3.938 25.978-6.264 39.54-6.797 1.9-.074 3.807-.113 5.718-.117zm5.23 82.88c-39.546 0-71.607 32.062-71.607 71.61 0 39.546 32.06 71.607 71.608 71.607s71.608-32.06 71.608-71.608c0-39.55-32.06-71.61-71.607-71.61z",
	credit="https://game-icons:net/lorc/originals/crowned-explosion:html",
)
[[glyphs/deadlyStrike.easel]]
pub glyph DeadlyStrike:Glyph(
	path="M196.38 16.29l12.018 214.677-69.382-213.75h-19.65l70.52 217.25c-17.16-18.22-34.434-44.74-52.243-80.246 18.864 62.058 35.573 139.067 40.552 192.04L19.38 62.393v38.277l144.89 258.98c-33.493-21.316-67.86-56.375-97.918-92.87 26.712 52.73 55.26 104.847 73.076 160.54L19.378 289.453v28.46l107.997 124.026C99 434.69 70.625 422.05 42.25 408.165c38.03 26.607 62.036 50.897 84.234 85.82H230.84l-6.785-91.082H197.77c0-44.845 2.87-108.728 40.767-115.86-6.993-8.433-11.533-20.27-11.533-33.523 0-23.93 14.228-43.758 32.45-46.127h.005c.303-.038.61-.056.923-.063.934-.02 1.895.063 2.83.063 19.957 0 36.205 20.602 36.205 46.128 0 12.928-4.304 24.595-10.996 32.99 41.4 6.42 40.496 71.424 40.496 116.394h-24.94l-6.003 91.082h90.96c19.418-30.77 60.864-56.727 96.524-75.234-38.585 10.67-75.927 17.602-109.66 21.02l117.97-86.97v-23.218l-125.78 92.728c24.4-49.363 55.902-88.075 90.164-122.648-40.56 27.323-73.25 37.7-107.027 43.785L493.77 158.7v-30.58L339.297 328.19c1.19-51.24 16.946-114.427 39.156-171.047-17.383 25.054-33.876 46.073-49.713 62.742l56.406-202.668h-19.398l-53.412 191.906 3.832-192.834h-119.79z",
	credit="https://game-icons.net/lorc/originals/deadly-strike.html",
)
[[glyphs/divert.easel]]
pub glyph Divert:Glyph(
	path="M237.688 20.25L18.344 288.344l174.625 63.094c-8.217 8.152-18.068 15.154-29.876 20.78L276.5 399.282c-10.966 11.894-24.456 22.08-41 30.22l125.563 12.406c-16.877 21.158-38.8 38.795-67.063 52.03l204.688-29.623L412.5 273.125c-1.632 34.214-5.993 66.51-14.688 95.813L320 270.03c-1.03 21.615-3.57 42.188-8.438 61.22l-80.843-72.47c-1.363 11.97-3.38 23.5-6.25 34.408l-45.94-28.657L496.69 20.25h-90.75l-284.72 250.844 158.313 87.03-211.655-76.78L318.5 20.25h-80.813z",
	credit="https://game-icons.net/lorc/originals/divert.html",
)
[[glyphs/dna1.easel]]
pub glyph Dna1:Glyph(
	path="M121.844 18.22c-10.248 46.5-5.753 86.598 7.562 121 31.722 35.503 74.78 60.367 119.5 84.405-15.144-14.727-29.5-29.294-41.97-44.188h72.94c5.318-6.197 10.267-12.425 14.812-18.687H192.5c-4.946-7.035-9.397-14.18-13.25-21.5-2.036-3.867-3.926-7.78-5.656-11.75h140.594c2.73-6.087 5.032-12.27 6.875-18.688h-154.22c-3.453-12.16-5.326-25.127-5.218-39.437h164.25c-.176-5.948-.708-12.168-1.656-18.72H162.843c1.202-10.093 3.29-20.866 6.437-32.436h-47.436zm216.03 0c10.033 36.836 9.616 65.44 2.47 90.593h-.156c-3.215 13.34-8.158 25.723-14.375 37.53-15.708 29.833-40.195 56.197-67.094 82.532 12.75 6.806 25.567 13.607 38.25 20.625 26.73-26.167 52.8-54.185 71.03-88.813 20.463-38.87 29.83-85.945 17.375-142.468h-47.5zm-129 253.81c-20.338 21.212-39.452 44.344-53.936 71.69-21.326 40.26-31.11 89.958-19.438 149.467h45.625c-5.036-22.15-6.48-42.845-5.03-62 .458-7.468 1.38-14.606 2.75-21.468H179c1.278-6.435 2.896-12.663 4.813-18.69.024-.07.038-.145.062-.217 3.025-9.47 6.796-18.44 11.188-26.875 14.96-28.73 35.86-51.34 56.5-71.813-14.107-6.74-28.446-13.326-42.688-20.094zm47.595 22.47c14.437 14.55 27.88 29.196 39.186 44.563h-61.812c-4.798 5.982-9.337 12.195-13.53 18.687h87.75c1.445 2.45 2.832 4.94 4.155 7.438 4.388 8.287 8.147 16.85 11.155 25.843H203.5c-2.184 5.98-4.007 12.218-5.47 18.69h130.314c2.428 12.173 3.525 25.21 2.937 39.436H194.19c.137 6.05.58 12.28 1.375 18.688h134.062c-1.072 8.062-2.65 16.496-4.75 25.344h46.813c9.533-48.618 4.736-90.682-8.97-126.407-28.443-31.848-66.276-52.97-106.25-72.28z",
	credit="https://game-icons.net/1x1/lorc/dna1.html",
)
[[glyphs/dodging.easel]]
pub glyph Dodging:Glyph(
	path="M396.082 17.326c-.166-.025-1.922.108-4.977.108-21.975 0-42.158 18.904-49.437 46.595l75.713 12.61-78.526 13.085c.564 16.248 5.55 30.99 13.062 42.367l54.39 9.603-41.277 7.29.484.607-15.91 2.47c-15.262 2.366-25.866 9.63-34.46 21.165-2.534 3.4-4.848 7.198-6.962 11.328l90.798 13.2-100.976 14.684c-.576 2.25-1.118 4.542-1.627 6.874-1.662 7.613-2.953 15.622-3.982 23.854l115.275 14.107-117.81 14.418c-.525 9.083-.84 18.236-1.022 27.31l114.07 16.407-113.304 16.3h40.826l2.144 32.532 82.026 11.38-80.54 11.173 2.512 38.14 75.582 10.897-74.158 10.69 2.938 44.59h96.306l11.875-159.403h43.983c-.228-36.033-1.914-77.32-10.137-111.194-4.462-18.384-10.84-34.42-19.314-46.063-8.472-11.642-18.583-18.958-32.248-21.53l-15.59-2.933 10.124-12.213c10.435-12.587 17.49-30.688 17.49-51.127 0-37.056-22.084-66.04-47.127-69.295l-.106-.013-.108-.016zm-53.535 5.055L16.785 45.968l304.93 22.082c3.073-17.672 10.43-33.57 20.832-45.67zm-22.402 62.114L16.783 106.46l312.28 22.612c-5.686-12.618-8.96-27.047-8.96-42.422 0-.722.027-1.437.042-2.156zm-2.612 60.688L16.783 166.96l269.96 19.546c3.583-8.906 7.975-17.144 13.415-24.445 4.868-6.532 10.676-12.254 17.375-16.878zm-37.79 63.228l-262.96 19.04L273.19 246.02c1.18-10.497 2.77-20.808 4.927-30.69.51-2.33 1.05-4.635 1.625-6.918zm-8.327 57.803L16.783 284.65l253.225 18.336c.18-12.057.585-24.438 1.408-36.773zm-1.562 60.605l-253.07 18.325 297.22 21.52-1.072-16.267H269.86v-9.343c0-4.62-.01-9.38-.006-14.235zm45.294 57.22L16.783 405.64l301.227 21.81-2.862-43.413zm3.97 60.202L16.782 466.13l305.233 22.102-2.9-43.992z",
	credit="https://game-icons.net/1x1/lorc/dodging.html",
)
[[glyphs/electricWhip.easel]]
pub glyph ElectricWhip:Glyph(
	path="M17.484 39.262c49.142 2.758 98.444 7.823 147.96 15.924l-6.188-37.095L298.61 124.75l8.177-41.976L421.17 255.672l32.39-29.328-4.658 171.826 45.943 6.657-128.062 62.762 28.438 25.59-234.395-2.697c405.34-23.83 225.85-392.453-143.335-451.22z",
	credit="https://game-icons.net/lorc/originals/electric-whip.html",
)
[[glyphs/energyBreath.easel]]
pub glyph EnergyBreath:Glyph(
	path="M21.094 18.738l2.648 324.412c18.77-2.59 45.98-7.852 64.945-12.642-64.106-101.55-51.257-197.104 2.327-249.63 53.662-52.602 146.447-59.914 233.177 7.337 4.84-9.857 10.42-22.838 16.794-36.006 5.47-11.3 11.646-22.644 18.895-32.767l-338.786-.705zm474.963 4.528v.004c0-.002 0-.003.002-.004h-.003zm0 .004c-61.196 95.76-153.25 141.768-246.823 130.314l.018-.09c-44.04-8.138-80.08-48.272-88.258-90.97l-5.1.978c-4.382 1.34-8.652 2.905-12.804 4.674 5.02 23.956 17.053 46.75 34.045 64.994-23.395-10.524-46.4-24.868-68.545-43.14-1.53 1.363-3.03 2.76-4.494 4.195-10.57 10.36-19.463 22.714-26.19 36.744 78.998 89.616 102.237 198.926 67.586 288.587a19.04 19.04 0 0 1 .024 0 19.04 19.04 0 0 1 18.494 19.04 19.04 19.04 0 0 1-33.54 12.434c-8.678 15.057-19.207 29.335-31.603 42.613h87.746c39.76-99.513 23.982-199.025-19.246-298.538 67.318 99.592 90.826 196.925 82.403 298.538h40.86c6.338-49.1-1.414-99.91-17.83-151.262 27.98 51.95 42.662 101.905 46.167 151.263h80.418c-7.116-82.67-59.353-161.448-136.016-238.282 51.847 37.27 99.116 74.24 137.67 113.58a28.06 28.06 0 0 1 26.353-16.5 28.06 28.06 0 0 1 27.253 28.064 28.06 28.06 0 0 1-19.53 26.857c21.467 27.107 38.57 55.61 50.107 86.283h10.834v-251.73c-90.946 14.794-178.154.85-267.36-51.786 28.81 10.04 57.617 17.515 86.426 21.637a15.033 15.033 0 0 1-.81-4.73 15.033 15.033 0 0 1 15.472-15.026 15.033 15.033 0 0 1 14.594 15.027 15.033 15.033 0 0 1-2.124 7.608c51.267 3.417 102.534-4.68 153.8-28.997V132.79c-13.638 7.018-27.81 13.495-42.56 19.394a19.04 19.04 0 0 1-32.117 11.59c-23.378 7.59-48.116 13.84-74.41 18.585 23.985-9.113 46.94-19.303 68.655-30.768a19.04 19.04 0 0 1-.072-1.617 19.04 19.04 0 0 1 19.588-19.04 19.04 19.04 0 0 1 10.442 3.51c17.903-11.117 34.778-23.286 50.475-36.648V23.27zM195.8 57.664c-5.448-.005-10.796.308-16.036.904l95.56 65.895 18.936-34.887c-34.17-22.12-67.845-31.884-98.46-31.912zM63.72 196.322c.062 32.42 9.328 68.888 30.667 107.545l22.33-13.244-52.996-94.3zm329.33 88.944a19.04 19.04 0 0 1 18.493 19.043 19.04 19.04 0 1 1-38.082 0 19.04 19.04 0 0 1 19.59-19.044z",
	credit="https://game-icons:net/lorc/originals/energy-breath:html",
)
[[glyphs/fireDash.easel]]
pub glyph FireDash:Glyph(
	path="M273.857 21.904c-24.193.012-51.198 5.552-81.1 17.467 143.7 12.608 150.35 129.263 84.032 132.814-85.27 4.565-53.232-57.217-133.34-103.03C200.445 201.48 94.44 190.33 21.054 59.23c12.805 85.755 24.28 116.942 78.26 153.596C261.996 323.294 94.618 347.8 36.82 245.53c14.568 93.454 68.364 132.803 131.707 139.93-42.753 24.49-99.452 32.49-143.01 25.556 51.025 42.317 131.606 40.94 193.515 8.576-37.137 36.123-97.446 70.644-116.803 74.728H276.36C517 405.563 530.305 232.45 454.827 124.492c-2.433 26.21-10.08 49.507-25.545 70.23-18.48-102.394-69.02-172.86-155.426-172.818zm2.82 184.666l141.384 52.155c.286-3.207.86-6.495 1.747-9.807 5.62-20.973 21.605-34.913 35.705-31.135 14.1 3.778 20.973 23.842 15.353 44.815-5.62 20.974-21.603 34.914-35.703 31.136-.725-.194-1.427-.442-2.113-.72l-60.58 49.394 70.637 19.584-140.023 84.71 65.848-68.866-31.32-7.006-150.335 122.58 158.06-196.89-137.39-41.137 137.006 5.654-68.275-54.467z",
	credit="https://game-icons.net/lorc/originals/fire-dash.html",
)
[[glyphs/fireRay.easel]]
pub glyph FireRay:Glyph(
	path="M12.195 20.94v39.128c76.452 73.026 151.387 152.574 187.47 215.5 12.6 21.978 38.114 72.972 49.056 118.557-31.424-3.388-64.762-14.633-96.36-33.873 11.605 19.025 25.57 37.838 42.632 54.898 83.895 83.897 200.548 103.142 260.473 43.217 59.927-59.927 40.678-176.574-43.22-260.47-17.062-17.063-35.872-31.028-54.895-42.633 21.316 35.01 33.27 71.947 35.04 106.29-47.3-13.436-103.76-38.565-127.316-51.976C201.59 173.434 121.32 98.073 47.818 20.938H12.195zM374.89 285.866c47.63 0 86.557 36.296 90.727 82.817-12.225-22.7-36.207-38.133-63.797-38.133-39.995 0-72.42 32.423-72.42 72.42 0 5.462.61 10.78 1.758 15.897 2.835-21.18 21.098-37.674 43.018-37.674 23.866 0 43.414 19.55 43.414 43.414 0 23.866-19.548 43.413-43.414 43.413-1.59 0-3.157-.093-4.703-.262.114.057.225.12.34.176-48.052-2.623-86.028-42.24-86.028-90.96 0-50.428 40.677-91.107 91.104-91.107z",
	credit="https://game-icons:net/1x1/lorc/fire-ray:html",
)
[[glyphs/fireWave.easel]]
pub glyph FireWave:Glyph(
	path="M328.5 30.156c-99.58-.03-191.647 52.414-271.156 151.438 9.912-28.743 47.544-88.772 70.28-108.094-41.265 15.076-87.27 63.656-106.5 114.5v61.53c18.558-26.168 38.798-47.69 65.25-71.78-26.49 44.543-52.15 119.388-65.25 176.688v141.937h26.72c19.804-93.475 48.162-162.69 100.406-233-19.15 60.202-24.366 124.175-20.906 195.188 9.994-45.116 32.146-93.158 73.094-142.657-18.344 65.052-21.955 124.932-4.813 180.47h57.188c-2.562-32.025 1.113-56.394 14.062-80.938-.532 13.048.643 26.58 3.875 40.875 5.996-34.556 17.585-64.022 37.5-93.657-7.526 40.626-5.283 84.21 10.375 133.72h88.688c-5.158-31.55-2.596-66.12 8.218-107 1.704 39.91 11.515 75.754 32.47 107h51.563v-86.438c-7.074 13.913-10.72 29.376-12.97 44.968-7.695-43.873-9.963-84.805-7-122.062-23.246 21.267-34.008 65.82-35.624 120.312-20.16-86.008-18.087-166.31 12.28-239.437-70.757 23.94-117.454 140.15-126.75 257.53-12.338-113.425 14.68-207.775 68.344-279.156-35.215 9.957-67.622 43.803-94.625 89.375 21.048-68.622 56.62-123.21 101.624-164.72-113.59-3.315-207.167 93.895-261.063 216.094 17.013-71.856 50.828-131.208 96.376-178.125-83.605 13.105-129.81 80.075-168.28 191.874C106.93 174.272 207.072 79.45 377.968 34.406c-16.676-2.84-33.175-4.245-49.47-4.25zM190.125 108c-30.494 21.716-78.727 81.786-113.313 141.875C95 180.18 131.58 121.033 190.125 108zm264.594 64.5c-21.134.42-43.392 17.915-54.94 52.97 29.15-23.528 58.873-32.432 91.064-32.845-9.516-13.632-22.58-20.395-36.125-20.125zm-162.095 40.406C250.05 291.598 224.94 381.348 211.97 478.78c-19.036-107.454 13.613-221.943 80.655-265.874z",
	credit="https://game-icons.net/1x1/lorc/fire-wave.html",
)
[[glyphs/fragmentedMeteor.easel]]
pub glyph FragmentedMeteor:Glyph(
	path="M21.89 14.13L219.02 248.454l-168.37-153.8 166.03 190.222-52.178 3.793 70.33 46.832-50.58 13.225 44.18 5.152-59.264 43.962 95.676-4.9-19.037 66.435 64.646-52.75 18.363 83.873 18.744-56.713 9.96 35.684 5.628-50.855 53.253 49.696-12.945-80.61 65.406 8.312-39.702-45.69 65.54-41.302-77.66-3.057 36.023-36.22-54.777 23.732 10.576-69.498-54.497 42.585-27.457-71.253-11.863 44.592L111.715 45.004 212.557 183.22 21.893 14.13h-.002zm305.016 181.18v-.005h-.002l.002.004zm34.596 101.266l36.87 45.13-36.026 13.85 1.306-23.154-52.257-16.94 50.107-18.886zm-41.326 35.05l-2.127 49.288-41.003-12.37 8.736-27.437 34.393-9.48zm17.543 37.212l42.135 14.045-40.798 20.734-1.338-34.78z",
	credit="",
)
[[glyphs/frostfire.easel]]
pub glyph Frostfire:Glyph(
	path="M131.5 23.906c-70.56 2.47-100.474 70.008-101.063 104.53-2.2 129.255 153.66 66.31 156.532 129.064 3.123 68.31-100.445 78.95-105.126-5.25-27.54 110.96 59.15 168.72 133.53 149.406l-.78-.47v-54.936h56.062c-.74-3.815-1.125-7.757-1.125-11.78 0-2.337.122-4.637.376-6.908h-55.312v-63.53l49.906-28.813 29.063 50.343c4.896-3.81 10.38-6.91 16.28-9.125l-29.156-50.563 52.688-30.406L387 226.437l-29.844 51.656c5.724 2.623 10.99 6.094 15.625 10.25l30.376-52.594 48.97 28.28v63.533h-59.032c.254 2.27.375 4.57.375 6.906 0 4.023-.386 7.965-1.126 11.78h59.78v54.938l-52.687 30.406-28.53-49.375c-4.782 3.953-10.182 7.2-16 9.592l28.374 49.125-49.905 28.813-49-28.28 27.78-48.158c-6.003-1.986-11.612-4.88-16.655-8.5l-27.313 47.313-27.75-16.03c-14.41 23.334-32.845 35.984-51.718 39.967 84.677 48.568 197.274 52.484 259.874-12.25 64.14-66.327 61.303-174.725 20.47-254.062-28.28 56.73-123.93 13.764-92.283-47.313 7.413-14.303 10.865-27.54 10.658-39.437l27.156-7.28-7.813 29.155 18.033 4.813 7.812-29.094 21.313 21.312 13.218-13.22-21.312-21.31 29.125-7.814-4.845-18.062L441 69.313l7.813-29.126-18.063-4.843-7.813 29.125-21.312-21.314-13.22 13.22 21.314 21.312-25.908 6.968c-11.268-28.337-48.504-45.664-105.156-46.75 84.123 12.04 52.984 118.1 8.188 133.156-39.562 13.3-59.797-6.677-52-36.78 10.018-38.682-12.282-60.445-37.47-63.876l-18.53-3.344 13.906-16.437-14.28-12.063-13.876 16.376-7.22-20.188-17.593 6.28L147 61.28l-21.125-3.81-3.344 18.374 21.126 3.844-13.906 16.406L144 108.188l13.875-16.407 7.22 20.22 17.624-6.28-7.25-20.282 18.468 3.343c29.282 50.18-56.84 94.55-94.563 39.657-26.562-38.65-23.513-83.452 32.125-104.53zM323 292.03c-8.926 1.76-16.83 6.225-22.844 12.533L323 317.75v-25.72zm18.688.345v25.375l21.75-12.563c-5.71-6.233-13.224-10.775-21.75-12.812zM290.5 320.563c-1.465 4.36-2.28 9.033-2.28 13.906 0 4.546.684 8.92 1.967 13.03l23.5-13.563-23.187-13.375zm82.28.812l-21.717 12.563 22 12.687c1.115-3.856 1.718-7.927 1.718-12.156 0-4.573-.702-8.967-2-13.095zM323 350.125l-23.5 13.563c6.09 6.676 14.247 11.395 23.5 13.218v-26.78zm18.688 0v26.438c8.843-2.113 16.594-6.937 22.375-13.532l-22.375-12.905zM73.563 394.78l-18.032 4.845 7.657 28.594-28.624-7.658-4.844 18.063 28.624 7.688-20.938 20.937 13.22 13.22 20.937-20.94 7.656 28.595 18.06-4.844-7.686-28.624 28.656 7.688 4.813-18.063-28.626-7.655 20.97-20.97-13.22-13.186-20.937 20.936-7.688-28.625z",
	credit="https://game-icons.net/1x1/lorc/frostfire.html",
)
[[glyphs/glowingHands.easel]]
pub glyph GlowingHands:Glyph(
	path="M104.748 18.654l49.537 95.77c-2.842 2.11-5.612 4.31-8.322 6.578L96.35 93.346l27.603 49.515c-23.207 27.374-38.42 61.737-42.035 99.488l-53.672 15.25 53.29 15.142c2.714 38.4 17.42 73.486 40.384 101.55l-9.27 16.628-93.978 89.217v13.795h12.61l93.935-89.17 16.94-9.446c28.21 24.968 64.26 41.267 104 44.72l14.052 49.456 13.972-49.174c20.024-1.333 39.16-5.918 56.877-13.24l32.15 66.854h20.735l-36.006-74.87c11.583-6.262 22.403-13.756 32.29-22.298l44.143 24.607-24.654-44.227c24.54-28.775 40.23-65.33 42.833-105.455l49.588-14.09-49.947-14.192c-.628-6.983-1.64-13.856-3.037-20.588l54.793-20.605v-19.967l-59.577 22.404c-7.712-24.122-20.35-46.036-36.725-64.574l26.164-46.935-47.45 26.452c-4.984-4.07-10.19-7.883-15.598-11.412l61.673-89.526h-22.693l-55.18 80.1C323.59 87.98 300.23 81.204 275.492 79.38L260.21 25.597 244.84 79.678c-27.16 2.56-52.57 11.12-74.897 24.343L125.79 18.655h-21.042zm80.846 148.838l32.418 66.22c2.915 2.22 5.857 4.2 8.96 5.774l8.485-39.52 18.272 3.923-11.437 53.253c-.877 6.204-2.08 11.73-3.57 16.632l-.207.963-.088-.02c-10.842 34.21-36.004 37.086-61.21 26.79l-74.59-18.977 4.606-18.112 53.29 13.56c.475-2.618 1.07-5.195 1.798-7.718l-59.506-32.723 9.006-16.377 57.885 31.832c1.276-2.172 2.645-4.256 4.115-6.226l-46.256-45.905L140.73 187.6l46.487 46.13c2.515-1.71 5.16-3.137 7.898-4.283L168.81 175.71l16.784-8.218zm153.21 0l16.784 8.217-26.307 53.735c2.74 1.146 5.384 2.574 7.9 4.284l46.486-46.132 13.164 13.263-46.258 45.906c1.47 1.97 2.84 4.054 4.117 6.226l57.884-31.832 9.006 16.377-59.506 32.723c.727 2.523 1.323 5.1 1.797 7.717l53.288-13.56 4.61 18.114-74.584 18.976c-30.147 12.315-60.23 5.795-65.83-50.63L270.69 204l18.224-4.145 8.96 39.39c2.934-1.535 5.736-3.42 8.51-5.53l32.42-66.223z",
	credit="https://game-icons:net/lorc/originals/glowing-hands:html",
)
[[glyphs/grapple.easel]]
pub glyph Grapple:Glyph(
	path="M337.63 24.242l-86.044 87.965 61.283-21.33 1.532 19.115.112-.01 5.218 62.72-18.625 1.548-.002-.03-25.53 25.48 25.857 25.83 25.21-25.16 2.317-17.567 59.02 7.787-.03.213 28.118 3.46-19.656 44.573 94.922-68.018-63.275-12.964-.01.042-51.67-10.414 3.69-18.32 22.975 4.63 16.137-57.24-53.256 19.56 3.234 28.138-18.566 2.135-3.787-32.948-9.176-69.195zM231.616 128.156L183.05 210.96l66.036-42.683 24.453 7.05 25.536-25.487-.256-3.074-67.205-18.61zm117.53 76.16l-19.237 19.198 4.492 11.006-49.308 73.593 90.35-55.24-17.077-47.34-9.22-1.217zm-79.098 16.276c-2.71 43.464-37.206 77.36-79.184 77.353-54.24-.01-98.053 45.767-98.043 101.56.008 43.487-31.728 78.71-72.072 82.524v13.052h25.897c37.86-14.145 64.87-51.776 64.863-95.58-.008-46.077 35.614-82.876 79.35-82.867h.003c46.896.007 85.98-34.213 95.71-79.537l-16.523-16.506z",
	credit="https://game-icons.net/lorc/originals/grapple.html",
)
[[glyphs/hidden.easel]]
pub glyph Hidden:Glyph(
	path="M16.375 17.22v94.28l20.47 14.25 6.374-32.063 50.468 33.22L71.844 37.03l29.53 14.032L91.22 17.22H16.374zm119.72 0l19.843 42.03-42.032 46.72H155l4.656 39.718L180.686 120l10.408 61.938 38.75-56.72 25.22 32.657 24.186-91.156 33.78 21.124.595-50.78 47.656 24.436-3.03 67.5 28.438-41.813 12.78 22.126 60.157-64.25 1.188 44.187 33.875-42.625V17.22H136.094zM85.468 186.03c-16.63.038-34.107 1.616-52.345 4.376l-7.906 1.188-.064 7.97c-.35 40.24 4.84 67.31 16.125 85.936 11.287 18.627 29.17 27.313 48.626 29.938 6.937.935 14.17 1.266 21.656 1.218v-92.47c-18.67 4.285-32.593 20.996-32.593 40.97 0 12.76 5.68 24.195 14.655 31.906-.407-.048-.817-.102-1.22-.156-16.03-2.162-26.822-7.34-35.155-21.094-7.72-12.74-12.852-34.287-13.313-67.968 14.533-1.918 28.44-3.073 41.47-3.094 25.72-.042 48.403 3.894 67.593 12.78 27.768 12.86 49.145 36.087 63.406 75.626-23.567-1.313-45.838.293-65.906 1.97 7.748-7.628 12.563-18.238 12.563-29.97 0-20.04-14.044-36.785-32.813-41v91.75c29.98-2.004 63.35-7.024 98.438-3.187l13.968 1.53-4-13.47c-15.143-51.256-42.066-83.663-77.812-100.217-22.342-10.347-47.66-14.594-75.375-14.532zm347.624 0c-27.716-.06-53.034 4.186-75.375 14.532-35.748 16.555-62.67 48.962-77.814 100.22l-3.97 13.468 13.94-1.53c35.57-3.89 69.386 1.335 99.687 3.28v-92.125c-19.397 3.735-34.063 20.795-34.063 41.28 0 11.726 4.822 22.344 12.563 29.97-20.063-1.682-42.327-3.31-65.875-2 14.26-39.522 35.645-62.737 63.406-75.594 19.19-8.886 41.87-12.822 67.594-12.78 13.038.022 26.924 1.173 41.468 3.094-.46 33.68-5.624 55.228-13.344 67.97-8.333 13.753-19.093 18.93-35.125 21.092-.41.056-.832.107-1.25.156 8.984-7.71 14.688-19.137 14.688-31.906 0-19.525-13.332-35.927-31.375-40.656v92.156c7.04.004 13.86-.335 20.406-1.22 19.458-2.623 37.37-11.31 48.656-29.936 11.287-18.627 16.443-45.695 16.094-85.938l-.062-7.968-7.875-1.188c-18.24-2.76-35.747-4.338-52.376-4.375zm37.937 139.19l-2.717 35.124-80.407-4.063 78.375 66.25-39.874 9.44 68.28 27.03.002-105.406-23.657-28.375zm-131.124 12.03L274.5 422.53l-12.28-42.06-29.19 96.936-50.218-67.72-14.593 85.845h257.53l-6.406-34.467-53.156 19.875-9.344-53.157-16.938 13.44V337.25zm-300.78 15.188l-22.75 19.843v123.25h130.06l-16.186-76.5-13.875 16.72-24.688-54.125-33.28 54.344-19.282-83.533z",
	credit="https://game-icons.net/lorc/originals/hidden.html",
)
[[glyphs/lightningHelix.easel]]
pub glyph LightningHelix:Glyph(
	path="M20.72 19.344v39.718l130.843 73.813L246.5 87.78l-95.53-68.436H20.72zm196.936.093L313 76.78l-45.5 21.657.03.063-96.03 45.625h-.03l-113.94 54.22 161.532 86.093 59.594-39.25-39.344-34.844 26.375-13.094.094.063 78.94-39.157-.095-.062 136.5-67.72L387.47 19.44H217.655zM361.936 170.5l-76.498 37.906 44.812 25.28-37.03 24.376-.064-.062-55.312 36.438.062.03-68.25 44.938 325.281 154.75L307.47 347l9.31-5.22-.03-.03 43.563-24.313-.032-.03 115.97-65.032L361.937 170.5zm13.19 160.063l-33.97 18.968 139.313 74.22-105.345-93.188z",
	credit="https://game-icons.net/lorc/originals/lightning-helix.html",
)
[[glyphs/mightyForce.easel]]
pub glyph MightyForce:Glyph(
	path="M256 28l-32 128c-32-16-64-48-96-96 0 48 0 96 32 128-32 17-64 0-96-32 0 32 0 80 48 112-32 16-64 0-80-32 0 48 16 96 48 128-16 16-48 0-64-16 0 64 48 112 112 144h76.8l16.7-68.6-17.2-86.1-97.9 5s20.3-75.2 34.9-103.7c5-9.6 7.2-18 20-18.3 11.3 0 20.4 9.8 20.4 21.9 0 12-9.1 21.8-20.4 21.8-2.3 0-4.6-.5-6.6-1.3l-5.1 46.8c29.6-8.9 56.9-18.8 84-30.9 0-.1-.1-.2-.1-.3-6.2-8.8-10.4-21.5-10.4-35.7 0-14.1 4.1-26.8 10.4-35.7 6.1-8.9 14.1-13.7 22.5-13.7 8.5 0 16.5 4.8 22.6 13.7 6.2 8.9 10.2 21.6 10.2 35.7 0 14.2-4 26.9-10.2 35.7-.1.3-.5.7-.6.9 27.3 12.1 56.1 20.6 84.3 30.3l-5-46.8c-2.2.8-4.3 1.3-6.7 1.3-11.2 0-20.3-9.8-20.3-21.8 0-12.1 9.1-21.9 20.3-21.9 12.8.3 15.2 8.7 20 18.3 14.8 28.5 35 103.7 35 103.7l-97.9-5-17.2 86.1 16.7 68.6H384c64-32 112-80 112-144-16 16-48 32-64 16 32-32 48-80 48-128-16 32-48 48-80 32 48-32 48-80 48-112-32 32-64 48-96 32 32-32 32-80 32-128-32 48-64 80-96 96z",
	credit="https://game-icons.net/1x1/delapouite/mighty-force.html",
)
[[glyphs/mineExplosion.easel]]
pub glyph MineExplosion:Glyph(
	path="M287.586 15.297l3.504 110.963 31.537-110.963h-35.04zm-95.78.238l-1.75 236.047-170.533-43.33L130.486 377.69l-88.77-5.174 114.432 112.357-44.466-75.867L186.896 417l-51.748-109.94 110.114 79.956-12.635-185.23.002.003 75.212 170.57 75.816-89.95-6.62 154.582 60.173-39.978-20.388 79.486 75.756-142.787-75.924 1.94L487.32 155.87l-131.402 73.08-12.264-139.69-65.41 140.336-86.435-214.06h-.003zM45.503 44.095L39.355 75.94 154.285 218h.002l-77.6-166.836-31.185-7.07zm422.27 24.776l-31.184 7.07-43.738 107.37 81.068-82.59-6.147-31.85zM279.208 403.61c-40.176 0-72.708 32.537-72.708 72.71 0 5.725.636 10.706 1.887 16.05 7.25-32.545 36.097-56.655 70.82-56.655 34.82 0 63.673 23.97 70.82 56.656 1.218-5.277 1.888-10.404 1.888-16.05 0-40.175-32.536-72.71-72.71-72.71z",
	credit="https://game-icons.net/lorc/originals/mine-explosion.html",
)
[[glyphs/person.easel]]
pub glyph Person:Glyph(
	path="M250.882 22.802c-23.366 3.035-44.553 30.444-44.553 65.935 0 19.558 6.771 36.856 16.695 48.815l11.84 14.263-18.217 3.424c-12.9 2.425-22.358 9.24-30.443 20.336-8.085 11.097-14.266 26.558-18.598 44.375-7.843 32.28-9.568 71.693-9.842 106.436h42.868l11.771 157.836c29.894 6.748 61.811 6.51 90.602.025l10.414-157.86h40.816c-.027-35.169-.477-75.126-7.584-107.65-3.918-17.934-9.858-33.372-18.04-44.343-8.185-10.97-18.08-17.745-32.563-19.989l-18.592-2.88 11.736-14.704c9.495-11.897 15.932-28.997 15.932-48.082 0-37.838-23.655-65.844-49.399-65.844z",
	credit="https://game-icons.net/1x1/delapouite/person.html",
)
[[glyphs/private.easel]]
pub glyph Private:Glyph(
	path="M255.977 147.306C285.345 194.92 349.612 272.93 406 311.866v52.592c-52.596-39.175-105.228-92.47-140.56-145.47l-9.44-14.16-9.44 14.16c-35.446 53.17-87.448 106.787-140.56 145.706v-52.89c55.382-38.943 120.38-116.82 149.977-164.498z",
	credit="https://game-icons.net/1x1/delapouite/private.html",
)
[[glyphs/rank1.easel]]
pub glyph Rank1:Glyph(
	path="M255 471L91.7 387V41h328.6v346zm-147.3-93.74L255 453l149.3-75.76V57H107.7zm146.56-33.1l-94.66-48.69v50l94.54 48.62 98.27-49.89v-49.9z",
	credit="https://game-icons.net/1x1/skoll/rank-1.html",
)
[[glyphs/rank2.easel]]
pub glyph Rank2:Glyph(
	path="M255 471L91.7 387V41h328.6v346zm-147.3-93.74L255 453l149.3-75.76V57H107.7v320.26zm146.43-65.76l98.27-49.89v-49.9l-98.14 49.82-94.66-48.69v50zm.13 32.66l-94.66-48.69v50l94.54 48.62 98.27-49.89v-49.9z",
	credit="https://game-icons.net/1x1/skoll/rank-2.html",
)
[[glyphs/rank3.easel]]
pub glyph Rank3:Glyph(
	path="M255 471L91.7 387V41h328.6v346zm-147.3-93.74L255 453l149.3-75.76V57H107.7v320.26zm187.61-168.34l-14.5-46 38.8-28.73-48.27-.43L256 87.94l-15.33 45.78-48.27.43 38.8 28.73-14.5 46 39.31-28zM254.13 311.5l98.27-49.89v-49.9l-98.14 49.82-94.66-48.69v50zm.13 32.66l-94.66-48.69v50l94.54 48.62 98.27-49.89v-49.9z",
	credit="https://game-icons.net/1x1/skoll/rank-3.html",
)
[[glyphs/resonance.easel]]
pub glyph Resonance:Glyph(
	path="M258.186 21.076c-61.262-.17-122.585 23.086-169.264 69.766-79.875 79.875-90.355 202.083-33.037 294.03-21.126-58.596-5.07-136.433 43.875-204.518-26.864 54.274-23.788 119.52 8.705 171.64-16.072-44.577-3.09-104.19 35.502-155.568-22.22 40.8-20.71 91 4.105 130.804-13.956-38.71 1.842-92.823 43.24-134.222 43.876-43.875 102.245-59.39 141.206-40.764-39.916-27.966-92.123-30.865-134.612-8.724 54.177-39.073 116.827-50.336 161.063-29.194-52.326-36.654-120.2-41.6-176.747-14.863 71.832-49.555 153.662-63.29 211.87-35.47-40.654-28.48-88.263-42.783-135.907-42.917zm135.908 42.918l.008.006v-.002c-.003 0-.006-.003-.008-.004zm-35.125 50.332c0 .002.004.004.007.006v-.002c-.003 0-.006-.003-.008-.004zm93.772 8.315c27.828 58.21 14.094 140.048-35.47 211.887 26.74-56.548 21.8-124.425-14.858-176.754 21.144 44.238 9.878 106.895-29.2 161.075 22.145-42.488 19.248-94.7-8.714-134.618 18.62 38.96 3.107 97.327-40.768 141.2-41.4 41.4-95.513 57.196-134.224 43.238 39.81 24.817 90.023 26.326 130.826 4.096-51.383 38.602-111.004 51.59-155.588 35.513 52.118 32.49 117.364 35.57 171.637 8.71-68.085 48.943-145.92 64.997-204.512 43.87 91.947 57.318 214.157 46.838 294.03-33.037 82.987-82.986 91.948-212.252 26.842-305.18zM364.5 184.23l-.004-.007h-.002l.006.007zm37.914-26.457l-.004-.007h-.002l.006.007z",
	credit="https://game-icons.net/1x1/lorc/resonance.html",
)
[[glyphs/sergeant.easel]]
pub glyph Sergeant:Glyph(
	path="M255.978 39.21C226.38 86.89 161.383 164.77 106 203.713V256.6c53.113-38.92 105.113-92.538 140.56-145.71L256 96.735l9.44 14.157c35.333 53 87.963 106.298 140.56 145.473V203.77C349.61 164.835 285.346 86.825 255.978 39.21zm0 108.406C226.38 195.293 161.383 273.174 106 312.116v52.89C159.113 326.09 211.113 272.47 246.56 219.3l9.44-14.16 9.44 14.16c35.333 53 87.963 106.298 140.56 145.473v-52.597c-56.39-38.937-120.654-116.944-150.022-164.557zm0 107.782C226.38 303.075 161.383 380.956 106 419.898v52.89c53.113-38.918 105.113-92.536 140.56-145.707l9.44-14.16 9.44 14.16c35.333 53 87.963 106.298 140.56 145.473v-52.597c-56.39-38.938-120.654-116.945-150.022-164.558z",
	credit="https://game-icons.net/1x1/delapouite/sergeant.html",
)
[[glyphs/shieldReflect.easel]]
pub glyph ShieldReflect:Glyph(
	path="M19.36 19.457l-.38 27.84 267.127 154.75-58.703 19.916 57.602 19.36L142.12 383.546l-19.214-19.213-51.47 114.324 123.125-43.482-17.492-18.95 151.868-151.87 12.433 43.078 22.976-68.5 56.675-16.565-57.475-15.492-22.934-79.828-14.145 48.266-268.65-155.41-38.454-.446zM370.614 81.94c-4.53.02-9.035.12-13.51.302-3.275.134-6.528.32-9.76.547l31.25 108.786 104.05 28.045c6.204-39.085 8.902-80.275 9.18-120.075C456.37 88.82 415.098 82.257 375.15 81.95c-1.514-.012-3.027-.015-4.537-.01zm-36.87 2.1c-31.99 3.653-61.013 12.153-83.014 25.87l64.493 37.31 18.52-63.18zm148.18 139.997L378.958 254.13l-38.93 116.054-20.268-70.225-39.07 39.067c18.814 35.364 46.1 62.287 86.175 77.604 47.473-17.834 78.566-62.795 98.014-121.6 7.323-22.14 12.905-46.11 17.042-70.993z",
	credit="https://game-icons:net/1x1/lorc/shield-reflect:html",
)
[[glyphs/snowflake1.easel]]
pub glyph Snowflake1:Glyph(
	path="M316.28 19.063L211.19 47.25l36.625 67.78-61.25 16.44L184 54.53 80.437 82.313 52.47 186.72l77 2.186L113 250.344l-67.875-36.22L17.22 318.19l75.843 75.843 40.593-65.56 45.25 45.25-65.562 40.624 76.53 76.53 103.782-27.812-36.5-68.03 61.53-16.47 2.377 77.157 104.687-28.064 27.97-104.437-77.158-2.376L393 259.47l68.03 36.5 27.908-104.22-77-77.03-40.47 65.718-44.624-44.657 65.406-40.75-75.97-75.968zM253.19 125l11.53 21.344-22.874 69.72-54.094-49.095-.813-24.19 66.25-17.78zm64.062 16.75l48.28 48.313-13 21.125-71.81 15.062 15.467-71.375 21.063-13.125zm-176.438 47.47l23.75.686 48.938 54.656-69.563 22.282L123 255.656l17.813-66.437zm221.094 53.56l21.125 11.345-17.78 66.375-23.97-.75-48.5-53.938 69.126-23.03zm-139.25 41.5l-14.625 71.376-19.53 12.094-48.875-48.906 12.094-19.5 70.936-15.063zm40.438 11.064l54.5 48.344.72 23.53-66.533 17.844-11.124-20.75 22.438-68.968z",
	credit="https://game-icons.net/lorc/originals/snowflake-1.html",
)
[[glyphs/sonicLightning.easel]]
pub glyph SonicLightning:Glyph(
	path="M17.664 18.91v37.574l77.523 129.942 86.754-21.067 79.33 121.394-78.918-46.483 93.195 101.34-64.182 10.81 53.05 18.783c-36.484 34.27-64.93 77.082-79.313 124.158h19.617c19.42-58.22 62.696-110.147 115.73-144.34 53.682-34.606 116.954-50.88 174.96-38.713v-19.055c-12.93-2.457-26.01-3.663-39.13-3.686-28.257-.05-56.664 5.316-83.977 15.053l-3.295-60.925-27.457 53.535-30.445-83.947-7.63 67.797-103.43-162.6-80.04 18.522L64.642 18.91H17.665zM329.63 86.627l15.995 166.596 57.285-138.067-38.79 27.656-34.49-56.185zm-38.198 47.238l-28.48 28.934 29.095 64.132-.615-93.067zm131.77 61.852l-40.65 86.244 52.173-42.435-11.524-43.808zM86.44 267.164l35.464 31.027 109.742 27.52-65.423-53.82-79.784-4.726zm379.953 83.254c-40.082-.07-80.49 12.044-115.74 32.207-45.917 26.264-83.418 66.318-99.645 112.736h19.96c15.535-38.607 48.525-73.382 88.964-96.512 41.507-23.742 90.514-35.082 135.476-27.21v-18.95c-9.6-1.51-19.298-2.253-29.015-2.27zM189.2 355.91l-74.67.637-51.22 22.242 50.598 18.204 75.29-41.084zm39.073 25.672L162.21 397.67l6.864 29.447 59.2-45.535zm250.19 32.398c-27.52-.05-55.206 6.695-79.498 17.963-31.34 14.54-57.393 36.595-69.25 63.418h21.056c10.88-18.072 31.22-34.94 56.06-46.464 27.045-12.545 59.08-18.76 88.58-15.175v-18.824c-5.62-.606-11.28-.905-16.947-.916zm11.744 52.41c-15.04-.024-30.138 2.215-43.537 5.995-17.346 4.892-32.058 11.575-40.176 22.976h31.602c4.06-1.848 8.664-3.583 13.648-4.99 13.228-3.73 28.92-5.752 43.666-5.157V466.5c-1.732-.064-3.466-.11-5.203-.11z",
	credit="https://game-icons.net/1x1/lorc/sonic-lightning.html",
)
[[glyphs/sprint.easel]]
pub glyph Sprint:Glyph(
	path="M169.53 16.344L259.345 88 337 92.28l-1.03 18.657-161.376-8.906-118.78-4.905 227.28 68.03-197.72 246.75-14.53-17.655-49.22 96.625 248.69-202.78 51.81 11.592-38.78 40.594L270.5 329.5l-57.28 84.125L444.843 273.47 328 241.06l100.22-81.718c1.132.46 2.3.898 3.5 1.22 23.324 6.248 49.764-16.835 59.06-51.533 9.298-34.695-2.08-67.874-25.405-74.124-23.325-6.25-49.765 16.802-59.063 51.5-1.467 5.476-2.403 10.918-2.875 16.22L169.53 16.343z",
	credit="https://game-icons.net/lorc/originals/sprint.html",
)
[[glyphs/starsStack.easel]]
pub glyph StarsStack:Glyph(
	path="M256.65 38.984l-49.697 100.702-111.13 16.146 80.413 78.385-18.982 110.68 99.396-52.256 99.397 52.256-18.983-110.68 80.413-78.384-111.127-16.146-49.7-100.702zM112 308.826l-26.674 54.05-59.646 8.665 43.16 42.073-10.188 59.403L112 444.97l53.348 28.046-10.188-59.403 43.16-42.072-59.646-8.665L112 308.825zm288 0l-26.674 54.05-59.646 8.665 43.16 42.073-10.188 59.403L400 444.97l53.348 28.046-10.188-59.403 43.16-42.072-59.646-8.665L400 308.825z",
	credit="https://game-icons.net/1x1/delapouite/stars-stack.html",
)
[[glyphs/teleport.easel]]
pub glyph Teleport:Glyph(
	path="M249.334 22.717c-18.64 2.424-35.677 23.574-37.043 51.49v.02c-.057 1.186-.097 2.38-.097 3.59 0 16.362 5.658 30.827 13.942 40.818l10.127 12.213-15.592 2.933c-10.75 2.025-18.622 7.702-25.373 16.978-2.285 3.14-4.384 6.707-6.31 10.62-57.54-6.44-97.91-21.06-97.91-37.952 0-17.363 42.647-31.983 102.75-37.97-.213-2.51-.323-5.057-.323-7.636v-.002c0-.84.024-1.674.047-2.51-96.43 6.77-167.298 29.15-167.3 55.71-.002 25.33 64.462 46.86 154.074 54.67-.19.742-.394 1.465-.576 2.216-2.36 9.72-4.05 20.22-5.268 31.03-.01 0-.02 0-.03.002-.418 3.653-.78 7.34-1.095 11.046l.05-.005c-1.316 15.777-1.772 31.88-1.893 46.95h35.894l2.115 28.4c-68.24-4.994-118.444-21.004-118.444-39.843 0-13.243 24.83-24.89 63.27-32.33.3-4.056.66-8.115 1.076-12.162-76.42 9.353-129.17 29.168-129.172 52.086-.002 28.17 79.71 51.643 185.098 56.768l5.94 79.77c10.5 2.648 24.84 4.162 39.017 4.068 13.79-.092 27.235-1.71 36.45-4l5.263-79.846c105.308-5.14 184.935-28.605 184.935-56.76 0-23.013-53.196-42.895-130.13-52.2.304 4.02.557 8.047.755 12.07 38.883 7.43 63.965 19.17 63.965 32.536 0 18.84-49.804 34.85-117.908 39.844l1.87-28.402h34.18c-.012-15.113-.127-31.27-1.033-47.094.01 0 .02.002.032.004-.214-3.687-.472-7.352-.782-10.986l-.02-.002c-.94-11.157-2.367-21.984-4.546-31.967-.09-.405-.184-.803-.275-1.206 89.518-7.826 153.893-29.344 153.893-54.656 0-26.787-72.076-49.332-169.77-55.887.025.895.053 1.788.053 2.688 0 2.5-.104 4.97-.304 7.407 61.19 5.836 104.61 20.61 104.61 38.2 0 16.805-39.633 31.355-96.524 37.848-2.01-4.283-4.26-8.15-6.762-11.505-6.83-9.167-15.063-14.81-27.14-16.682l-15.913-2.47 10.037-12.59c6.928-8.69 11.912-20.715 13.057-34.268h.002c.163-1.95.25-3.93.25-5.938 0-.77-.022-1.532-.048-2.29-.015-.48-.033-.958-.057-1.434h-.002c-1.48-29.745-20.507-51.3-41.076-51.3-2.528 0-3.966-.087-4.03-.08h-.003zM194.54 355.822c-97.11 6.655-168.573 29.11-168.573 55.8 0 31.932 102.243 57.815 228.367 57.815S482.7 443.555 482.7 411.623c0-26.608-71.02-49.004-167.67-55.736l-.655 9.93c60.363 6.055 103.074 20.956 103.074 38.394 0 22.81-73.032 41.298-163.12 41.298-90.088 0-163.12-18.49-163.12-41.297 0-17.533 43.18-32.502 104.07-38.493l-.74-9.895z",
	credit="https://game-icons:net/lorc/originals/teleport:html",
)
[[glyphs/thunderball.easel]]
pub glyph Thunderball:Glyph(
	path="M22.03 16.844l147 158.125 37.75-14.626 6.75 17.437-110.25 42.72 209.564 230.53.187.25c18.074 22.833 46.023 37.5 77.314 37.5 54.318 0 98.562-44.243 98.562-98.56 0-43.636-28.55-80.77-67.937-93.69l-132.095-73.56-56.75 23.968-7.28-17.22 43.31-18.28-.186-.094 102.624-43.28L22.03 16.843zm368.314 293.5c44.218 0 79.875 35.656 79.875 79.875 0 7.866-1.146 15.45-3.25 22.624L446.155 409l4.688-39.656-22.78 54.22 32.467 4.873c-5.74 10.555-13.776 19.644-23.467 26.625l-51-24.75 37.312-44.78-79.594-40.626 53.064 47.25-43.97 36.47 42.72 41.312c-1.736.11-3.486.156-5.25.156-44.22 0-79.875-35.657-79.875-79.875 0-1.48.045-2.95.124-4.408l30.562 11.47-6.5 25.562 27.75-34.938-49.437-17.72c6.807-26.514 26.865-47.622 52.717-55.967l24.5 35.217 51.438-5.218-41.75-8.72-17.688-24.75c2.68-.27 5.404-.406 8.157-.406z",
	credit="https://game-icons:net/lorc/originals/thunderball:html",
)
[[glyphs/tripleScratches.easel]]
pub glyph TripleScratches:Glyph(
	path="M190.03 21.97c-.71-.003-1.422.01-2.124.03 38.633 74.657 186.967 157.52 307.906 333.03-38.488-159.928-215.34-332.78-305.78-333.06zM83.53 65.374c61.253 98.216 249.157 212.75 375.75 378.844C420.49 283.03 173.3 62.907 83.53 65.374zm-67.31 81.313c59.365 87.324 194.506 155.172 355.03 345.125-38.792-161.19-265.263-347.592-355.03-345.125z",
	credit="https://game-icons.net/lorc/originals/triple-scratches.html",
)
[[glyphs/waveStrike.easel]]
pub glyph WaveStrike:Glyph(
	path="M26.813 17.813c10.67 36.57 30.308 58.678 55.5 75.343 26.295 17.395 58.9 28.282 92.25 40.5 33.35 12.22 67.5 25.846 96.125 50.125 24.774 21.014 45.033 50.145 56.5 91.75 10.083-7.83 19.953-15.923 29.687-24.155-8.25-37.906-24.515-64.104-45.5-84.125-23.608-22.523-53.616-37.196-85.313-49.78-31.696-12.587-64.96-23.005-94.53-38-28.06-14.23-53.063-32.96-68.845-61.657H26.813zm57.78 0C98.03 37.413 117.137 51.185 140 62.78c27.615 14.006 60.402 24.426 92.938 37.345 32.535 12.92 64.96 28.424 91.343 53.594 21.59 20.595 38.808 47.72 48.47 84.03 10.542-9.203 20.88-18.468 31.063-27.656-4.29-31.932-15.97-55.526-32.344-74.313-18.983-21.777-44.68-37.112-73.25-49.436-56.814-24.508-124.14-35.88-167.408-68.53l-46.218-.002zm82.5 0c38.082 18.53 90.58 30.703 138.5 51.374 29.982 12.934 58.36 29.522 79.97 54.313 18.824 21.597 32.212 49.413 36.906 85.125 11.41-.115 22.933-1.572 34.31-4.53 6.072-51.136-23.834-93.087-67.217-125.345-44.564-33.135-102.834-54.48-144.157-60.938h-78.312zm148.47 0C344.61 28.898 374.5 44.279 400.688 63.75c47.9 35.617 83.894 86.4 73.843 148.28l-.592-.093c-3.8 20.62-11.742 36.798-22.907 50.532-16.013 19.697-39.146 34.58-66.905 48.342-55.517 27.525-128.875 50.104-192.844 103.407l-.343.31-.343.345-33.53 34.344-2.314-21.876-1.28-12.156-11.407 4.437c-33.53 13.054-62.26 31.723-89.72 50.906-5.284-2.04-8.91-4.855-11-8.217-2.192-3.53-3.116-8.167-1.968-14.688L118.28 399.5l1.314-.78.97-1.158c12.175-14.383 13.776-33.828 6.905-50.718l22.56 9.53c-.257-16.11-3.89-26.708-9.405-34.405-7.125-9.95-18.33-16.103-33.125-21.47-24.528-8.9-57.97-14.734-87.656-36.125v30.97c20.075 21.326 47.712 29.102 67.72 34.686l1.717.72c9.795 5.807 16.654 13.605 20.345 21.72 5.218 11.472 4.48 22.9-2.563 31.967l-80.937 49.344-3.188 1.97-.968 3.594c-3.275 12.18-2.11 23.814 3.5 32.844 5.608 9.03 15.048 14.85 25.905 17.75l4.22 1.125 3.56-2.532c25.008-17.58 50.215-34.295 78.314-46.75l3.093 29.19 2.062 19.78 13.906-14.25 47.064-48.188c60.463-50.24 131.272-72.253 188.812-100.78 28.825-14.29 54.484-30.322 73.125-53.25 17.733-21.81 28.453-49.89 29.47-86.25l.125-.063v-14.845h-.063c.264-81.24-73.275-134.13-132.937-155.313h-46.563zM19.842 51.03v52.75c10.487 24.406 27.77 38.944 49.75 50.25 23.378 12.026 51.937 19.68 80.626 29.376 28.687 9.696 57.71 21.552 81.28 43.313 20.874 19.27 36.986 46.308 44.563 84.624 11.905-7.347 23.528-15.285 34.937-23.625-10.11-42.448-28.82-69.71-52.375-89.69-25.635-21.74-57.498-34.732-90.47-46.81-32.97-12.08-66.98-23.17-96.155-42.47-20.953-13.86-39.27-32.264-52.156-57.72zm0 87.845v38.813l.22-.157C44.636 212.48 90.37 218.744 135 234c22.315 7.63 44.27 17.78 61.344 36.313 14.593 15.84 25.135 37.576 29.562 67.343 11.21-4.807 22.2-10.24 32.97-16.22-6.31-38.705-20.892-63.268-40.063-80.967-20.417-18.85-46.672-29.92-74.563-39.345-27.89-9.426-57.24-17.12-83.188-30.47-15.407-7.924-29.668-18.113-41.218-31.78zm493.97 34.25v4.28l7.562-4.28h-7.563zm-493.97 32.22v34.905c27.883 25.858 63.202 31.502 94.032 42.688 16.226 5.887 31.563 13.672 41.938 28.156 7.978 11.138 12.446 25.657 12.875 44.5 13.415-2.626 26.51-6.334 39.312-10.906-3.538-29.16-12.852-48.093-25.406-61.72-13.957-15.15-32.584-24.087-53.625-31.28-35.713-12.21-78.587-18.57-109.126-46.344z",
	credit="https://game-icons.net/lorc/originals/wave-strike.html",
)
[[glyphs/wingedShield.easel]]
pub glyph WingedShield:Glyph(
	path="M133.813 37.28C103.96 66.698 96.25 109.353 110.28 145.47c-36.49-20.383-64.53-55.487-74.624-98.907-24.28 73.892 10.364 151.554 77.406 183.812-32.378 8.965-67.574-2.14-92.843-33.03 13.227 64.09 61.895 103.305 111.843 93.905-6.975 30.883-30.75 49.33-62.032 44.438 34.323 27.377 71.306 27 91.157 2.437 12.456 22.323 27.246 44.204 44.375 65.438l-23.125 12.062c16.96 26.955 42.62 53.035 75.907 77.125 31.79-23.093 55.416-48.452 72.437-74.28l-22.81-11.845c18.262-22.29 33.963-45.313 47.124-68.844 19.78 24.912 56.984 25.416 91.47-2.092-31.284 4.89-55.09-13.554-62.064-44.438 49.96 9.422 98.644-29.8 111.875-93.906-25.27 30.89-60.465 41.996-92.844 33.03 67.044-32.257 101.688-109.92 77.408-183.81-10.097 43.428-38.153 78.525-74.657 98.905 14.035-36.12 6.356-78.772-23.5-108.19 12.743 50.553-15.21 102.74-63.842 120.345-39.307 2.985-81.754 3.038-121.063.094-48.77-17.527-76.824-69.81-64.063-120.44zm252.156 130.595c-3.963 92.26-46.662 184.737-127.908 265.78-81.665-81.18-123.585-173.522-127.437-265.75 75.58 14.548 179.816 14.366 255.344-.03z",
	credit="https://game-icons.net/1x1/lorc/winged-shield.html",
)
[[glyphs/woodenFence.easel]]
pub glyph WoodenFence:Glyph(
	path="M149.725 16.338L90.627 79.926v348.678l59.098 63.582 18.584-61.58h51.895l37.91 61.58 37.91-61.58h51.895l18.584 61.58 59.098-63.582V79.926l-59.098-63.588-19.188 63.588v1.97h-50.058v-1.97l-39.143-63.588-39.142 63.588v1.97h-50.06v-1.97l-19.188-63.588zm19.187 84.244h50.06v142.486h-50.06V100.582zm128.346 0h50.058v142.486h-50.058V100.582zM168.912 261.756h50.06v150.162h-50.06V261.756zm128.346 0h50.058v150.162h-50.058V261.756z",
	credit="https://game-icons.net/lorc/originals/wooden-fence.html",
)
[[home.easel]]
pub page fn owner.HomePage {
	Nav {
		Button(icon="fas fa-gamepad", onPress=Main) { %("Play") }
		Button(icon="fas fa-eye", onPress=SpectatePage) { %("Spectate") }
		Blank(lines=1)
		Button(icon="fas fa-user", onPress=owner.UserId) { %("Profile") }
		Button(icon="fas fa-trophy", onPress=HighestRatedLeaderboard) { %("Leaderboard") }
		Blank(lines=1)
		Button(icon="fas fa-cog", onPress=SettingsPage) { %("Settings") }
		Button(icon="fas fa-info-circle", onPress=AboutPage) { %("About") }
	}

	Toolbar {
		Button(icon="fas fa-trophy", onPress=HighestRatedLeaderboard) { %("Leaderboard") }
	}

	Landing<title>(placement=$hero) {
		H1(animation=$scalingLoop) {
			Span(animation=$flyFromLeft) { %("Acolyte") }
			%(" ")
			Span(animation=$flyFromRight) { %("Fight!") }
		}
		H2(animation=$flyFromBottom) {
			%("Skillshot Arena")
		}
	}

	Landing<menu> {
		Span(animation=$flyFromBottom) {
			P {
				Span(scale=0.8) { %("Choose Your Name") }
				%(LineBreak)
				NameEditor(pixelWidth=350)
			}

			P(scale=1.5) {
				Button(onPress=Main, tier=$primary, pixelWidth=350) { %("Play") }
			}

			P {
				Button(onPress="bookmark:belowFold", tier=$secondary, pixelWidth=350) { %("Choose Your Abilities") }
			}
		}
	}

	Section {
		Bookmark("belowFold")

		hook PlayerName {
			Fragment { H1 {%(PlayerName + ", your destiny awaits!")} }
		}

		P {
			%("Our Warlocks have fallen! Their valiant sacrifice shall forever be remembered. ")
			%("Young Acolyte, fate has hastened the hour of your destiny, as your vulnerable homeland now turns to you to as one of the last remaining keepers of magic. ")
			%("With no mentors to guide you, the path to mastery lies in your hands. ")
		}

		P {
			%("Venture into the enigmatic mirror dimension within your school of magic, challenging your fellow Acolytes to battle. ")
			%("Together you will hone your skills, forging unbreakable bonds while rediscovering the lost arcane wisdom that once made the Warlocks so formidable. ")
			%("Through perseverance and unity, you will rise as the new generation of Warlocks, standing resolute against the ever-encroaching darkness that threatens your homeland. ")
		}

		P {
			%("Young Acolyte, you have much to learn, and the shadow of our adversaries grows ever closer. Embrace your destiny! ")
		}
		
		H1 { %("Choose Your Abilities") }
		SlotEditors
	}

	UnrankedTool(placement=$important)
}
[[layouts.easel]]
pub fn scene.RandomLayout() {
    const layout = PickRandom([
        () => CircleLayout
        () => ColdLayout
        () => OctogonLayout
        () => ReturnLayout
        () => DoubleLayout
        () => RingLayout
        () => ExitLayout
        () => HealLayout
        () => SnowflakeLayout
        () => Inside5Layout
        () => SingleLayout
        () => PepperLayout
        () => MirrorsLayout
        () => InnerStarLayout
        () => MirrorhengeLayout
        () => SpiralLayout
        () => TripletLayout
        () => SquareLayout
        () => SurroundedLayout
        () => TripletSwirlLayout
    ])
    layout()
}
[[layouts/circle.easel]]
pub fn scene.CircleLayout {
	Lava
	Shrink
	SolidBackground(color=#2a1b2c)

	Spawn turf {
		Turf(color=#413243) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}
}
[[layouts/cold.easel]]
pub fn scene.ColdLayout {
	Lava
	Shrink
	SolidBackground(color=#25192e)

	Spawn turf {
		Turf(color=#41324e) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=6)
			}
		}
	}

	ArrangeRing(orbit=27.2, numObstacles=6, angleOffset=0.5rev / numObstacles) {
		Spawn obstacle {
			Ice {
				Shape:Arc(radius=0.2, arc=0.72rev / numObstacles, cap=true)
			}
		}
	}

	ArrangeRing(orbit=5.8, numObstacles=3, angleOffset=0.5rev / numObstacles) {
		Spawn obstacle {
			Ice {
				Shape:Arc(radius=0.16, arc=0.6rev / numObstacles, cap=true)
			}
		}
	}

	ArrangeRing(orbit=5.8, numObstacles=3) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=6, radius=0.8)
			}
		}
	}

	ArrangeRing(orbit=27.2, numObstacles=3) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=6, radius=1.2)
			}
		}
	}
}
[[layouts/double.easel]]
pub fn scene.DoubleLayout {
	Lava
	Shrink
	SolidBackground(color=#2e2619)

	Spawn turf {
		Turf(color=#453b2a) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=4)
			}
		}
	}

	ArrangeRing(orbit=5.6, numObstacles=2, angleOffset=0.125rev, headingOffset=0.125rev) {
		Spawn obstacle {
			Bumper {
				Shape:Equilateral(numPoints=4, radius=1.36)
			}
		}
	}

	ArrangeRing(orbit=26.4, numObstacles=4) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=0.72)
			}
		}
	}
}
[[layouts/exit.easel]]
pub fn scene.ExitLayout {
	Lava
	Shrink
	SolidBackground(color=#2b1f1d)

	Spawn turf {
		Turf(color=#433632) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}

	ArrangeRing(orbit=8, numObstacles=3) {
		Spawn obstacle {
			Conveyor(convey=@(5,0), maxHp=200) {
				Shape:Arc(radius=2.4, arc=0.5rev / numObstacles)
			}
		}
	}

	ArrangeRing(orbit=18.4, numObstacles=3, angleOffset=0.5rev / numObstacles) {
		Spawn obstacle {
			Boost {
				Shape:Arc(radius=0.16, arc=0.15rev, cap=true)
			}
		}
	}

	ArrangeRing(orbit=20, numObstacles=30, angleOffset=0.5rev / 3, pattern=[1,1,1,0,0,0,0,0,1,1]) {
		Spawn obstacle {
			Explosive(radius=0.4)
		}
	}
}
[[layouts/heal.easel]]
pub fn scene.HealLayout {
	Lava
	Shrink
	SolidBackground(color=#2b1d1d)

	Spawn turf {
		Turf(color=#413130) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=6)
			}
		}
	}

	Spawn obstacle {
		Healing(pos=@(0,0), heading=0.5rev / 6) {
			Shape:Equilateral(numPoints=6, radius=1.6)
		}
	}

	ArrangeRing(orbit=6.8, numObstacles=6) {
		Spawn obstacle {
			Boost {
				Shape:Trapezoid(radius=0.24, arc=1rev / numObstacles)
			}
		}
	}

	ArrangeRing(orbit=20, numObstacles=6) {
		Spawn obstacle {
			Boulder {
				Shape:Trapezoid(radius=2, arc=0.008rev)
			}
		}
	}

	once BeforeCommence {
		Transmission<heal>(duration=15s) {
			P {
				%("Fight over this ")
				Span(bold=true, color=#0f9) { %("healing pool!") }
			}
		}
	}
}
[[layouts/innerStar.easel]]
pub fn scene.InnerStarLayout {
	.. orientation=0.1rev

	Lava
	Shrink
	SolidBackground(color=#2b1c22)

	Spawn turf {
		Turf(color=#443138, heading=orientation) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=5)
			}
		}
	}

	ArrangeRing(orbit=25.6, numObstacles=5) {
		Spawn obstacle {
			Volcano {
				Shape:Arc(radius=0.16, arc=0.15rev, cap=true)
			}
		}
	}

	ArrangeRing(orbit=5.6, numObstacles=10, angleOffset=orientation, headingOffset=0.5rev) {
		Spawn obstacle {
			Explosive(radius=0.4)
		}
	}

	ArrangeRing(orbit=25.6, numObstacles=5, angleOffset=orientation, headingOffset=0.5rev) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=1.6)
			}
		}
	}
}
[[layouts/inside5.easel]]
pub fn scene.Inside5Layout {
	Lava
	Shrink
	SolidBackground(color=#2a1d20)

	Spawn turf {
		Turf(color=#413034) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=5)
			}
		}
	}

	Spawn obstacle {
		Volcano(pos=@(0,0)) {
			Shape:Circle(radius=2)
		}
	}

	ArrangeRing(orbit=12, numObstacles=5, angleOffset=0.5rev / numObstacles, headingOffset=0.5rev) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=3, radius=1.2)
			}
		}
	}
}
[[layouts/mirrorhenge.easel]]
pub fn scene.MirrorhengeLayout {
	Lava
	Shrink
	SolidBackground(color=#29221e)

	Spawn turf {
		Turf(color=#413834) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}

	ArrangeRing(orbit=14.4, numObstacles=4, angleOffset=1rev / 12) {
		Spawn obstacle {
			Boost {
				Shape:Trapezoid(radius=0.24, arc=1rev / numObstacles)
			}
		}
	}

	ArrangeRing(orbit=5.8, numObstacles=3, angleOffset=0.2rev) {
		Spawn obstacle {
			Boulder(turningDecay=0.01) {
				Shape:Trapezoid(radius=1.44, arc=0.03rev)
			}
		}
	}

	ArrangeRing(orbit=28, numObstacles=36, angleOffset=0.125rev, pattern=[1,1,0,0,0,1]) {
		Spawn obstacle {
			Mirror {
				Shape:Trapezoid(radius=0.4, arc=0.02rev)
			}
		}
	}
}
[[layouts/mirrors.easel]]
pub fn scene.MirrorsLayout {
	Lava
	Shrink
	SolidBackground(color=#25192e)

	Spawn turf {
		Turf(color=#41334d) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=7)
			}
		}
	}

	ArrangeRing(orbit=17.6, numObstacles=7) {
		Spawn obstacle {
			Mirror {
				Shape:Trapezoid(radius=0.4, arc=0.05rev)
			}
		}
	}
}
[[layouts/octogon.easel]]
pub fn scene.OctogonLayout {
	Lava
	Shrink
	SolidBackground(color=#241d2b)

	Spawn turf {
		Turf(color=#41344b) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=8)
			}
		}
	}

	ArrangeRing(orbit=6, numObstacles=3, angleOffset=0.125rev) {
		Spawn obstacle {
			Ice {
				Shape:Trapezoid(radius=0.2, arc=1rev / numObstacles)
			}
		}
	}

	ArrangeRing(orbit=20, numObstacles=20, pattern=[1,1,1,0,0]) {
		Spawn obstacle {
			Boulder(density=5) {
				Shape:Trapezoid(radius=0.72, arc=0.015rev)
			}
		}
	}
}
[[layouts/pepper.easel]]
pub fn scene.PepperLayout {
	Lava
	Shrink
	SolidBackground(color=#2b261d)

	Spawn turf {
		Turf(color=#413a30) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=5)
			}
		}
	}

	ArrangeRing(orbit=25.6, numObstacles=5, headingOffset=1rev / 6) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=3, radius=1.36)
			}
		}
	}

	ArrangeRing(orbit=9.6, numObstacles=5, angleOffset=0.5rev / numObstacles) {
		Spawn obstacle {
			Bumper {
				Shape:Trapezoid(radius=0.8, arc=0.04rev)
			}
		}
	}
}
[[layouts/return.easel]]
pub fn scene.ReturnLayout {
	.. orientation=0.2rev

	Lava
	Shrink
	SolidBackground(color=#2b1c22)

	Spawn turf {
		Turf(color=#433239, heading=orientation) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=6)
			}
		}
	}

	Spawn obstacle {
		Volcano(pos=@(0,0), heading=orientation + 0.5rev) {
			Shape:Equilateral(numPoints=3, radius=2)
		}
	}

	ArrangeRing(orbit=12, numObstacles=3, angleOffset=orientation) {
		Spawn obstacle {
			Conveyor(convey=@(-5,0), maxHp=200) {
				Shape:Trapezoid(radius=8, arc=0.01rev)
			}
		}
	}

	ArrangeRing(orbit=20, numObstacles=3, angleOffset=orientation + 0.5rev / numObstacles) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=0.8)
			}
		}
	}
}
[[layouts/ring.easel]]
pub fn scene.RingLayout {
	.. orientation = 0.5rev / 6

	Lava
	Shrink
	SolidBackground(color=#2b1d1d)

	Spawn turf {
		Turf(color=#463434, heading=orientation) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=4)
			}
		}
	}

	ArrangeRing(orbit=10.6, numObstacles=10) {
		Spawn obstacle {
			Boost {
				Shape:Arc(radius=0.2, arc=1rev / numObstacles)
			}
		}
	}

	Spawn obstacle {
		Mirror(pos=@(0,0), heading=orientation / 2) {
			Shape:Equilateral(numPoints=6, radius=1.2)
		}
	}

	ArrangeRing(orbit=25.6, numObstacles=4, angleOffset=orientation) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=0.8)
			}
		}
	}
}
[[layouts/single.easel]]
pub fn scene.SingleLayout {
	Lava
	Shrink
	SolidBackground(color=#2b1d27)

	Spawn turf {
		Turf(color=#463441) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=3)
			}
		}
	}

	Spawn obstacle {
		Boulder(pos=@(0,0), turningDecay=0.001) {
			Shape:Equilateral(numPoints=3, radius=1.36)
		}
	}
}
[[layouts/snowflake.easel]]
pub fn scene.SnowflakeLayout {
	.. orientation = 0.5rev / 6

	Lava
	Shrink
	SolidBackground(color=#2c1e1b)

	Spawn turf {
		Turf(color=#493936, heading=orientation) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=6)
			}
		}
	}

	ArrangeRing(orbit=6.8, numObstacles=2) {
		Spawn obstacle {
			Boost {
				Shape:Trapezoid(radius=0.24, arc=0.24rev)
			}
		}
	}

	ArrangeRing(orbit=9.6, numObstacles=4, angleOffset=0.5rev / numObstacles) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=1.36)
			}
		}
	}

	ArrangeRing(orbit=28, numObstacles=6, angleOffset=orientation) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=0.6)
			}
		}
	}
}
[[layouts/spiral.easel]]
pub fn scene.SpiralLayout {
	Lava
	Shrink
	SolidBackground(color=#2b211d)

	Spawn turf {
		Turf(color=#413530) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}

	ArrangeRing(orbit=14, numObstacles=5, headingOffset=-0.15rev) {
		Spawn obstacle {
			Conveyor(convey=@(0,-5)) {
				Shape:Arc(radius=0.12, arc=0.24rev)
			}
		}
	}

	Spawn obstacle {
		Bumper(pos=@(0,0)) {
			Shape:Equilateral(numPoints=4, radius=1.2)
		}
	}

	ArrangeRing(orbit=28, numObstacles=5, angleOffset=0.2rev, headingOffset=1rev / 6) {
		Spawn obstacle {
			Explosive(radius=0.4)
		}
	}
}
[[layouts/square.easel]]
pub fn scene.SquareLayout {
	.. orientation = 0.5rev / 4

	Lava
	Shrink
	SolidBackground(color=#2a1b2c)

	Spawn turf {
		Turf(color=#413243, heading=orientation) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=4)
			}
		}
	}

	ArrangeRing(orbit=16, numObstacles=2, angleOffset=orientation) {
		Spawn obstacle {
			Boost(maxHp=200) {
				Shape:Arc(radius=0.16, arc=0.25rev, cap=true)
			}
		}
	}

	ArrangeRing(orbit=26.4, numObstacles=2, angleOffset=orientation) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=4, radius=0.72)
			}
		}
	}
}
[[layouts/surrounded.easel]]
pub fn scene.SurroundedLayout {
	Lava
	Shrink
	SolidBackground(color=#2c211b)

	Spawn turf {
		Turf(color=#433832) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}

	ArrangeRing(orbit=28, numObstacles=15, angleOffset=0.1rev, headingOffset=0.5rev, pattern=[1,1,1,1,0]) {
		Spawn obstacle {
			Boulder {
				Shape:Equilateral(numPoints=3, radius=1.04)
			}
		}
	}

	ArrangeRing(orbit=12, numObstacles=6, angleOffset=0.5rev / numObstacles, headingOffset=0.5rev) {
		Spawn obstacle {
			Bumper {
				Shape:Equilateral(numPoints=4, radius=0.72)
			}
		}
	}

	Spawn obstacle {
		Boulder(pos=@(0,0), heading=0.5rev) {
			Shape:Equilateral(numPoints=4, radius=0.8)
		}
	}
}
[[layouts/triplet.easel]]
pub fn scene.TripletLayout {
	Lava
	Shrink
	SolidBackground(color=#2b192e)

	Spawn turf {
		Turf(color=#422f46, heading=0.5rev / 3) {
			hook ShrinkScale {
				Shape:Equilateral(radius=32 * ShrinkScale, numPoints=3)
			}
		}
	}

	ArrangeRing(orbit=22.4, numObstacles=3, angleOffset=0.5rev, headingOffset=0.5rev) {
		Spawn obstacle {
			Boulder(turningDecay=0.003) {
				Shape:Equilateral(numPoints=3, radius=1.8)
			}
		}
	}
}
[[layouts/tripletSwirl.easel]]
pub fn scene.TripletSwirlLayout {
	Lava
	Shrink
	SolidBackground(color=#2c1b23)

	Spawn turf {
		Turf(color=#413038) {
			hook ShrinkScale {
				Shape:Circle(radius=32 * ShrinkScale)
			}
		}
	}

	ArrangeRing(orbit=24, numObstacles=3, angleOffset=0.18rev, headingOffset=0.125rev) {
		Spawn obstacle {
			Volcano {
				Shape:Equilateral(numPoints=6, radius=2)
			}
		}
	}

	ArrangeRing(orbit=11.2, numObstacles=3, angleOffset=0.28rev, headingOffset=0.125rev) {
		Spawn obstacle {
			Boulder(maxHp=20) {
				Shape:Equilateral(numPoints=3, radius=0.6)
			}
		}
	}

	ArrangeRing(orbit=17.6, numObstacles=3, angleOffset=0.23rev, headingOffset=0.125rev) {
		Spawn obstacle {
			Boulder(maxHp=20) {
				Shape:Equilateral(numPoints=3, radius=0.9)
			}
		}
	}

	ArrangeRing(orbit=4.8, numObstacles=15, angleOffset=0.055rev + 1rev/6, pattern=[1,1,1,0,0]) {
		Spawn obstacle {
			Explosive(radius=0.4)
		}
	}
}
[[leaderboards.easel]]
pub page fn owner.HighestRatedLeaderboard {
    Section {
        LeaderboardSelector

        H1 { %("Best Players") }

        LeaderboardRows([&Rating, &NumGames]) player {
            Span(scale=0.75, color=#eee, reveal=true) {
                %(player.NumGames)
                %(" games")
            }
            Right {
                Span {
                    %(FormatToFixed(player.Rating, 0))
                    %(" rating")
                }
            }
        }
    }
}

pub page fn owner.MostGamesLeaderboard {
    Section {
        LeaderboardSelector

        H1 { %("Most Games") }

        LeaderboardRows([&NumGames, &Rating]) player {
            Span(scale=0.75, color=#eee, reveal=true) {
                %(FormatToFixed(player.Rating, 0))
                %(" rating")
            }
            Right {
                Span {
                    %(player.NumGames)
                    %(" games")
                }
            }
        }
    }
}

fn LeaderboardSelector(.. ui) {
    Row {
        Pill(onPress=HighestRatedLeaderboard) { %("Best") }
        Pill(onPress=MostGamesLeaderboard) { %("Most Games") }
    }
}

fn this.LeaderboardRows(fields, .. ui, limit=100) player .. ui {
    // First output a loading message inside a Fragment so we can replace it later
    Fragment<leaderboard> {
        Span { %("Loading...") }
    }

    // Then fetch the leaderboard and once that has returned the ranking, replace the Fragment with the real data
    once FetchLeaderboard(fields, limit=) ranking {
        Fragment<leaderboard> {
            let rank = 1
            for player in ranking {
                let league = FindLeague(player.Rating)
                Sash(backgroundColor=league.color) {
                    Span(scale=0.75, color=#eee, chars=2, align=$center) {
                        %(rank)
                    }
                    Medal(glyph=league.glyph, scale=1.2, backgroundColor=league.color, tooltip=league.name)
                    Span(scale=1.2, bold=true) {
                        Link(tier=$subtle, onPress=player.UserId) {
                            %(player.PlayerName)
                        }
                    }

                    delve(player)
                }

                rank += 1
            }
        }
    }
}
[[main.easel]]
meta Project(name="Acolyte Fight!", author="raysplaceinspace")

meta PlayerNames(defaultPrefix="Acolyte")
meta PlayerColors(
	selfColor=#00ccff,
	colors=[#f58c81, #54c794, #b69cf6, #e09f47, #e08747, #e58cc5, #a9b852, #6eb2fd],
	teamHueRange=10.0, teamHueStep=7.0,
)

pub mode fn World.Main {
	Introducer
	Scoreboard<NumOutlasts:Session>("Most Outlasts", icon="fas fa-skull")
	Scoreboard<NumWins:Session>("Most Wins", icon="fas fa-crown")
	Scoreboard<NumGames:Session>("Most Games", icon="fas fa-hourglass-start")

	Spawn scene {
		RandomLayout
	}

	SpawnPlayer owner {
		if owner.IsHuman {
			QueryPlayers.WhereIsHuman(false).FindAny.DespawnBot // Replace a bot with a human
		} else {
			BotChooseSpells
		}

		SlotRandomizeTool(tooltip="Randomize your abilities", placement=$important) { RandomizeAllSlots }
		SlotLoadoutTool(tooltip="Choose your abilities", placement=$important) {
			H1 {%("Choose Your Abilities")}
			SlotEditors
		}

		Spawn unit {
			AudioCenter // spatial audio is calculated around this unit
			PointerCenter // emulated pointers (e.g. touchscreen or gamepads) are relative to this unit
			PointerLine(color=#0001, radius=0.5, depth=Depth:Aim)

			Hero(owner=, pos=NextStartingPosition(radiusFraction=0.4))
			SlotAbilities
			AntiTeamingBonus

			Tombstone { // add a backup Tombstone in case the user does not get hit by anything
				NameBlock
				%(" died")
			}

			once BeforePlayerLeave {
				if IsReadyToBegin && !HasConcluded {
					// During the game, no one leaves, instead wait until the game is complete
					await Conclude
					await Sleep(2s)
				}
				delete unit.Tombstone // Voluntary leaving should not count as a kill
				unit.HeroExit
			}

			hook IsPresent {
				if IsPresent {
					delete Bot
				} else {
					Bot
				}
			}

			once Expire {
				Eliminate(owner)

				// Spawn a ghost unit and attach abilities to it so the player can still edit their spells after they are dead
				.. parent = unit
				Spawn unit {
					Ghost
					SlotAbilities
				}
			}
		}

		once AfterCommence {
			SlotsUneditable = true
		}

		once IsEliminated {
			SlotsUneditable = false

			EliminatedDialog { 
				H1 { %("You Died") }
				Button(tier=$primary, onPress=Main) { %("Play Again") }
			}

			if Outlast:IsGameComplete {
				Victory = Outlast:CalculateRanking
			}
		}

		on Rating:OnChange {
			Rating:AnnounceChange
		}

		once Conclude {
			SlotsUneditable = false
		}
	}

	PlayVsAiDialog {
		const numBots=7
		for i in Range(0, numBots) {
			SpawnBot(name="AcolyteBot") player {
				// Make the bot automatically leave when the game ends
				await Conclude
				await Sleep(2s)
				player.DespawnBot
			}
		}
	}

	CommenceCountdown(waitForMoreDelay=12s, commenceDelay=3s) {
		let numPlayers = QueryPlayers.Count
		if numPlayers < 2 { return false }

		let numBots = QueryPlayers.WhereIsHuman(false).Count
		if numPlayers < 4 && numBots == 0 { return WaitForMorePlayers }

		return true
	}

	once BeforeCommence {
		Teams:Individual
	}

	once AfterCommence {
		Transmission<announceStart>(duration=15s) {
			P {
				%("Game started. ")
				Span(bold=true) { %("Defeat your enemies!") }
			}
		}
	}

	once Victory ranking {
		Conclude(ranking)
		VictoryDialog
		DiscordAd

		if ranking.Where(p => p.IsHuman).Length >= 2 { // Single player games do not count towards stats
			NumGames:Accumulate
			NumOutlasts:Accumulate
			NumWins:Accumulate
			Rating:Accumulate
		}
	}
}
[[obstacles/boost.easel]]
.. owner = null

pub fn obstacle.Boost(pos, heading?=0, maxHp=50, radius=0.25) .. shape {
	.. density=1.0,
	.. color=#ff4c, fade=#ff44,
	.. bloom=2.0, bloomAlpha=0.3, luminous=1,
	.. shading=0, shadow=0, depth=Depth:Zone,
	.. categories=(Category:Zone | Category:HurtByLava),
	.. collideWith=Category:None, sense=Category:Hero,
	.. durability=Durability:Maximum,
	.. isSensor=true, immovable=true, ccd=false

	Body(pos, heading=)
	PrepareForCollision
	Health(maxHp)

	BuffOnContact<boost>(filter=Category:Hero) that {
		SpeedModifier(0.5, that)
		Smoke(that,
			color=#ff4c, fade=1, ownerColor=true, owner=that.Owner,
			radius=1.0, depth=Depth:Buff,
			dissipation=30, luminous=1, feather=0, bloom=0,
			splatter=Splatter:Outwards(5.0))
	}

	Collider {
		Sprite {
			Perimeter {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps
		Smoke(
			luminous=1.0, shine=0.2, bloom=0, shadow=0,
			dissipation=15, splatter=Splatter:Outwards(4.0),
			flutter=$area)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=2.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/boulder.easel]]
.. owner=null

pub fn obstacle.Boulder(pos, heading?=0, maxHp=100.0, radius=1.0, density=50.0, turningDecay=0.05) .. shape {
	.. color=#bbb, fade=#822,
	.. bloom=0, luminous=0,
	.. shading=0.25, depth=Depth:Obstacle,
	.. categories=(Category:Obstacle | Category:CanGrab | Category:HurtByLava | Category:Aoe),
	.. collideWith=Category:Solid,
	.. durability=Durability:Maximum,
	.. ccd=false

	Body(pos, heading=)
	PrepareForCollision
	DecayingMotion(turningDecay=)

	Health(maxHp)

	Collider {
		Sprite {
			Perimeter {
				delve()
			}
		}
	}

	Anchored(pos, heading)
	once AfterCommence { delete Anchored }

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps(shadow=0.5)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=1.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/bumper.easel]]
.. owner=null

pub fn obstacle.Bumper(pos, heading?=0, maxHp=100.0, impulse=200, radius=1.0, density=1.0) .. shape {
	.. color=#c94, fade=#753,
	.. bloom=0, luminous=0,
	.. shading=0.25, depth=Depth:Obstacle,
	.. categories=(Category:Obstacle | Category:CanGrab | Category:HurtByLava | Category:Aoe),
	.. collideWith=Category:Solid,
	.. durability=Durability:Maximum,
	.. ccd=false

	Body(pos, heading=)
	PrepareForCollision
	DecayingMotion(turningDecay=0.05)

	Health(maxHp)

	Collider {
		Sprite {
			Perimeter shape {
				delve()
			}
		}
	}

	Anchored(pos, heading)
	once AfterCommence { delete Anchored }

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps(shadow=0.5)
	}

	on BeforeCollide that {
		if that.Category & (Category:Hero | Category:Obstacle) {
			that.ApplyImpulse(impulse * Direction(that.Pos - this.Pos))
			Strobe(dissipation=10, shine=0.5, growth=0.5)
			Hear(Obstacle:Bumper)
		}
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=1.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}

sound Obstacle:Bumper(duration=0.5s) {
	Vibrato(freqModulation=120) {
		Oscillator(freq=240)
	}
	Oscillator(wave=$square, freq=120)
	LowPass(freq=120)
	HighPass(freq=40)
	Envelope(attack=0.001s, sustain=0s)
}
[[obstacles/conveyor.easel]]
.. owner = null

pub fn obstacle.Conveyor(pos, heading?=0, convey, maxHp=50, radius=0.25) .. shape {
	.. density=1.0,
	.. color=#3332, fade=#3331,
	.. bloom=0, luminous=1,
	.. shading=0, shadow=0, depth=Depth:Zone,
	.. categories=(Category:Zone | Category:HurtByLava),
	.. collideWith=Category:None, sense=Category:Aoe,
	.. durability=Durability:Maximum,
	.. isSensor=true, immovable=true, ccd=false

	Body(pos, heading=)
	PrepareForCollision
	Health

	// reuse=false so a new buff is created each time a new conveyor is entered.
	// This is important because we expect different conveyors to point in different directions and so the buff must be refreshed each time.
	BuffOnContact<conveyor>(reuse=false, filter=Category:Aoe) that {
		hook Tick {
			that.ApplyPositionStep(Rotate(convey, obstacle.Heading) / TicksPerSecond)
		}
	}

	Collider {
		Sprite {
			Perimeter {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps
		Smoke(
			radius=, luminous=1.0, shine=0.5, bloom=0, shadow=0,
			interval=6, dissipation=45, splatter=Splatter:Conveyor(convey),
			flutter=$area)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=2.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/explosive.easel]]
.. owner = null

pub fn obstacle.Explosive(pos, heading?=0, maxHp=50.0, impulse=350, radius=0.4, aoe=4.0, density=10.0) {

	.. dissipation=30,
	.. color=#fc0,
	.. bloom=0, luminous=0,
	.. shading=0.25, depth=Depth:Obstacle,
	.. categories=(Category:Obstacle | Category:CanGrab | Category:HurtByLava | Category:Aoe),
	.. collideWith=Category:Solid, sense=Category:Zone,
	.. durability=Durability:Maximum,
	.. ccd=true

	Body(pos, heading=)
	PrepareForCollision
	DecayingMotion(turningDecay=0.05)

	Health
	on Hurt {
		Strobe(dissipation=10, shine=0.25, growth=0.2)
	}

	Anchored(pos, heading)
	once AfterCommence { delete Anchored }

	// Circular collider to make it more predictable where it will go when hit,
	// but triangular avatar to give it a distinctive shape
	Collider {
		Shape:Circle(radius=)
	}
	Sprite(shadow=0.5) {
		Shape:Equilateral(numPoints=3, radius=)
	}

	on BeforeCollide that {
		if HasCommenced && (that.Category & Category:Hero) {
			Puff(count=10, splatter=Splatter:Outwards(26), luminous=1)
			Explosion(aoe)
			Hear(Obstacle:Explosive)

			Aoe:ForEach that {
				Aoe:ImpulseAttenuated(that, attenuate=0.4)
				Aoe:Destroy(that)
				that.Interrupt
			}

			Expire
			break
		}
	}

	once BeforeOutOfHealth {
		Puff(count=3, shine=1, luminous=1, splatter=Splatter:Outwards(12))
	}
}

sound Obstacle:Explosive(duration=1s) {
	Vibrato(freqModulation=1000) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=40)
	LowPass(freq=[300,0])
	LowShelf(freq=80, db=12)
	Envelope(attack=0.01s, decay=0.07s, sustain=0s, sustainVolume=0.5)
}
[[obstacles/healing.easel]]
.. owner=null

pub fn obstacle.Healing(pos, heading?=0, maxHp=50, heal=4, selfDamage=4, decayDamage=2, radius=0.25) .. shape {
	.. healInterval=1s 
	.. color=#0f9, fade=#0f94,
	.. bloom=2.0, bloomAlpha=0.3, luminous=1
	.. shading=0, shadow=0, depth=Depth:Zone
	.. categories=(Category:Zone | Category:HurtByLava)
	.. collideWith=Category:None, sense=Category:Hero
	.. durability=Durability:Maximum, density=1
	.. isSensor=true, immovable=true, ccd=false

	Body(pos, heading=)
	PrepareForCollision
	Health

	BuffOnContact<healing>(filter=Category:Hero) that {
		Smoke(that,
			radius=1.0, dissipation=30, interval=15, depth=Depth:Particle,
			color=color.Fade(0.5), fade=1,
			luminous=1, feather=1, bloom=0,
			splatter=Splatter:Outwards(8.0))
		hook<heal> Sleep(healInterval) {
			that.Heal(healInterval * heal / TicksPerSecond)
			obstacle.TakeDamage(selfDamage)
		}
	}

	if decayDamage > 0 {
		hook<decay> Sleep(healInterval) {
			obstacle.TakeDamage(decayDamage)
		}
	}

	Collider {
		Sprite {
			Perimeter {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps
		Smoke(
			interval=4, dissipation=30,
			luminous=1.0, shine=0.2, bloom=0, shadow=0,
			splatter=Splatter:Outwards(4.0),
			flutter=$area)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=2.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/ice.easel]]
.. owner = null

pub fn obstacle.Ice(pos, heading?=0, maxHp=50, radius=0.25) .. shape {
	.. density=1.0,
	.. color=#4ffc, fade=#4ff4,
	.. bloom=2, bloomAlpha=0.3, luminous=1,
	.. shading=0, shadow=0, depth=Depth:Zone,
	.. categories=(Category:Zone | Category:HurtByLava),
	.. collideWith=Category:None, sense=Category:Hero,
	.. durability=Durability:Maximum,
	.. isSensor=true, immovable=true, ccd=false

	Body(pos, heading=)
	PrepareForCollision
	Health

	BuffOnContact<ice>(filter=Category:Hero) that {
		SpeedModifier(-0.5, that)
		Smoke(that,
			radius=1.0, dissipation=20, depth=Depth:Particle,
			color=#4ff4, fade=1, feather=0.5, bloom=0,
			splatter=Splatter:Outwards(12), flutter=$perimeter)
	}

	Collider {
		Sprite {
			Perimeter shape {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps
		Smoke(
			radius=, luminous=1.0, shine=0.2, bloom=0, shadow=0,
			dissipation=15, splatter=Splatter:Outwards(4.0),
			flutter=$area)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=2.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/mirror.easel]]
.. owner=null

pub fn obstacle.Mirror(pos, heading?=0, maxHp=100.0, radius=1.0, density=100.0) .. shape {
	.. color=#0cf, fade=#48f,
	.. bloom=0.5, luminous=1,
	.. shading=0.25, depth=Depth:Obstacle,
	.. categories=(Category:Shield | Category:CanGrab | Category:HurtByLava | Category:Aoe),
	.. collideWith=Category:Solid,
	.. durability=Durability:Shield,
	.. ccd=false

	Body(pos, heading=)
	PrepareForCollision
	DecayingMotion(turningDecay=0.05)

	Anchored(pos, heading)
	once AfterCommence { delete Anchored }

	Health

	Collider {
		Sprite {
			Perimeter shape {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps(shadow=0.5)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=1.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[obstacles/volcano.easel]]
.. owner=null

pub fn obstacle.Volcano(pos, heading?=0, maxHp=50, owner?, damage=36, radius=1.0) .. shape {
	.. damageInterval = 5
	.. color=#f08e, fade=#f084
	.. bloom=2, bloomAlpha=0.5, luminous=0
	.. shading=0, shadow=0, depth=Depth:Zone
	.. categories=(Category:Zone | Category:HurtByLava)
	.. collideWith=Category:None, sense=Category:Hero
	.. durability=Durability:Maximum, density=1
	.. isSensor=true, immovable=true, ccd=false

	Body(pos, heading=)
	PrepareForCollision
	Health

	BuffOnContact<volcano>(filter=Category:Hero) that {
		Smoke(that,
			color=, fade=1, luminous=1, feather=1, bloom=0,
			radius=1.0, dissipation=15, interval=4, depth=Depth:Particle,
			flutter=$perimeter, splatter=Splatter:Outwards(8.0))
		hook<dps> Sleep(damageInterval) {
			that.TakeDamage(damageInterval * damage / TicksPerSecond)
		}
	}

	Collider {
		Sprite {
			Perimeter {
				delve()
			}
		}
	}

	hook Hp {
		await TickEnd // coalesce multiple changes to HP into a single paint at the end of tick
		.. color = HpProportion.Mix(fade, color)

		SpriteProps
		Smoke(
			color=, fade=#0000, luminous=0,
			shine=0, bloom=0, shadow=0, feather=1,
			interval=8, dissipation=30, splatter=Splatter:Outwards(8.0),
			flutter=$area, depth=Depth:Buff)
	}

	once BeforeOutOfHealth {
		Puff(
			count=10, shadow=0,
			luminous=1.0, shine=1.0, bloom=2.0,
			dissipation=30, splatter=Splatter:Outwards(10.0),
			flutter=$area)
	}
}
[[physics/body.easel]]
pub fn body.LaunchBody(
	parent,
	..
	headingOffset?,
	pos=parent.Pos, speed,
	heading = parent.Heading + headingOffset, turnRate?,
	immovable?, ccd?) {

	Body(velocity = Direction(heading) * speed)
}

pub fn body.SynchronizeBody(unit .. ccd?) {
	Body(pos=unit.Pos, heading=unit.Heading, velocity=unit.Velocity, turnRate=unit.TurnRate)

	// Match the internal forces on the with the unit so it swoops between positions and collides with everything during the physics simulation.
	// If we just copied the position it might tunnel through objects and this would not happen.
	Movement:WalkWith(unit)
	Movement:TurnWith(unit)

	// Update the position and heading of the deflector each tick to be the same as the unit
	// This is needed in addition to the above because the unit have external forces applied
	on PhysicsStart {
		body.Pos = unit.Pos
		body.Heading = unit.Heading
		body.Velocity = unit.Velocity
		body.TurnRate = unit.TurnRate
	}
}
[[physics/collider.easel]]
// This sets properties which may be read when this entity collides with another.
pub fn body.PrepareForCollision(owner, categories, durability?=Durability:None) {
	body.Category = categories
	body.Owner = owner
	body.Durability = durability
}
[[physics/durability.easel]]
pub field body.Durability
[[physics/motion.easel]]
// If an entity with DriftingMotion gets hit, it will keep its new speed
pub fn body.DriftingMotion(.. turnRate?, turningDecay=0.5, alignHeadingToVelocity?) {
	Motion(speedDecay=0)
}

// If an entity with PropulsiveMotion gets hit, it will slowly revert (speed up or slow down) to its original speed.
pub fn body.PropulsiveMotion(propulsion=0.05, .. speed, maxSpeed?, turnRate?, turningDecay=0.5, alignHeadingToVelocity?) {
	Motion(speedDecay=propulsion)
}

// If an entity with DecayingMotion gets hit, it will slowly revert to zero speed
pub fn body.DecayingMotion(speedDecay=0.0488, .. maxSpeed?=100.0, turnRate?, turningDecay=0.5, alignHeadingToVelocity?) {
	Motion
}
[[physics/movement.easel]]
prop body.Movement:TargetAngle
prop body.Movement:TargetPosition

pub signal body.Movement:Walked(step)
pub signal body.Movement:Turned(step)

pub fn body.Movement:Look(heading) {
	body.Movement:TargetAngle = heading
}

pub fn body.Movement:LookAt(target) {
	body.Movement:TargetAngle = Angle(target - body.Pos)
}

pub fn body.Movement:WalkTo(target) {
	body.Movement:TargetPosition = target
}

pub fn Movement:Stop(body) {
	body.Movement:TargetPosition = null
	body.Movement:TargetAngle = null
}

pub behavior fn this.Movement:Walk(body, speed) {
	loop {
		await PhysicsStart

		// Step towards the target
		let target = body.Movement:TargetPosition
		if !target {
			// If no target, wait for one
			await body.Movement:TargetPosition
			continue
		}

		let limit = body.SpeedModifier * speed / TicksPerSecond

		let delta = target - body.Pos
		let step = delta
		if Length(step) > limit {
			step = Truncate(step, limit)
		} else {
			// We will have arrived after body step
			body.Movement:TargetPosition = null
		}

		body.ApplyPositionStep(step)
		body.Movement:Walked(step)
	}
}

pub behavior fn this.Movement:Turn(body, turnRate=1revs) {
	loop {
		await PhysicsStart

		// Step towards the target
		let target = body.Movement:TargetAngle
		if !target {
			// If no target, wait for one
			await body.Movement:TargetAngle
			continue
		}

		let limit = body.TurnRateModifier * turnRate

		let delta = body.Heading.AngleDelta(target)
		let step = delta
		if Abs(step) > limit {
			step = Truncate(step, limit)
		} else {
			// We will have arrived after body step
			body.Movement:TargetAngle = null
		}

		body.ApplyTurningStep(step)
		body.Movement:Turned(step)
	}
}

pub fn body.Movement:WalkWith(parent) {
	on parent.Movement:Walked step {
		body.ApplyPositionStep(step)
	}
}

pub fn body.Movement:TurnWith(parent) {
	on parent.Movement:Turned step {
		body.ApplyTurningStep(step)
	}
}
[[physics/velocity.easel]]
pub fn body.Velocity:TicksTo(target, speed) {
	return TicksPerSecond * Distance(target, body.Pos) / speed
}

pub fn body.Velocity:RedirectTowards(prey, speed=null, .. speedFactor=1) {
	if !Exists(body) { return }

	let prey = FindPrey(prey)
	if !prey { return }

	body.Velocity = Direction(prey - body.Pos) * (speedFactor * (speed ?? Length(body.Velocity)))
}
[[players/antiTeamingBonus.easel]]
const DamageModifierBonusPerTeamer = 0.3
const CooldownRateBonusPerTeamer = 0.3

pub fn this.AntiTeamingBonus(unit) {
    hook NumAttackers {
        if NumAttackers > 1 {
            const numTeamers = NumAttackers - 1
            DamageModifier(DamageModifierBonusPerTeamer * numTeamers)
            UnitCooldownRate(CooldownRateBonusPerTeamer * numTeamers)

        } else {
            delete DamageModifier
            delete UnitCooldownRate
        }
    }
}
[[players/bot.easel]]
.. thinkInterval=0.25s, timeJitter=3, wakeInterval=1s, spinPerTick=-0.05rev

symbol SpinAction

field unit.PreviousTarget
field unit.CurrentlyChannelling

field unit.HasAction
field unit.ActionUtility
field unit.ActionAbility
field unit.ActionDelay
field unit.ActionTarget
field unit.ActionSpin
field unit.ActionKeepChannelling

pub signal unit.BotChannelling(.. target, enemy, channelling)
pub signal unit.BotDeflecting(.. target, enemy)
pub signal unit.BotAttacking(.. target, enemy)
pub signal unit.BotRecovering(.. target, enemy)

pub fn owner.BotChooseSpells() {
	// Bots get random spells
	owner.RandomizeAllSlots

	// Uncomment the lines below if you want to choose specific spells for the bot
	// owner.DashSlot = WantSwap
	// owner.PrimarySlot = WantFireball
	// owner.SpecialSlot = WantHoming
	// owner.DefenseSlot = WantMeteor
	// owner.UltimateSlot = WantSpiritBomb
	// owner.MeleeSlot = WantEnergyMines
}

pub behavior fn unit.Bot(owner) {
	loop {
		const start = Tick
		const sleepAction = await BotThink

		const end = start + thinkInterval + Random() * timeJitter
		if sleepAction == SpinAction {
			while Tick < end {
				unit.Movement:Look(unit.Heading + spinPerTick)
				await TickStart
			}
		} else {
			await SleepUntilTickStart(end - Tick)
		}
	}
}
pub delete fn unit.Bot(owner) { }

fn unit.BotResetAction {
	unit.HasAction = false
	unit.ActionUtility = Utility:None
	unit.ActionAbility = null
	unit.ActionDelay = 0
	unit.ActionTarget = null
	unit.ActionSpin = false
	unit.ActionKeepChannelling = false
}

pub fn unit.BotUseAbility(target .. ability, utility=Utility:Medium, delay=0.25s, spin=false) {
	if utility > unit.ActionUtility {
		unit.HasAction = true
		unit.ActionUtility = utility
		unit.ActionAbility = ability
		unit.ActionDelay = delay
		unit.ActionTarget = target
		unit.ActionSpin = spin
		unit.ActionKeepChannelling = false
	}
}
pub fn unit.BotKeepChannelling(target .. ability, utility=Utility:High, delay=0.15s, spin=false) {
	if ability == unit.CurrentlyChannelling && utility > unit.ActionUtility {
		unit.HasAction = true
		unit.ActionUtility = utility
		unit.ActionAbility = null
		unit.ActionDelay = delay
		unit.ActionTarget = target
		unit.ActionSpin = spin
		unit.ActionKeepChannelling = true
	}
}
pub fn unit.BotMoveTo(target .. utility=Utility:Low, delay=0.15s) {
	if utility > unit.ActionUtility {
		unit.HasAction = true
		unit.ActionUtility = utility
		unit.ActionAbility = null
		unit.ActionDelay = delay
		unit.ActionTarget = target
		unit.ActionSpin = false
		unit.ActionKeepChannelling = true
	}
}
pub fn unit.BotSpin(.. utility=Utility:Minimum, delay=0s) {
	if utility > unit.ActionUtility {
		unit.HasAction = true
		unit.ActionUtility = utility
		unit.ActionAbility = null
		unit.ActionDelay = delay
		unit.ActionTarget = null
		unit.ActionSpin = true
		unit.ActionKeepChannelling = false
	}
}

await fn BotThink(.. unit, owner) {
	.. this = unit

	.. enemy = QueryUnits.WhereAlliance(unit,Alliance:Enemy).FindNearest(unit.Pos)
	if !enemy {
		if HasConcluded {
			// Has won the game - spin to celebrate!
			return SpinAction
		} else {
			return null
		}
	}

	.. target = enemy.Vanished ? unit.PreviousTarget : enemy?.Pos
	if !target { return }
	unit.PreviousTarget = target

	BotResetAction
	BotConsiderRecovery
	BotConsiderChannelling
	BotConsiderDodge
	BotConsiderAttack
	BotConsiderMove

	if unit.ActionDelay > 0 {
		await SleepUntilTickStart(unit.ActionDelay)
	}

	// Pointers are processed early in the tick (before physics) - ensure the bot is doing the same so all timings are correct
	if unit.ActionTarget && !unit.ActionSpin {
		owner.Pointer = unit.ActionTarget
		owner.IsPointerActive = true
	} else {
		owner.IsPointerActive = false
	}

	// User-invoked incantations occur during the main part of the tick - ensure the bot is doing the same so all timings are correct
	await Tick
	if unit.CurrentlyChannelling && !unit.ActionKeepChannelling {
		// Release if no command to keep channelling
		unit.CurrentlyChannelling.ReleaseCommand
		unit.CurrentlyChannelling = null
	}
	if unit.ActionAbility {
		unit.ActionAbility.InvokeCommand
		unit.CurrentlyChannelling = unit.ActionAbility

	}

	if unit.ActionSpin {
		return SpinAction
	}
}

fn BotConsiderMove(unit, target, enemy) {
	if unit.HasAction { return }

	// Walk away, but around the edge, not through the middle
	let selfAngle = Angle(unit.Pos) // Get angle from center of map
	let awayAngle = Angle(-target)
	let newAngle = selfAngle + 0.1 * AngleDelta(selfAngle, awayAngle)
	let radius = Length(target) // Match our enemy's radius

	BotMoveTo(target=radius * Direction(newAngle), utility=Utility:Minimum)
}

fn BotConsiderChannelling(unit, target, enemy) {
	if unit.HasAction { return }

	const channelling = unit.CurrentlyChannelling
	if !channelling { return }
	unit.BotChannelling(.. target enemy channelling)
}

fn BotFindIncoming(unit, tooFarRadius=2.0) {
	let projectile = QueryColliders.WhereCategory(Category:Projectile).WhereAlliance(unit,Alliance:Enemy).FindNearest(unit.Pos)
	if !projectile { return null }

	let incoming = projectile.Pos

	let diff = unit.Pos - incoming
	let incomingSpeed = Dot(projectile.Velocity, Direction(diff))
	if incomingSpeed <= 0 { return null } // Not coming towards us

	let timeToCollision = Length(diff) / incomingSpeed
	if timeToCollision <= 0 || timeToCollision > 0.5s { return null } // Not coming towards us or too far away

	let collisionPoint = projectile.Pos + projectile.Velocity * timeToCollision
	let distanceToCollision = Length(unit.Pos - collisionPoint)

	// Need to know the radius of the unit and projectile to do this accurately
	if distanceToCollision > tooFarRadius { return null } // Too far away

	return [incoming,collisionPoint]
}

fn BotConsiderDodge(unit, target, enemy, escapeRadius=10) {
	if unit.HasAction { return }

	let [incoming, predictedCollisionPoint] = BotFindIncoming
	if !incoming { return null }

	if HasCommenced {
		// Attempt to use a spell to deflect the incoming collision
		unit.BotDeflecting(.. target enemy)
		if unit.HasAction { return }
	}

	// If no action assigned yet, attempt to dodge the incoming collision
	let dodge = unit.Pos + escapeRadius * Direction(unit.Pos - predictedCollisionPoint)
	BotMoveTo(target=dodge, utility=Utility:Maximum)
}

fn BotConsiderAttack(unit, target, enemy) {
	if unit.HasAction || !HasCommenced { return }
	unit.BotAttacking(.. target enemy)
}

fn BotConsiderRecovery(unit, target, enemy) {
	if unit.HasAction || !HasCommenced | !unit.IsInLava { return }

	// Find a safe place
	let turf = QueryColliders.WhereCategory(Category:Turf).FindNearest(unit.Pos)
	let safePoint = turf?.Pos ?? @(0,0)

	// Recover to somewhere between our target and the center of the map. This stops everyone going to the absolute center all the time which sometimes has dangerous obstacles
	.. target = (target + safePoint) / 2.0

	// Attempt to use a spell to recover
	BotRecovering(.. target enemy)
	if unit.HasAction { return }

	// If no spell available, run back to the middle as quickly as possible
	BotMoveTo(target=, utility=Utility:Maximum)
}
[[players/commenceCountdown.easel]]
pub signal World.RecheckCommenceCountdown()
pub symbol WaitForMorePlayers

pub behavior fn this.CommenceCountdown(waitForMoreDelay, commenceDelay=3s) .. {
	if IsReadyToBegin { return }

	loop {
		await RecheckCommenceCountdown

		let readyToBegin = delve()
		if !readyToBegin { continue }

		if readyToBegin == WaitForMorePlayers {
			let cancelled = false
			let end = Tick + waitForMoreDelay
			loop {
				let remaining = Max(0, end - Tick)
				CountdownDialog(remaining) // Update the countdown
				if remaining <= 0 { break }

				// Update the status every 1 second, or immediately after a player leaves
				await Sleep(1s), AfterPlayerLeave
				let readyToBegin = delve()
				if !readyToBegin {
					cancelled = true
					break
				} else if readyToBegin == WaitForMorePlayers {
					// Already waiting for more players, do nothing
				} else {
					// Ready to begin immediately
					break
				}
			}

			// Remove the countdown dialog
			delete CountdownDialog

			if cancelled { continue }
		}

		break
	}

	ReadyToBegin(commenceDelay)
}

fn this.CountdownDialog(remaining) {
	if remaining > 0 {
		Transmission<countdown>(duration=remaining) {
			P(scale=0.9) {
				%("Waiting ")
				Span(bold=true) {
					%(Ceil(remaining / TicksPerSecond))
					%(" seconds")
				}
				%(" for more players to join...")
			}
		}
	} else {
		delete Transmission<countdown>
	}
}
delete fn this.CountdownDialog() {
	delete Transmission<countdown>
}
[[players/discordAd.easel]]
pub fn this.DiscordAd {
	Section<discordAd>(owner=null) {
		P(scale=0.8) {
			%("Like this game? ")
			Link(onPress="https://discord.gg/sZvgpZk") {
				%("Join our community on Discord! ")
				Icon("fab fa-discord")
			}
		}
	}
}
pub delete fn this.DiscordAd {
	delete Section<discordAd>
}
[[players/eliminatedDialog.easel]]
pub fn owner.EliminatedDialog() .. ui {
	if !Victory {
		Subspawn {
			Section {
				Panel { delve() }
			}

			await Victory
			Despawn
		}
	}
}
[[players/ghost.easel]]
pub field unit.IsGhost

/// The purpose of the Ghost is to allow a player to continue to edit their abilities after they are dead.
pub fn unit.Ghost(owner, parent) {
	this.Category = Category:Ghost
	this.Owner = owner

    // Add a body just to avoid any potential crashes if someone looks for it
	Body(parent.Pos, heading=parent.Heading, immovable=true)
}
[[players/hero.easel]]
pub signal unit.HeroExit

pub fn unit.Hero(owner, pos=@(0,0), radius=1.0, density=1) {
	.. color=#aaa, ownerColor=true
	.. depth=Depth:Unit, durability=Durability:Maximum
	.. categories=(Category:Hero | Category:CanGrab | Category:HurtByLava | Category:Aoe)
	.. collideWith=Category:Solid, sense=Category:Zone, ccd=true

	.. entrance = pos + 40.0 * Direction(pos), heading = Angle(pos - entrance)
	.. exitSpeed = 5.0

	Unit

	// Body
	Body(entrance, heading=)
	PrepareForCollision
	DecayingMotion

	// Health
	Health(100)
	on Hurt {
		Strobe(dissipation=10, shine=0.5, growth=0.5)
	}
	once BeforeOutOfHealth {
		Puff(count=10, luminous=1.0, shine=1.0, bloom=2.0, dissipation=30, splatter=Splatter:Outwards(10.0))
		Hear(Hero:Explode)
		Hear(Hero:Death)
	}

	// Movement
	Movement:Walk(speed=9.6)
	Movement:Turn
	hook Pointer {
		Movement:LookAt(Pointer)
	}
	on Movement:Turned step {
		if Abs(step) > 0.125rev {
			Strobe<turning>(dissipation=15, growth=0.15)
		}
	}

	// Entrance animation
	Subscope {
		.. dissipation=30, luminous=1, shine=0

		Tangibility
		Vulnerability(-1)
		SpeedModifier(-1)
		RayEmitter(radius * 1.5, glare=0.5, bloom=3, bloomAlpha=1, shadow=0.5)

		await Tween(duration=dissipation, initial=0.0, final=1.0) blend {
			unit.Pos = (blend ** 2.0).Mix(unit.Pos, pos)
		}
	}
	
	// Exit animation
	once HeroExit {
		Unkillable // Stop the unit dying during their exit animation
		once BeforeOutOfHealth { } // Remove BeforeOutOfHealth handler to stop the death sound from playing after the animation is complete

		Subscope {
			.. dissipation=30, luminous=1, shine=0

			RayEmitter(radius * 1.5, glare=0.5, bloom=3, bloomAlpha=1, shadow=0.5)

			await Tween(duration=dissipation, initial=1.0, final=0.0) blend {
				unit.Pos += blend * exitSpeed * Direction(unit.Pos) // Just move away from center each tick
			}

			unit.Expire
		}
	}

	// Cleanse on game start
	once AfterCommence {
		CleanseBuffs
		SeverTethers
	}

	hook<categories> FilterCategoriesModifier, AlsoCategoriesModifier {
		unit.Category = categories & FilterCategoriesModifier | AlsoCategoriesModifier
	}

	hook<render> SizeModifier, Vanished {
		await TickEnd // Don't change anything until the tick is finished and we are abougt to render so we can collate multiple changes together
		.. radius = radius * SizeModifier

		if Vanished {
			delete Sprite<glyph>
			delete Sprite<hero>
			delete Nametag
			delete Healthbar

		} else {
			Sprite<hero>(shadow=0.5, shading=0.4) {
				Perimeter {
					Shape:Circle(radius=)
				}
			}
			
			Sprite<glyph>(depth=depth - 1, ownerColor=false, color=#fff8, luminous=1) {
				Glyph(radius=, glyph=Hero:Arrowhead)
			}
			
			Healthbar(unit, height=0.2*radius, width=2*radius, verticalOffset = -1.5 * radius)
			Nametag(offset=1.5, anchorTop=true, ownerColor=false, luminous=1)
		}
	}

	hook<physics> SizeModifier, Tangibility, SenseAlso, DensityModifier {
		await PhysicsStart // Don't change anything until the physics is about to happen so we can collate multiple changes together
		.. radius = radius * SizeModifier
		.. density = density * DensityModifier
		.. collideWith = collideWith & Tangibility
		.. sense = sense | SenseAlso

		if collideWith || sense {
			Collider(.. collideWith sense density) {
				Shape:Circle(radius=)
			}

		} else {
			// If we collide with nothing, become intangible - completely remove the collider.
			// This ensures we also won't be found even by area-of-effect queries, for example.
			delete Collider
		}
	}
}

sound Hero:Death(duration=0.3s) {
	Vibrato(freqModulation=140) {
		WhiteNoise
	}
	Oscillator(wave=$sine, freq=35, harmonics=[1,1.5,2,4,16])
	LowPass(freq=[560,0], q=1)
	Tremolo(volumeModulation=1.0) {
		Oscillator(freq=[17.5,0])
	}
	Envelope(attack=0.01s, decay=0.05s, sustainVolume=0.4, sustain=0s)
}

sound Hero:Explode(duration=1.0s) {
	Vibrato(freqModulation=280) {
		WhiteNoise
	}
	Oscillator(wave=$triangle, freq=35)
	LowPass(freq=[140,0], q=1)
	Envelope(attack=0.01s, decay=0.05s, sustainVolume=0.2, sustain=0s)
}

glyph Hero:Arrowhead(path="M 256,0 C 190.36953,0 130.5363,24.714581 85.232422,65.3125 L 256,256 84.410156,445.97461 C 129.80926,487.00513 189.9782,512 256,512 L 384,256 Z")
[[players/introducer.easel]]
pub fn this.Introducer {
	Subspawn {
		hook NumPlayers {
			Transmission<introducer>(duration=15s) {
				P {
					let isFirst = true
					for player in QueryPlayers.FindAll {
						if isFirst {
							isFirst = false
						} else {
							%(", ")
						}
						NameBlock(player)
					}
					%(" joined")
				}
			}
		}

		once AfterCommence {
			// Expire once the game starts so we don't keep re-notifying when players leave during/after the game
			Expire
		}
	}
}
[[players/outlast.easel]]
field team.TeamEliminatedTick

pub fn Outlast:IsGameComplete {
	if !HasCommenced { return false }

	let firstTeam = null
	for player in QueryPlayers.FindAll {
		if player.IsEliminated { continue } // Ignore defeated players

		// Consider only the undefeated players
		if firstTeam {
			if player.Team != firstTeam {
				// At least two teams remain - game not complete
				return false
			}
		} else {
			firstTeam = player.Team
		}
	}

	// At most one team exists - game complete
	return true
}

pub fn Outlast:CalculateRanking {
	let undefeated = Tick + 1 // If undefeated, use a future tick as a sentinel value
	for player in QueryPlayers.FindAll {
		let eliminatedTick = player.EliminatedTick ?? undefeated 
		let team = player.Team
		team.TeamEliminatedTick = Max(team.TeamEliminatedTick ?? 0, eliminatedTick)
	}

	let rankings = QueryPlayers.FindAll.OrderByDesc(
		player => [player.Team.TeamEliminatedTick ?? undefeated, player.EliminatedTick ?? undefeated]
	)

	return rankings
}
[[players/playVsAiDialog.easel]]
pub fn this.PlayVsAiDialog() .. {
	Subspawn {
		hook NumPlayers {
			Section {
				if NumPlayers < 2 {
					Panel {
						H1 {%("Waiting for players...")}
						Button(tier=$primary, onPress=$playVsAi) { %("Play vs AI") }
					}
				}
			}
		}

		once BeforeCommence {
			Despawn
		}

		once ButtonPress($playVsAi) {
			delve()
		}
	}
}
[[players/teams.easel]]
pub fn Teams:Individual {
	for player in (QueryPlayers.FindAll) {
		// Reuse the same entity as both the player and the team
		MakeTeam(player)
		player.Team = player
	}
}
[[players/tombstone.easel]]
pub behavior fn unit.Tombstone() [victim .. ui] {
	if !(unit.Category & Category:Hero) { return }
	await unit.BeforeOutOfHealth

	.. victim = unit.Owner
	Transmission<tombstone> {
		P { delve() }
	}
}
pub delete fn unit.Tombstone() { }
[[players/victory.easel]]
pub prop World.Victory
[[players/victoryDialog.easel]]
pub fn this.VictoryDialog(ranking) {
	if !ranking { return }

	Subspawn {
		let winningTeam = ranking[0]?.Team
		let winners = []
		for player in ranking {
			if player.Team == winningTeam {
				winners.Append(player)
			}
		}

		Section {
			Panel {
				H1 {
					let len = Length(winners)
					let last = len - 1
					for i in Range(0, len) {
						if i > 0 {
							%(i == last ? " & " : ", ")
						}
						NameBlock(winners[i])
					}
					%(len == 1 ? " wins!" : " win!")
				}
				Button(tier=$primary, onPress=Mode) { %("Play Again") }
			}
		}
	}
}
[[profile.easel]]
pub page fn owner.ProfilePage(userId) {
	// Display a loading screen while fetching the data
	Section<profile> {
		P { %("Loading profile...") }
	}
	Section<history> { }

	once FetchProfile(userId) player {
		Section<profile> {
			let rating = player.Rating
			let league = FindLeague(rating)

			H1 { %(player.PlayerName) }

			Sash(backgroundColor=league.color, align=$center, scale=4) {
				Medal(glyph=league.glyph, backgroundColor=league.color, scale=1.2)

				Span {
					Span(bold=true) {
						%(league.name)
					}
					%(" ")
					%(FormatToFixed(rating, 0))
				}
			}

			Row {
				DigitCard(heading="Games Played") { %(player.NumGames) }
				DigitCard(heading="Outlasts") { %(player.NumOutlasts) }
				DigitCard(heading="Wins") { %(player.NumWins) }
			}
		}
	}

	once FetchUserEpisodeHistory(userId) episodes {
		Section<history> {
			H1 { %("Recent Games") }

			if episodes.Length == 0 {
				P { %("No recent games") }
				return
			}

			for episode in episodes {
				Sash(backgroundColor=#777) {
					P {
						let isFirst = true
						for player in episode.EpisodeRanking {
							if isFirst { isFirst = false }
							else { %(", ") }

							Link(onPress=player.UserId) { %(player.PlayerName) }
						}
					}

					Right {
						Link(onPress=episode.EpisodeId) {
							Icon("fa-solid fa-video")
							%(" Replay")
						}
					}
				}
			}
		}
	}
}
[[renders/bloom.easel]]
pub fn this.Bloom<Id?>(
	body,
	..
	audience?,
	bloom=4.0, bloomAlpha=0.5,
	color, ownerColor?, owner?,
	depth=Depth:Bloom,
	luminous=1) {

	Sprite<Id+bloom>(body) {
		Circle(radius=0.0)
	}
}

pub fn this.BloomIndicator<Id?>(
	body,
	..
	audience?,
	bloom=4.0, bloomAlpha=0.5,
	color, ownerColor?, owner?,
	depth=Depth:Bloom,
	luminous=1) {

	hook body.Vanished {
		if body.Vanished {
			delete Sprite<Id+indicator>

		} else {
			Sprite<Id+indicator>(body) {
				Circle(radius=0.0)
			}
		}
	}
}
[[renders/explosion.easel]]
pub fn this.Explosion(
	radius, body,
	..
	color, depth, dissipation,

	audience?,
	bloom=3.0, bloomAlpha=0.5,
	crater=0,
	diminish=1,
	feather=1.0,
	glare=0.3, glareAlpha=1.0,
	luminous=1.0,
	ownerColor?,
	owner?,
	shading=0.0,
	shine=0.2,
	taper=1) {

	Particle(body, strobe=false)
}
[[renders/flutter.easel]]
pub fn Flutter:Shorthand(flutter) {
	if flutter == $perimeter { return Flutter:Perimeter() }
	else if flutter == $area { return Flutter:Area() }
	else { return flutter }
}

pub fn Flutter:Swirl(radius, period=15, angleOffset=0rev) {
	return (body,phase) => {
		let angle = (1rev * (Tick % period) / period) + angleOffset + (1rev * phase)
		let offset = radius * Direction(angle)
		return Rotate(offset, body.Heading)
	}
}

pub fn Flutter:Helix(radius, period=15, angleOffset=0rev) {
	return (body,phase) => {
		let angle = (1rev * (Tick % period) / period) + angleOffset + (1rev * phase)
		let shift = radius * Sin(angle)
		let offset = @(0,shift)
		return Rotate(offset, body.Heading)
	}
}

pub fn Flutter:Perimeter(radiusFraction=1) {
	return (body,phase) => {
		let offset = body.TracePerimeter(perimeterFraction=Random, radiusFraction=)
		return Rotate(offset, body.Heading)
	}
}

pub fn Flutter:Area {
	return (body,phase) => {
		let offset = body.TracePerimeter(perimeterFraction=Random, radiusFraction=Random)
		return Rotate(offset, body.Heading)
	}
}
[[renders/hide.easel]]
pub fn Hide:Shorthand(hide) {
	if hide == $whenInvisible { return Hide:WhenInvisible() }
	else { return hide }
}

pub fn Hide:WhenInvisible {
	return (body) => {
		return body.Vanished
	}
}
[[renders/nametag.easel]]
symbol NametagSprite

pub fn this.Nametag(
	body,
	..
	shape?,
	owner,
	depth=Depth:Label,
	color=#fff4, ownerColor?, luminous?=1,
	pixelWidth=200, pixelHeight=22, offset,
	anchorTop=false, anchorBottom=false,

	audience?,
	bloom?, bloomAlpha?,
	crater?, feather?,
	strobe=false,
	flicker?,
	glare?, glareAlpha?,
	noRotation?,
	shading?, shadow?, shine?) {

	Sprite<NametagSprite>(body, noRotation=true, .. luminous) {
		Label(text=owner?.PlayerName, posOffset=@(0.0, offset), ..  pixelWidth pixelHeight anchorTop anchorBottom)
	}
}

pub delete fn this.Nametag {
	delete Sprite<NametagSprite>
}
[[renders/puff.easel]]
pub fn this.Puff(
	body,
	..
	count=1,
	flutter?, splatter?,
	color, depth?=Depth:Particle, dissipation?=15, radius,
	audience?,
	fade?,
	bloom?=0, bloomAlpha?=0.3,
	crater?,
	diminish?,
	feather?=1.0,
	flicker?,
	glare?, glareAlpha?,
	luminous?=1.0,
	ownerColor?, owner?,
	shading?, shadow?,
	shine?=0.5,
	strobe?,
	taper?) {

	let pos = body?.Pos
	if !pos { return }

	let flutter = Flutter:Shorthand(flutter)
	let splatter = Splatter:Shorthand(splatter)

	for i in Range(0, count) {
		let pos = pos
		if flutter {
			pos += IsFunc(flutter) ? flutter(body, i / count) : flutter
		}
		let velocity = IsFunc(splatter) ? splatter(body) : splatter
		Particle(pos, velocity=)
	}
}
[[renders/ray.easel]]
pub behavior fn this.RayEmitter<Id?>(
	radius, body,
	..
	color, depth, dissipation,

	flutter?,

	audience?,
	fade?,
	bloom?=3, bloomAlpha?=1,
	crater?,
	diminish?,
	feather?,
	flicker?,
	glare?=1, glareAlpha?,
	luminous?=1.0,
	owner?, ownerColor?,
	phase=0,
	shading?,
	shadow?=0.25,
	shine?,
	strobe?,
	taper?) {

	let flutter = Flutter:Shorthand(flutter)
	loop {
		let pos = body.Pos
		if flutter {
			pos += IsFunc(flutter) ? flutter(body, phase) : flutter
		}
		Ray<Id>(pos)
		await TickEnd
	}
}
[[renders/shape.easel]]
const DistancePerDivision=1
const MinDivisions=4

pub fn Shape:Circle(shape, radius, posOffset?) {
	Circle(.. shape)
}

pub fn Shape:Sector(shape, arc, angleOffset, radius, posOffset?) {
	Sector(.. shape angleOffset arc)
}

pub fn Shape:Equilateral(shape, numPoints, radius, angleOffset=0, posOffset?) {
	Equilateral(.. shape radius)
}

pub fn Shape:Capsule(shape, extent, radius, angleOffset=0, posOffset?) {
	Capsule(.. shape extent radius angleOffset)
}

pub fn Shape:Arc(shape, orbit, arc, radius, numDivisions=Max(MinDivisions,Ceil(orbit * arc / DistancePerDivision)), cap=false) {
	let arcExtent = arc / 2.0
	let origin = @(-orbit,0)
	let points = []
	for i in Range(0,numDivisions+1) {
		let angle = -arcExtent + i * arc / numDivisions
		points.Append(origin + Direction(angle) * orbit)
	}

	Line(
		headTilt=-arcExtent / numDivisions,
		tailTilt=arcExtent / numDivisions,
		.. shape radius points cap)
}

pub fn Shape:Trapezoid(shape, arc, radius, orbit, cap=false) {
	let origin = @(-orbit,0)
	let adjacentAngle = Min(arc / 2.0, 1rev / 3.0)
	let hypotenuseMultipler = 1.0 / Cos(adjacentAngle)

	let points = [
		origin + Direction(-adjacentAngle) * (hypotenuseMultipler * orbit),
		origin + Direction(adjacentAngle) * (hypotenuseMultipler * orbit),
	]

	Line(
		headTilt=-adjacentAngle,
		tailTilt=adjacentAngle,
		.. shape points radius cap)
}
[[renders/smoke.easel]]
pub behavior fn this.Smoke<Id?>(
	body, radius,
	..
	count=1, interval=1,
	flutter?, splatter?,

	color, dissipation?=15, depth?=Depth:Particle,

	audience?,
	fade?,
	bloom?=0, bloomAlpha?,
	crater?,
	diminish?,
	feather?,
	flicker?,
	glare?, glareAlpha?,
	luminous?,
	owner?,
	ownerColor?,
	shading?, shadow?,
	shine?,
	strobe?,
	taper?) {

	let flutter = Flutter:Shorthand(flutter)
	let splatter = Splatter:Shorthand(splatter)

	loop {
		if !body.Exists { break }

		if body.Invisibility {
			// go to sleep until we are visible again
			await body.Invisibility

		} else {
			Puff(.. body count flutter splatter)
		}

		await SleepUntilTickEnd(interval.Max(1))
	}
}

pub delete fn this.Smoke<Id?> { }
[[renders/splatter.easel]]
pub fn Splatter:Shorthand(splatter) {
	if splatter > 0 { return Splatter:Glide(splatter) }
	else { return splatter }
}

pub fn Splatter:Outwards(explodeSpeed, glide=1) {
	return (body) => {
		let direction = RandomV2()
		let speed = explodeSpeed * Random()
		if glide > 0.0 {
			speed += glide * Random() * Dot(body.Velocity, direction)
		}
		return direction * speed
	}
}

pub fn Splatter:Glide(glide=1) {
	return (body) => {
		let direction = RandomV2()
		let speed = glide * Random() * Dot(body.Velocity, direction)
		return direction * speed
	}
}

pub fn Splatter:Conveyor(convey) {
	return (body) => {
		return Rotate(convey, body.Heading)
	}
}
[[renders/swoop.easel]]
pub behavior fn this.SwoopEmitter<Id?>(
	body, radius,
	..
	color, depth, dissipation,

	audience?,
	fade?,
	angleOffset?=0,
	bloom?=3.0, bloomAlpha?=0.3,
	crater?,
	diminish?,
	feather?,
	strobe?,
	flicker?,
	glare?, glareAlpha?,
	luminous?=1.0,
	owner?, ownerColor?,
	shading?, shadow?=0,
	shine?,

	// Looks weird if the swooping radius tapers to zero, so default to this off
	taper=0) {

	loop {
		let heading = body.Heading
		if !IsNum(heading) { break } // Seems our mark has died

		Swoop<Id>(angle = heading + angleOffset, .. body)
		await TickEnd
	}
}
[[renders/tether.easel]]
symbol TetherRay

pub behavior fn this.Tether<Id?>(
	body, ancestor,
	..
	color, depth, radius,

	segments=5, // the tether recreates this many points each tick, so don't make this too large

	audience?,
	fade?,
	bloom?=2, bloomAlpha?=1,
	crater?,
	diminish?,
	feather?,
	flicker?,
	glare?=1, glareAlpha?,
	luminous?=1.0,
	owner?, ownerColor?,
	shading?, shadow?=0.25,
	shine?,
	strobe?,
	taper?=0) {

	.. dissipation=segments

	loop {
		await TickEnd
		if radius == 0 { break }

		let from = ancestor?.Pos
		let to = body?.Pos
		if !(from && to) { break }

		let points = []
		for index in RangeInclusive(0, segments) {
			let pos = (index / segments).Mix(from, to)
			points.ArrayPush(pos)
		}
		Ray<TetherRay+Id>(points)
	}
}

pub delete fn this.Tether<Id?>() {
	delete Ray<TetherRay+Id>
}
[[settings.easel]]
pub page fn owner.SettingsPage {
	Section {
        H1 { %("Settings") }
        Panel {
            FormBlock("Name") { NameEditor }
        }

        H1 { %("Visuals") }
        Panel {
            FormBlock("Resolution") {
                ResolutionEditor
                Caption { %("Higher for better quality, lower for better performance") }
            }
        }

        H1 { %("Audio") }
        Panel {
            FormBlock("Volume") { VolumeEditor }
        }

        H1 { %("Controls") }
        Panel {
            FormBlock("Movement") {
                WalkSlotEditor
                Caption { %("Choose whether to continuously move towards your cursor, or only when you click/tap") }
            }
            FormBlock("Left-click/Tap") {
                LeftClickEditor
            }
            FormBlock("Right-click/Double Tap") {
                RightClickEditor
            }
        }
	}
}
[[slots.easel]]
pub fn unit.SlotAbilities(owner) {
    WalkSlotAbility
    DashSlotAbility(btnIndex=0, btnSize=0.75)
    PrimarySlotAbility(btnIndex=1, btnSize=1)
    DefenseSlotAbility(btnIndex=3, btnSize=0.9)
    SpecialSlotAbility(btnIndex=2, btnSize=0.9)
    UltimateSlotAbility(btnIndex=4, btnSize=0.9)
    MeleeSlotAbility(btnIndex=5, btnSize=0.75)

    LeftClickBinding
    RightClickBinding
}

pub fn owner.RandomizeAllSlots {
	RandomizePrimarySlot
	RandomizeDefenseSlot
	RandomizeSpecialSlot
	RandomizeUltimateSlot
	RandomizeMeleeSlot
	RandomizeDashSlot
}

pub fn this.SlotEditors(.. ui, owner) {
	PrimarySlotEditor
	SpecialSlotEditor
	DefenseSlotEditor
	UltimateSlotEditor
	MeleeSlotEditor
	DashSlotEditor
}
[[slots/clicks.easel]]
pub preference owner.LeftClickSlot
pub preference owner.RightClickSlot

pub symbol WantClickMove
pub symbol WantClickQ
pub symbol WantClickA

const LeftClickDefault=WantClickQ
const RightClickDefault=WantClickA

pub fn unit.LeftClickBinding(owner) {
	SlotAbility<LeftClickSlot>(slotDefault=LeftClickDefault) choice {
        const binding = ChoiceToBinding(choice)
        AlternateBinding("Click", binding)
        AlternateBinding("Tap", binding)
	}
}
pub fn unit.RightClickBinding(owner) {
    SlotAbility<RightClickSlot>(slotDefault=RightClickDefault) choice {
        const binding = ChoiceToBinding(choice)
        AlternateBinding("SecondaryClick", binding)
        AlternateBinding("DoubleTap", binding)
	}
}

fn ChoiceToBinding(choice) {
    if choice == WantClickMove { return "Click" }
    else if choice == WantClickQ { return "KeyQ" }
    else if choice == WantClickA { return "KeyA" }
    else { return null }
}

pub fn this.LeftClickEditor(.. owner, ui) {
	SlotDropdown<LeftClickSlot>(slotDefault=LeftClickDefault) {
        ClickEditor
	}
}

pub fn this.RightClickEditor(.. owner, ui) {
	SlotDropdown<RightClickSlot>(slotDefault=RightClickDefault) {
        ClickEditor
	}
}

fn ClickEditor(.. ui) {
    DropdownOption<WantClickMove>("Move")
    DropdownOption<WantClickQ>("Primary Attack")
    DropdownOption<WantClickA>("Dash")
}
[[slots/dash.easel]]
.. btn="KeyA", slotDefault=WantCharge

pub preference owner.DashSlot

pub fn unit.DashSlotAbility(.. owner, btnIndex?, btnSize=1) {
	SlotAbility<DashSlot> choice {
		if choice == WantCharge { ChargeAbility }
		else if choice == WantTeleport { TeleportAbility }
		else if choice == WantVoidRush { VoidRushAbility }
		else if choice == WantSwap { SwapAbility }
		else if choice == WantVanish { VanishAbility }
		else { SlotWithoutAbility }

		SlotPopup<DashSlot> { DashSlotEditor }
	}
}

pub fn this.DashSlotEditor(.. owner, ui) {
	SlotEditor<DashSlot> {
		ChargeOption
		TeleportOption
		VoidRushOption
		SwapOption
		VanishOption
	}
}

pub fn owner.RandomizeDashSlot {
	DashSlot = PickRandom([
		WantCharge,
		WantTeleport,
		WantVoidRush,
		WantSwap,
		WantVanish,
	])
}
[[slots/defense.easel]]
.. btn="KeyE", slotDefault=WantReflect

pub preference owner.DefenseSlot

pub fn unit.DefenseSlotAbility(.. owner, btnIndex, btnSize=1) {
	SlotAbility<DefenseSlot> choice {
		if choice == WantReflect { ReflectAbility }
		else if choice == WantSpiritArmor { SpiritArmorAbility }
		else if choice == WantForcefield { ForcefieldAbility }
		else if choice == WantSaber { SaberAbility }
		else if choice == WantDualSaber { DualSaberAbility }
		else if choice == WantMeteor { MeteorAbility }
		else if choice == WantMeteorite { MeteoriteAbility }
		else if choice == WantHorcrux { HorcruxAbility }
		else if choice == WantPhaseShift { PhaseShiftAbility }
		else if choice == WantBlaze { BlazeAbility }
		else { SlotWithoutAbility }

		SlotPopup<DefenseSlot> { DefenseSlotEditor }
	}
}

pub fn this.DefenseSlotEditor(.. owner, ui) {
	SlotEditor<DefenseSlot> {
		ReflectOption
		ForcefieldOption
		SaberOption
		DualSaberOption
		MeteorOption
		MeteoriteOption
		HorcruxOption
		PhaseShiftOption
		BlazeOption
		SpiritArmorOption
	}
}

pub fn owner.RandomizeDefenseSlot {
	DefenseSlot = PickRandom([
		WantReflect,
		WantForcefield,
		WantSaber,
		WantDualSaber,
		WantMeteor,
		WantMeteorite,
		WantHorcrux,
		WantPhaseShift,
		WantBlaze,
		WantSpiritArmor,
	])
}
[[slots/melee.easel]]
.. btn="KeyF", slotDefault=WantOverload

pub preference owner.MeleeSlot

pub fn unit.MeleeSlotAbility(.. owner, btnIndex?, btnSize=1) {
	SlotAbility<MeleeSlot> choice {
		if choice == WantOverload { OverloadAbility }
		else if choice == WantFiresplatter { FiresplatterAbility }
		else if choice == WantFrostsplatter { FrostsplatterAbility }
		else if choice == WantEnergyMines { EnergyMinesAbility }
		else if choice == WantHalo { HaloAbility }
		else if choice == WantReverberate { ReverberateAbility }
		else { SlotWithoutAbility }

		SlotPopup<MeleeSlot> { MeleeSlotEditor }
	}
}

pub fn this.MeleeSlotEditor(.. owner, ui) {
	SlotEditor<MeleeSlot> {
		OverloadOption
		FiresplatterOption
		FrostsplatterOption
		EnergyMinesOption
		HaloOption
		ReverberateOption
	}
}

pub fn owner.RandomizeMeleeSlot {
	MeleeSlot = PickRandom([
		WantOverload,
		WantFiresplatter,
		WantFrostsplatter,
		WantEnergyMines,
		WantHalo,
		WantReverberate,
	])
}
[[slots/primary.easel]]
.. btn="KeyQ", slotDefault=WantFireball

pub preference owner.PrimarySlot

pub fn unit.PrimarySlotAbility(.. owner, btnIndex?, btnSize=1) {
	SlotAbility<PrimarySlot> choice {
		if choice == WantFireball { FireballAbility }
		else if choice == WantFireboom { FireboomAbility }
		else if choice == WantDifire { DifireAbility }
		else if choice == WantTrifire { TrifireAbility }
		else if choice == WantRefract { RefractAbility }
		else if choice == WantBoomerang { BoomerangAbility }
		else if choice == WantElectroshock { ElectroshockAbility }
		else { SlotWithoutAbility }

		SlotPopup<PrimarySlot> { PrimarySlotEditor }
	}
}

pub fn this.PrimarySlotEditor(.. owner, ui) {
	SlotEditor<PrimarySlot> {
		FireballOption
		FireboomOption
		DifireOption
		TrifireOption
		RefractOption
		BoomerangOption
		ElectroshockOption
	}
}

pub fn owner.RandomizePrimarySlot {
	PrimarySlot = PickRandom([
		WantFireball,
		WantFireboom,
		WantDifire,
		WantTrifire,
		WantRefract,
		WantBoomerang,
		WantElectroshock,
	])
}
[[slots/special.easel]]
.. btn="KeyW", slotDefault=WantHoming

pub preference owner.SpecialSlot

pub fn unit.SpecialSlotAbility(.. owner, btnIndex?, btnSize=1) {
	SlotAbility<SpecialSlot> choice {
		if choice == WantHoming { HomingAbility }
		else if choice == WantDrain { DrainAbility }
		else if choice == WantArcaneAgility { ArcaneAgilityAbility }
		else if choice == WantOrbiter { OrbiterAbility }
		else if choice == WantRepulsor { RepulsorAbility }
		else if choice == WantEnsnare { EnsnareAbility }
		else if choice == WantLink1 { LinkAbility }
		else if choice == WantGrapple { GrappleAbility }
		else if choice == WantWhirlwind { WhirlwindAbility }
		else { SlotWithoutAbility }

		SlotPopup<SpecialSlot> { SpecialSlotEditor }
	}
}

pub fn this.SpecialSlotEditor(.. owner, ui) {
	SlotEditor<SpecialSlot> {
		HomingOption
		OrbiterOption
		DrainOption
		RepulsorOption
		EnsnareOption
		LinkOption
		GrappleOption
		WhirlwindOption
		ArcaneAgilityOption
	}
}

pub fn owner.RandomizeSpecialSlot {
	SpecialSlot = PickRandom([
		WantHoming,
		WantOrbiter,
		WantDrain,
		WantRepulsor,
		WantEnsnare,
		WantLink1,
		WantGrapple,
		WantWhirlwind,
		WantArcaneAgility,
	])
}
[[slots/ultimate.easel]]
.. btn="KeyR", slotDefault=WantBeam

pub preference owner.UltimateSlot

pub fn unit.UltimateSlotAbility(.. owner, btnIndex?, btnSize=1) {
	SlotAbility<UltimateSlot> choice {
		if choice == WantBeam { BeamAbility }
		else if choice == WantApexAcolyte { ApexAcolyteAbility }
		else if choice == WantBlast { BlastAbility }
		else if choice == WantSupernova { SupernovaAbility }
		else if choice == WantSpiritBomb { SpiritBombAbility }
		else if choice == WantRepeater { RepeaterAbility }
		else if choice == WantBouncer { BouncerAbility }
		else { SlotWithoutAbility }

		SlotPopup<UltimateSlot> { UltimateSlotEditor }
	}
}

pub fn this.UltimateSlotEditor(.. owner, ui) {
	SlotEditor<UltimateSlot> {
		BeamOption
		BlastOption
		SupernovaOption
		SpiritBombOption
		RepeaterOption
		BouncerOption
		ApexAcolyteOption
	}
}

pub fn owner.RandomizeUltimateSlot {
	UltimateSlot = PickRandom([
		WantBeam,
		WantBlast,
		WantSupernova,
		WantSpiritBomb,
		WantRepeater,
		WantBouncer,
		WantApexAcolyte,
	])
}
[[slots/walk.easel]]
.. slotDefault=WantFollowCursor

pub preference owner.WalkSlot

pub fn unit.WalkSlotAbility(owner) {
	SlotAbility<WalkSlot> choice {
		if choice == WantFollowCursor { FollowCursorAbility }
		else if choice == WantClickToMove { ClickToMoveAbility }
	}
}

pub fn this.WalkSlotEditor(.. owner, ui) {
	SlotDropdown<WalkSlot> {
		DropdownOption<WantFollowCursor>("Follow Cursor")
		DropdownOption<WantClickToMove>("Click/Tap to Move")
	}
}
[[terrain/anchored.easel]]
pub behavior fn body.Anchored(pos, heading, speed=0.1, turnRate=0.05revs, proportion=0.02) {
	loop {
		await PhysicsStart

		let currentPos = body.Pos
		let posDiff = pos - currentPos
		if posDiff != @(0,0) {
			body.ApplyPositionStep(posDiff.Truncate(Max(speed / TicksPerSecond, proportion * Length(posDiff))))
		}

		let angleDiff = AngleDelta(body.Heading, heading)
		if angleDiff != 0.0 {
			body.Heading += angleDiff.Truncate(Max(turnRate / TicksPerSecond, proportion * Abs(angleDiff)))
		}
	}
}
pub delete fn body.Anchored { }
[[terrain/arrange.easel]]
pub fn ArrangeRing(numObstacles, orbit, .. pos?=@(0,0), headingOffset=0, angleOffset=0, pattern=null) .. pos heading {
	for index in Range(0, numObstacles) {
		if pattern && !pattern[index % Length(pattern)] {
			continue
		}
		let angle = angleOffset + index * 1rev / numObstacles
		let pos = pos + orbit * Direction(angle)
		delve(pos, heading = headingOffset + angle)
	}
}
[[terrain/contact.easel]]
field that.CurrentBuff<Id>
field that.NumContacts<Id> // The unit might be touching multiple zones of the same type at once, count so that we remove the buff only when all contacts are gone

pub fn body.BuffOnContact<Id>(.. filter=Category:Hero, reuse=true) that .. *buff {
    on body.BeforeCollide that {
        if that.Category & filter {
            that.NumContacts<Id> += 1

            if !reuse {
                that.CurrentBuff<Id>.Despawn // Always destroy and re-create the buff
            }

            // Create the buff
            if !Exists(that.CurrentBuff<Id>) {
                that.CurrentBuff<Id> = that.Subspawn buff {
                    delve()
                }
            }
        }
    }

    on body.AfterCollide that {
        if (that.Category & filter) && that.NumContacts<Id> > 0 {
            that.NumContacts<Id> -= 1
            if that.NumContacts<Id> <= 0 {
                that.CurrentBuff<Id>.Despawn // All contacts ended, destroy the buff
            }
        }
    }
}
[[terrain/lava.easel]]
pub prop body.IsInLava
pub field this.LavaLifestealer

pub behavior fn this.Lava(damageInterval=20, damagePerSecond=12.5, lifesteal=0.3) {
	let damage = (damagePerSecond / TicksPerSecond) * damageInterval
	loop {
		for that in QueryColliders.WhereCategory(Category:HurtByLava).FindAll {
			let isInLava = !QueryColliders.WhereCategory(Category:Turf).FindAnyAtPos(that.Pos)

			// Apply lava damage
			if isInLava {
				let damage = damage * that.LavaDamageModifier
				if damage > 0.0 {
					that.TakeDamage(damage)
					that.LavaLifestealer.Heal(damage * lifesteal)
					if that.Category & Category:Hero {
						that.Hurt
					}
				}
			}

			if that.IsInLava != isInLava {
				that.IsInLava = isInLava
			}
		}

		await Sleep(damageInterval)
	}
}
[[terrain/shrink.easel]]
// This is the maximum number of players each map is designed to hold
// Smaller than this and we will quickly shrink to the proportional area (not radius) for that number of players
const ShrinkMaxPlayers = 8
const ShrinkRatePerTick = 0.003 // This is the rate at which the turf will shrink to its target size
const ShrinkPower = 0.5 // Reshape the shrink curve according to this power - less than 1 means the shrinking is slower at start and faster at end, the opposite for greater than 1

field scene.ShrinkStartTick
pub prop scene.ShrinkScale

pub behavior fn scene.Shrink(shrinkDuration=90s) {
	ShrinkScale ??= 1.0

	if !HasCommenced {
		await AfterCommence
	}

	let startTick = ShrinkStartTick ??= Tick
	loop {
		await TickStart
		if HasConcluded { break } // Stop shrinking once game is complete

		const decayOverTime = 1.0 - ((Tick - startTick) / shrinkDuration).Max(0.0)
		const decayOverNumPlayers = ((QueryUnits.WhereCategory(Category:Hero).Count / ShrinkMaxPlayers) ** 0.5).Min(1.0) // 0.5 power to square root because we want to prorate area not radius
		const target = (decayOverTime * decayOverNumPlayers) ** ShrinkPower

		ShrinkScale = ShrinkRatePerTick.Mix(ShrinkScale, target)
	}
}
[[terrain/startingPositions.easel]]
field this.NextPlayerIndex

pub fn World.NextStartingPosition(radiusFraction=0.4, .. maxPlayers=MaxPlayers) {
	let turf = QueryColliders.WhereCategory(Category:Turf).FindAny
	if !turf { return @(0,0) }

	let index = this.NextPlayerIndex ?? 0
	let pos = turf.TracePerimeter(perimeterFraction=(index / maxPlayers) % 1.0, radiusFraction=)
	this.NextPlayerIndex = index + 1

	return pos
}
[[terrain/turf.easel]]
pub fn turf.Turf(
	pos=@(0,0),
	..
	heading=0,
	color, ownerColor=0.15) .. shape {

	.. owner=null
	.. shadow=0.5, bloom=0, bloomAlpha=0
	.. depth=Depth:Turf
	.. categories=Category:Turf, collideWith=Category:None
	.. isSensor=true, immovable=true

	Body(pos, heading=)
	PrepareForCollision

	Perimeter {
		Collider {
			Sprite {
				delve()
			}
		}
	}

	hook Victory {
		let winningTeam = Victory?.[0]?.Team
		SpriteProps(.. ownerColor shadow, owner=winningTeam)
		if winningTeam {
			Strobe(growth=0.05, shine=0.2, dissipation=10)
		}
	}
}
[[tricks/aoe.easel]]
pub fn body.Aoe:ForEach(aoe, .. filter=Category:Aoe) that {
	for that in QueryColliders.WhereCategory(filter).FindAllWithinRadius(body.Pos, aoe) {
		delve(that)
	}
}

pub fn this.Aoe:Indicator<Id?>(aoe, body, .. color, ownerColor?, owner?, luminous?=1.0) {
	Sprite<Id + aoeIndicator>(body, depth=Depth:Indicator, crater=0.85) {
		Circle(radius=aoe)
	}
}

pub fn body.Aoe:Impulse(that, impulse) {
	if that.Category & Category:Aoe {
		let outward = that.Pos - body.Pos
		that.ApplyImpulse(impulse * Direction(outward))
	}
}

pub fn body.Aoe:ImpulseAttenuated(that, impulse, aoe, attenuate=1.0) {
	if that.Category & Category:Aoe {
		let outward = that.Pos - body.Pos
		let impulse = impulse * (Length(outward) / aoe).Mix(1.0, attenuate)
		that.ApplyImpulse(impulse * Direction(outward))
	}
}

pub fn body.Aoe:Destroy(that, .. owner) {
	if that.Category & Category:Destructible && (Alliance(that, owner) & Alliance:NotFriendly) {
		that.Expire
	}
}
[[tricks/barrage.easel]]
pub await fn Barrage(count, interval) index {
	let start = Tick()
	for index in Range(0,count) {
		// Wait for the appropriate time to fire the next shot
		let next = start + interval * index
		let sleep = Floor(next - Tick)
		await Sleep(sleep)

		// Fire
		delve(index)
	}
}
[[tricks/charging.easel]]
pub prop incantation.ChargeProportion

pub await fn incantation.ChargeForDuration(chargeDuration) .. *charger {
	incantation.ChargeProportion = 0

	await Subscope charger {
		delve(charger)

		const start = Tick
		loop {
			const proportion = ((Tick - start) / chargeDuration).Min(1.0)
			incantation.ChargeProportion = proportion
			if proportion >= 1.0 { break }
			await Tick
		}
	}
}

pub await fn incantation.ChargeUntilReleased(chargeDuration, .. ability, minProportion=1.0) .. *charger {
	incantation.ChargeProportion = 0

	await Subscope charger {
		delve(charger)

		// Wait until the user releases the button and the charge is at least the minimum proportion
		once ability.ReleaseCommand {
			while incantation.ChargeProportion < minProportion {
				await incantation.ChargeProportion
			}
			StopCharging
		}

		const start = Tick
		loop {
			const proportion = ((Tick - start) / chargeDuration).Min(1.0)
			incantation.ChargeProportion = proportion
			if proportion >= 1.0 { break }
			await Tick
		}

		await charger.Expire
	}
}

pub fn charger.StopCharging {
	charger.Expire
}

pub fn this.ChargingIndicator(
	body,
	..
	incantation,
	radius=1.8, crater?,
	color, ownerColor?, owner?, shadow=0.5,
	luminous=1, flicker?, glare=0, glareAlpha=1, bloom=3.0, bloomAlpha=0.5,
	depth=Depth:Charger) {

	hook incantation.ChargeProportion {
		Sprite<chargingIndicator>(body, noRotation=true, color=color.WithOpacity(ChargeProportion)) {
			Circle
		}
	}
}
[[tricks/expire.easel]]
pub behavior fn this.ExpireAfterLifetime(lifetime) {
    await Sleep(lifetime)
    Expire
}
[[tricks/hitLimiter.easel]]
field this.NumHitsLookup

pub fn this.TakeHitIfWithinLimit(that, maxHits) {
	if !that { return false }

	const lookup = this.NumHitsLookup ??= {}
	const numHits = lookup[that] ?? 0
	if numHits < maxHits {
		lookup[that] = numHits + 1
		return true
	} else {
		return false
	}
}
[[tricks/homing.easel]]
pub behavior fn this.Homing(prey, .. turnProportion=1, turnRate=1, body) {
	let previousTarget = null
	loop {
		if !Exists(body) { break }

		let target = FindPrey(prey)
		if previousTarget && IsId(prey) && prey.Vanished {
			target = previousTarget
		}
		if !target { break }
		previousTarget = target

		let currentAngle = Angle(body.Velocity)
		let targetAngle = Angle(target - body.Pos)

		body.Velocity = Length(body.Velocity) * Direction(currentAngle + (AngleDelta(currentAngle, targetAngle) * turnProportion).Clamp(-turnRate, turnRate))

		await PhysicsStart
	}
}
[[tricks/poison.easel]]
pub behavior fn this.Poison<Id?>(that, damage, poisonDuration, .. interval=20, lifesteal?, minHealth?, noRelay?, unit?) {
	let damage = damage * interval / poisonDuration
	loop {
		// Must set noHurt and noInterrupt otherwise the enemy will be constantly flashing
		Attack(that, damage, noHurt=true, noInterrupt=true)
		await Sleep(interval)
	}
}
[[tricks/prey.easel]]
pub fn FindPrey(prey) {
	let prey = prey
	if IsFunc(prey) { prey = prey() }
	if IsId(prey) { prey = prey?.Pos }
	return IsVec(prey) ? prey : null
}
[[tricks/proximity.easel]]
pub behavior fn this.Proximity:OnArrival(prey, range=CloseEnough, body) .. {
	loop {
		await Tick

		let prey = FindPrey(prey)
		if !prey { break }

		let thisPos = body?.Pos
		if !thisPos { break }

		let distance = Length(prey - thisPos)
		if distance < range {
			break
		}
	}
	delve()
}

pub behavior fn this.Proximity:OnRetreat(prey, range, body) .. {
	loop {
		await Tick

		let prey = FindPrey(prey)
		if !prey { break }

		let thisPos = body?.Pos
		if !thisPos { break }

		let distance = Length(prey - thisPos)
		if distance > range {
			break
		}
	}
	delve()
}
[[tricks/spray.easel]]
pub await fn Spray(duration, count, spray=0.25revs, step=1) .. headingOffset index {
	// Calculate the angle per division
	let numDivisions = Ceil(count / 2) // Divide by 2 because we allocate half the count to the left and half to the right

	let perDivision = spray / (count - 1)

	let angleOffset = 0.0
	let indexOffset = 0
	if count % 2 {
		// If odd, only shoot to the middle once
		indexOffset = 1
	} else {
		// If even number of shots, the first shots will be separated by half a division
		angleOffset = perDivision / 2.0
	}

	// Fire loop
	let start = Tick()
	for index in Range(0,count) {
		// Wait for the appropriate time to fire the next shot
		let fireStart = start + duration * index / count
		let sleep = Floor(fireStart - Tick)
		// Wait to begin the next repeat
		await Sleep(sleep)

		// Calculate the angle offset
		let sideIndex = Floor((index + indexOffset) / 2) // Half the index since we are doing only the left or right side individually
		let headingOffset = ((step * sideIndex) % numDivisions) * perDivision + angleOffset
		if index % 2 {
			headingOffset = -headingOffset
		} // Go left or right

		// Fire
		delve(headingOffset,index)
	}
}
[[tricks/tether.easel]]
pub signal unit.SeverTethers

pub fn projectile.TetherBuffOnHit(
	..
	unit, owner?,

	depth=Depth:Tether,
	grabbable=(Category:Hero | Category:Obstacle | Category:CanGrab),
	severable=true,
	taper=0,

	color, radius,

	audience?,
	fade?,
	bloom?, bloomAlpha?,
	crater?,
	feather?,
	flicker?,
	glare?, glareAlpha?,
	luminous?,
	ownerColor?,
	shadow?,
	shine?,
	strobe?) [that .. *buff] {
	
	.. body=projectile
	.. segments=1 // Always one segment because if it is more segments it will dissipate over multiple ticks and look weird because it does not stay connected to us

	Tether(projectile, ancestor=unit, radius=, segments=)

	on BeforeCollide that {
		if that != unit && (that.Category & grabbable) {
			delete Tether // Erase the old tether because otherwise we are going to have two
			projectile.Expire // Projectile is consumed as the tether moves from the projectile to the target

			unit.Subspawn buff {
				buff.ExpireWith(that)

				if severable {
					// Need separate IDs so the handlers don't overwrite each other
					once<severThis> unit.SeverTethers { Expire }
					once<severThat> that.SeverTethers { Expire }
				}

				Tether(that, ancestor=unit, strobe=unit, segments=, .. radius audience)

				delve(that)
			}

			break // break so we only attach to one thing then stop
		}
	}
}

// Forces
pub behavior fn this.PullTether(that, attractor, impulse, minDistance=0, maxDistance) {
	loop {
		await Tick

		let thatPos = that?.Pos
		if !thatPos { break }

		let attractorPos = attractor?.Pos
		if !attractorPos { break }

		let delta = attractorPos - thatPos
		let magnitude = ((Length(delta) - minDistance) / Max(0.0001, maxDistance - minDistance)).Mix(0.0, impulse)
		that.ApplyImpulse(magnitude * Direction(delta))
	}
}

pub behavior fn this.TowTether(that, attractor) {
	let thatPos = that?.Pos
	if !thatPos { break }

	let attractorPos = attractor?.Pos
	if !attractorPos { break }

	let maxDistance = Length(attractorPos - thatPos)

	loop {
		await Tick

		let thatPos = that?.Pos
		if !thatPos { break }

		let attractorPos = attractor?.Pos
		if !attractorPos { break }

		let delta = attractorPos - thatPos
		let distance = Length(delta)
		if distance < maxDistance { continue }

		let step = distance - maxDistance
		that.ApplyPositionStep(step * Direction(delta))
	}
}

pub behavior fn this.SwingTether(that, unit, turnProportion, momentumFactor=1) {
	loop {
		await Tick

		let thatPos = that?.Pos
		if !thatPos { break }

		let unitPos = unit?.Pos
		if !unitPos { break }

		let diff = thatPos - unitPos
		let initialAngle = Angle(diff)
		let turn = turnProportion * AngleDelta(initialAngle, unit.Heading)
		let target = unitPos + Direction(initialAngle + turn) * Length(diff)

		let step = target - thatPos
		if Length(step) <= CloseEnough { continue }

		let velocity = that.Velocity

		// Keep some part of the velocity that is orthogonal to the step.
		// This makes the swing build up and feel more natural.
		let orthogonal = RotateRight(Direction(step))
		velocity = (step * TicksPerSecond) + (Dot(velocity, orthogonal) * orthogonal * momentumFactor)
		
		that.ApplyTurningStep(turn)
		that.Velocity = velocity
	}
}
[[tricks/thrust.easel]]
pub behavior fn this.Thrust(prey, speed, body) {
	loop {
		await PhysicsStart

		let prey = FindPrey(prey)
		if !prey { break }

		let pos = body?.Pos
		if !pos { break }

		let diff = prey - pos
		let direction = Direction(diff)
		let distance = Length(diff)
		let step = (direction * speed / TicksPerSecond).Truncate(distance)
		body.ApplyPositionStep(step)

		await PhysicsEnd
		body.Velocity = @(0,0) // Cancel out any knockback during the charge
	}
}
[[tricks/tween.easel]]
field this.TweenStart<Id>

pub await fn Tween(duration, initial=0.0, final=1.0, start=Tick) scale {
	loop {
		let alpha = duration > 0 ? (Tick - start) / duration : 1
		let scale = alpha.Mix(initial, final)
		delve(scale)

		if alpha >= 1.0 { break }
		await Tick
	}
}

pub behavior fn this.Tween<Id?>(duration, initial=0.0, final=1.0) scale {
	let start = this.TweenStart<Id> ??= Tick
	await Tween(.. duration initial final start) scale {
		delve(scale)
	}
}

pub delete fn this.Tween<Id?> {
	delete this.TweenStart<Id>
}
[[tricks/wind.easel]]
pub behavior fn this.Wind(wind, radius, body, .. filter = (Category:Projectile | Category:Obstacle), owner) {
	loop {
		await Tick
		let windVelocity = body.Velocity
		let windDirection = Direction(windVelocity)
		let windSpeed = Length(windVelocity)
		let mass = body.Mass

		let items = QueryColliders.WhereCategory(filter).FindAllWithinRadius(body.Pos, radius)
		for that in items {
			const alliance = Alliance(owner, that)
			if alliance == Alliance:Self | Alliance:Ally {
				if !(that.Category & Category:AlwaysBlow) {
					// Generally do not affect our own team's entities unless has the AlwaysBlow flag
					continue
				}
			} else {
				// Always affect enemy entities
			}

			let speed = Dot(windDirection, that.Velocity)
			if speed < windSpeed {
				let delta = windSpeed - speed
				let acceleration = delta * wind * mass / (mass + that.Mass)
				that.Velocity += acceleration * windDirection
			}
		}
	}
}
