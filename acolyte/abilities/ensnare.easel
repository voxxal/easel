use glyph=@atomicSlashes.svg, color=#0ace00, damage=0.0, cooldown=6s, silenceDuration=0.5s, ensnareDuration=2s

pub symbol WantEnsnare

signal projectile.OnEnsnare(that)

pub fn EnsnareDescription([ui]) {
    H1 { "Ensnare" }

    P {
        "Trap your adversaries in an inescapable vortex of mystic energy, leaving them immobilized. Seize the moment to unleash a barrage of your deadliest abilities as they lay helpless before you."
    }

    SlotEffect("Mystic Silence", icon="fas fa-hourglass-half") {
        "Your enemy will be unable to use their abilities for " + (silenceDuration / TicksPerSecond) + " seconds."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn EnsnareOption([ui]) {
	SlotOption(WantEnsnare) {
        EnsnareDescription
	}
}

pub fn ability.EnsnareAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        EnsnareDescription
    }

	SpawnEachIncantation incantation {
		Spawn projectile {
			use parent=unit, body=projectile
			use lifetime=5s, dissipate=15
			use radius=0.5, aoe=3.6, speed=28
			use luminous=1, layer=Layer:Buff

			ExpireAfterLifetime
			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading))
			Durability = Durability:High
			RecoverSpeed
			DecayTurnRate
			CooldownRate(0)
			Sing(@ensnare.esfx)

			PolygonCollider(
                Circle,
                category=Category:Projectile,
                isSensor=true, collideWith = Category:Unit | Category:Disintegrator,
            )

			behavior<trailSparks> on Paint {
				Spark(
					shine=0.5, feather=1, glare=0.4, bloom=1.5, shadow=0.5,
					speed=5.5, splatter=0.3,
					screenOffset=SwirlOffset(0.2,period=20))
			}

			on BeforeCollide that {
				if that.Owner != owner && that.Category.Overlaps(Category:Unit) {
					ExpireAfterLifetime(lifetime=ensnareDuration) // Re-extend lifetime if we catch something

					that.Silence(silenceDuration)
					that.Tombstone victim {
						PlayerNameDisplay(owner)
						" held "
						PlayerNameDisplay(victim)
						" til the end "
					}

					OnEnsnare(that)
					break // Only catch the first unit that enters the vortex, otherwise could extend lifetime forever
				}
			}
			on AfterCollide that {
				if that.Durability >= this.Durability && !that.Category.Overlaps(Category:Unit) {
					Expire
				}
			}

			// Plant the vortex either when the projectile reaches the cursor or when it catches a unit
			once OnEnsnare that {
				Speed = 0
				DecaySpeed
				Sing(@ensnareTrapping.esfx)

				with Tick {
					for that in QueryWithinRadius(aoe, filter=Category:Unit) {
						ImpulseAwayAttenuated(that, impulse=-5, attenuate=0.4)
					}
				}

				await Tween(duration=5, initial=0.0, final=1.0) factor {
					use aoe = factor * aoe

					behavior<trailSparks> on Paint {
						const numSparks = 3
						for i in Range(0,numSparks) {
							Spark(
								radius=0.5, shadow=0.5, shine=0.5, feather=1, glare=0.4, bloom=1.5,
								speed=5.5, splatter=0.3,
								screenOffset=SwirlOffset(factor * 1.6, period=20, phase=i/numSparks))
						}
					}
				}
			}

            // Must be after `once OnEnsnare` in case so it still works from point blank range
			once Tick(Velocity:TicksTo(Pointer)) {
				OnEnsnare(null)
			}
		}
	}
}