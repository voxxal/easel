use glyph=@divert.svg, color=#00ff44, damage=12, maxHits=8, lifesteal=0.3, cooldown=7.5s


pub symbol WantBouncer

pub fn BouncerDescription([ui]) {
    H1 { "Bouncer" }

    P {
        "Release a pulsing energy orb that oscillates relentlessly between you and your foe, inflicting damage with each successive impact. "
        "Stay close to sustain the perilous waltz that balances the risk of exposure with the promise of persistent punishment. "
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn BouncerOption([ui]) {
	SlotOption(WantBouncer) {
        BouncerDescription
	}
}

pub fn ability.BouncerAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		const triggerDistance=5
		if Cooldown == 0 && Distance(unit.Pos, target) <= triggerDistance {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        BouncerDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier

		Spawn projectile {
			use parent=unit, body=projectile
			use lifetime=3.0s, dissipate=20
			use radius=0.08, speed=50.0
			use ownerColor=Alliance:Self, luminous=1, layer=Layer:Projectile

			on BotChannelling target {
				const chaseDistance=10
				if Distance(projectile.Pos, target) <= chaseDistance {
					BotKeepChannelling
				}
			}

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:High
			RecoverSpeed
			LimitSpeed(1.2*speed)
			DecayTurnRate
			Sing(@bouncer.esfx)
			ExpireAfterLifetime

			once Retreated(unit, range=50) {
				Expire
			}

			PolygonCollider(
                Circle,
                category = Category:Projectile,
                collideWith = Category:Tangible ^ Category:Projectile,
                density=15, restitution=1,
            )

			PolygonSprite(Circle(5*radius), shadow=0.5, glare=1, bloom=1.5, bloomAlpha=1)

			let numHits = 0
			on BeforeCollide that {
				Hear(@bouncerBounce.esfx)
				Strobe(dissipate=10, growth=1.0)

				if CanHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						PlayerNameDisplay(owner)
						" bounced "
						PlayerNameDisplay(victim)
						" out of existence "
					}
				}
			}
			on AfterCollide that {
                if that == unit {
                    Velocity:RedirectTowards(QueryNearest(filter=Category:Unit, against=Alliance:Enemy))
                } else if that.Team != unit.Team {
                    numHits += 1
                    Velocity:RedirectTowards(unit)
                }

				if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team {
					CanHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Category.Overlaps(Category:Projectile) && that.Durability >= this.Durability || numHits >= maxHits {
					Expire
				}
			}

			once BeforeDespawn {
				repeat 10 { Spark(radius=5*radius, shine=0.5, splatter=1, feather=1) }
			}
		}
	}
}