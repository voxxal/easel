use glyph=@arcingBolt.svg, color=#00ff7f
use damage=15, lifesteal=0.3, cooldown=1.5s, bonusProportion=1.0, bonusDuration=1s

pub symbol WantRefract

pub fn RefractDescription([ui]) {
    H1 { "Refract" }

    P {
        "Invoke a vigilant burst of energy that obeys the whims of your will, allowing you to redirect Refract's path of destruction towards your enemies."
    }

    SlotEffect("Refractable Path", icon="fas fa-arrows") {
        "Hold down the button to launch, then release the button to redirect towards your cursor. "
    }

    SlotEffect("Radiance Unleashed", icon="fas fa-sun") {
        "After redirection, Refract grows in power, ramping up to " + (bonusProportion+1) + "x bonus damage after " + (bonusDuration / TicksPerSecond) + " second, so take an indirect path for maximum effect."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn RefractOption([ui]) {
	SlotOption(WantRefract) {
        RefractDescription
	}
}

pub fn ability.RefractAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        RefractDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier

		CooldownRate(0)

		Spawn projectile {
			use parent=unit, body=projectile
			use radius=0.28, speed=32, speedAfterRefract=48
			use lifetime=3s, dissipate=15
			use ownerColor=Alliance:Self, luminous=1, layer=Layer:Projectile

			const birth = Tick

			on BotChannelling target {
				const channelDuration=0.75s

				let age = Tick - birth
				if age < channelDuration {
					BotKeepChannelling
				}
			}

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:Medium
			RecoverSpeed
			DecayTurnRate
			Sing(@refract.esfx)
			ExpireAfterLifetime

			once BeforeDespawn {
				// End the incantation even if the owner is still holding down the button
				// so the cooldown starts ticking again
				incantation.Expire
			}

			PolygonCollider(
                Circle,
                category=Category:Projectile,
                density=166, restitution=1,
            )

			on Paint {
				Streak(bloom=3, bloomAlpha=1, glare=1, shadow=0.25)
				Streak(radius=0.5*radius, bloom=0, glare=0, shadow=0.25, fade=1, screenOffset=HelixOffset(radius=0.6, period=9))
			}

			let releasedTick = false
			once ButtonUp {
				Velocity:RedirectTowards(Pointer, speed=16)
                RecoverSpeed(speed=speedAfterRefract, speedDecay=0.05)
				releasedTick = Tick
			}

			on BeforeCollide that {
				if CanHurtSelf || that.Team != owner.Team {
					const bonusMultiplier = 1 + (releasedTick ? (bonusProportion * ((Tick - releasedTick) / bonusDuration).Min(1)) : 0)
					Attack(that, damage = damage * bonusMultiplier)

					that.Tombstone victim {
						PlayerNameDisplay(owner)
						" illuminated "
						PlayerNameDisplay(victim)
						if releasedTick {
							" with twisted magic "
						}
					}
				}
			}
			on AfterCollide that {
				if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team {
					CanHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=1.0, shine=0.5)
					Spark(radius=1, feather=1, glare=0.3, shine=0.2)
					repeat 10 { Spark(splatter=1, feather=1, shine=0.5) }
					Hear(@refractHit.esfx)
					Expire
				}
			}
		}

		await ButtonUp
	}
}