use glyph=@electricWhip.svg, color=#ffaa00
use damage=20, bonusChargeDuration=0.75s, bonusDamageProportion=0.75, lifesteal=1.0, cooldown=1.5s, lifetime=4, speed=80.0, fastProportion=0.3

const botChaseDistance = speed * lifetime / 1s


pub symbol WantElectroshock

pub fn ElectroshockDescription([ui]) {
    H1 { "Electroshock" }

    P {
        "Shock your enemies at short-range, siphoning away their vitality through the conduit of crackling electricity. "
        "The surge of lightning through your veins also quickens your movement. "
    }

    SlotEffect("Electrostatic Charge", icon="fas fa-bolt") {
        "Hold the button down for up to " + (bonusChargeDuration / 1s) + "s for up to " + (100 * bonusDamageProportion) + "% bonus damage."
    }

    SlotEffect("Surging Swiftness", icon="fas fa-running") {
        "While charging up, you will move " + (fastProportion * 100) + "% faster."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn ElectroshockOption([ui]) {
	SlotOption(WantElectroshock) {
        ElectroshockDescription
	}
}

pub fn ability.ElectroshockAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility

		} else {
			// Chase down our enemies
			BotMoveTo(
				target = target + botChaseDistance * Direction(unit.Pos - target),
				utility = Utility:Minimum)
		}
	}

    AbilityCommandBtn {
        ElectroshockDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier
		let birth = Tick

		await ChargeUntilReleased(1s, minProportion=0) charger {
			ChargingIndicator(flicker=0.3, color=#fffcb1)
			CooldownRate(0)
            SpeedModifier(1 + fastProportion)

            behavior<interruptible> once Interrupt {
                charger.Expire
            }

            behavior<speedBuff> on Paint {
                if Vanished {
                    await Vanished // no sparks when invisible
                } else {
                    Spark(
                        color=color.Fade(0.8), ownerColor=true, luminous=1, shine=0.5,
                        radius=1.0, layer=Layer:Buff,
                        feather=0, fade=1, dissipate=30,
                        speed=5, splatter=1)
                }
            }

            on BotChannelling target {
                // Must aim at our enemy in order to hit them.
                // The bot likes to turn around otherwise and then it misses.
                BotMoveTo(target=)
            }
		}

		// Must capture ChargeProportion here because we are about to overwrite it
		use damage = damage * (1 + bonusDamageProportion * ChargeProportion)

		// Small delay before electroshock gets released
		SpeedModifier(0)
        TurnRateModifier(0)
        await ChargeForDuration(3) {
            ChargingIndicator(color=#fffcb1)
        }

        // Perform the attack
		Hear(@electroshock.esfx)
		Spawn projectile {
			use parent=unit, body=projectile
			use dissipate=30
			use radius=0.4, aoe=1.0, impulse=142
			use color=#fffcb1, luminous=1, layer=Layer:Projectile

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:Medium
			DecayTurnRate
			Movement:WalkWith(unit)
			Strand(unit, projectile, radius=0.5*radius, bloom=2, bloomAlpha=1, glare=1, taper=1, dissipate=5, shadow=0.25)
			ExpireAfterLifetime

			PolygonCollider(
                Circle,
                category=Category:Projectile,
                collideWith = Category:Shield | Category:Obstacle | Category:Disintegrator,
                density=2.8, restitution=1,
            )

			on Paint {
				Spark(feather=1, shine=0.5, splatter=0.15)
			}

			on AfterCollide that {
				if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team {
					CanHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Expire
				}
			}
			once BeforeDespawn {
				Spark(radius=aoe, bloom=3, bloomAlpha=0.5, feather=1, glare=0.3, shine=0.2)
				repeat 7 { Spark(feather=1, shine=0.5, splatter=0.2, flicker=0.25) }
				Hear(@electroshockHit.esfx)

				for that in QueryWithinRadius(aoe, filter=Category:Aoe) {
					if CanHurtSelf || that.Team != owner.Team {
						Attack(that)
						ImpulseAway(that)
						ExpireIfDestructible(that)

						that.Tombstone victim {
							PlayerNameDisplay(owner)
							" zapped "
							PlayerNameDisplay(victim)
						}
					}
				}
			}
		}
	}
}