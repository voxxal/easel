use glyph=@mineExplosion.svg, color=#ff009c, damage=16.0, damageReductionPerHit=0.5, lifesteal=0.3, cooldown=5.0s, armDelay=6, retreatDelay=1s

pub symbol WantEnergyMines

pub fn EnergyMinesDescription([ui]) {
    H1 { "Energy Mines" }

    P {
        "Mark your territory with solid ingots of volatile energy, protecting you from all who dare come too close."
    }

    SlotEffect("Stabilizing Presence", icon="fas fa-anchor") {
        "Your sustained presence stabilizes the mines' volatile energy. Stray too far and they will expire."
    }
    SlotEffect("Arming Delay", icon="fas fa-stopwatch") {
        "Energy mines take a moment to activate and only do damage after " + (armDelay / TicksPerSecond) + "s."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn EnergyMinesOption([ui]) {
	SlotOption(WantEnergyMines) {
        EnergyMinesDescription
	}
}

pub fn ability.EnergyMinesAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        EnergyMinesDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier
	
		TurnRateModifier(0)
		SpeedModifier(0)

		Hear(@minesLaunch.esfx)
		await Spray(duration=5, count=5, spray=0.28revs) headingOffset {
			Spawn projectile {
				use parent=unit, body=projectile
				use lifetime=4.5s, dissipate=15
				use radius=0.32, speed=40.0, impulse=75, aoe=1.2
				use ownerColor=Alliance:Self, bloom=1.5, bloomAlpha=0.3, luminous=1, layer=Layer:Projectile

				Body(pos=parent.Pos, heading=parent.Heading+headingOffset, velocity=speed*Direction(heading), bullet=true)
				Durability = Durability:None
				DecayTurnRate
				ExpireAfterLifetime
                LimitSpeed(1.2*speed)

				PolygonSprite(Circle, shadow=0.5)
				PolygonCollider(
                    Circle,
                    category = Category:Projectile | Category:Aoe | Category:Destructible | Category:AlwaysBlow,
                    sense=Category:Projectile,
                    density=1.5, restitution=0,
                )

				let armed = false
				on BeforeCollide that {
					if that.Durability >= this.Durability && !(that.Owner == this.Owner && !that.Category.Overlaps(Category:Unit)) {
						// Expire on everything unless it is an entity owned by the same player but not the hero.
						// This lets us push mines around with meteors, for example.
						Strobe(shine=1.0)
						Expire
					}
				}

				once BeforeDespawn {
					Spark(radius=1.2, bloom=3, bloomAlpha=0.5, feather=1, glare=0.3, shine=1)
					Hear(@minesHit.esfx)

					for that in QueryWithinRadius(aoe, filter=Category:Aoe) {
						if that.Team != owner.Team {
                            that.StackEffect<mines> stacks {
                                once Tick(2s) { Expire }

                                Attack(that, damage = armed ? (damage * (1-damageReductionPerHit)**stacks) : 0)
                                ImpulseAway(that)
                                ExpireIfDestructible(that)

                                that.Tombstone victim {
                                    PlayerNameDisplay(owner)
                                    " blew "
                                    PlayerNameDisplay(victim)
                                    "'s mined"
                                }
							}
						}
					}
				}

				once Tick(armDelay) {
					armed = true
					Speed = 0
					DecaySpeed
				}

				once Tick(retreatDelay) {
					once Retreated(unit, range=12) {
						Expire
					}
				}
			}
		}
	}
}