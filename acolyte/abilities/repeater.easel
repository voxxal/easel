use glyph=@sonicLightning.svg, color=#00ff00
use damage=12, lifesteal=0.3, cooldown=9s
use rangedBonus=1, rangedDuration=0.4s
use secondHitBonus=0.33, buffDuration=5s

pub symbol WantRepeater

signal ability.RepeaterMiss // signal this on the ability, not the projectile, because repeater projectile will have expired by the time this is sent

pub fn RepeaterDescription([ui]) {
    H1 { "Repeater" }

    P {
        "Upon striking an enemy's soul with the harmonious energy of Repeater, the resulting symphony allows you to immediately unleash another blow, weaving an unyielding chain of attacks."
    }

    SlotEffect("Harmonic Resonance", icon="fas fa-undo") {
        "Each time Repeater hits, its cooldown resets, allowing you to fire it again immediately. "
        "Hitting the same enemy a second time grants " + (secondHitBonus * 100.0) + "% bonus damage. "
    }

    SlotEffect("Soaring Crescendo", icon="fas fa-chart-line") {
        "Damage increases with range, building up to " + (rangedBonus+1) + "x bonus damage after " + (rangedDuration / TicksPerSecond) + " seconds."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn RepeaterOption([ui]) {
	SlotOption(WantRepeater) {
        RepeaterDescription
	}
}

pub fn ability.RepeaterAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        RepeaterDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier

		TurnRateModifier(0)
		await ChargeForDuration(3) {
			ChargingIndicator
		}

		Spawn projectile {
			use parent=unit, body=projectile
			use lifetime=1s, dissipate=18
			use maxStacks=2
			use radius=0.16, speed=64
			use luminous=1, layer=Layer:Projectile

			const birth = Tick

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:Medium
			RecoverSpeed
			DecayTurnRate
			Sing(@repeater.esfx)
			ExpireAfterLifetime

			PolygonCollider(
                Circle,
                category = Category:Projectile,
                collideWith = Category:Tangible ^ Category:Projectile,
                density=14, restitution=1,
            )

			let hit = false
			once BeforeDespawn {
				if !hit {
					RepeaterMiss
				}
			}

		   	on Paint {
				Streak(radius=0.5*radius, dissipate=12, bloom=3, bloomAlpha=1, glare=1, shadow=0.25)

				if Tick % 2 == 0 { // every second tick
					Spark(shadow=0.5, radius=4.0*radius, feather=1, shine=0.5)
				}
			}

			on BeforeCollide that {
				if CanHurtSelf || that.Team != owner.Team {
					// Only reset on units that are owned by a owner, not neutrals
					if that.Category.Overlaps(Category:Unit) && that.Team && (that.Team != owner.Team) {
						hit = true
						Cooldown = 0
						Hear(@repeaterSuccess.esfx)
						that.StackEffect<repeater>(cleansable=true, maxStacks=1) stacks {
							use body = that
							ExpireAfterLifetime(lifetime=buffDuration)

							const secondHitMultiplier = 1 + stacks * secondHitBonus
							const rangedMultiplier = 1 + rangedBonus * ((Tick - birth) / rangedDuration).Min(1.0)
							Attack(that, damage = damage * rangedMultiplier * secondHitMultiplier)

							once RepeaterMiss { // miss once and the buff expires too
								Expire
							}

							with that.Vanished {
                                if that.Vanished {
                                    delete PolygonSprite<mark>
                                } else {
                                    PolygonSprite<mark>(shape=Circle(0), audience=owner, bloom=4, bloomAlpha=0.5, layer=Layer:Bloom)
                                }
							}

							that.Tombstone victim {
								PlayerNameDisplay(owner)
								" orchestrated "
								PlayerNameDisplay(victim)
								"'s final refrain"
								if stacks > 0 {
									" again and again"
								}
							}
						}
					} else {
						Attack(that)
					}
				}
			}
			on AfterCollide that {
				if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team {
					CanHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=1, shine=1.0)
					repeat 5 { Spark(splatter=1, feather=1, shine=0.5) }
					Expire
				}
			}
		}
	}
}