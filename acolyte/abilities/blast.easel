use glyph=@fireRay.svg, color=#00ffff, damage=40.0, lifesteal=0.3, cooldown=5.0s

pub symbol WantBlast

pub fn BlastDescription([ui]) {
    H1 { "Acolyte Blast" }

    P {
        "Concentrate your inner reserves, unleashing a cataclysmic force proportional to the time spent in focused meditation. "
    }

    SlotEffect("Luminous Convergence", icon="fas fa-sun") {
        "Hold the button to charge up your blast, and feel the pulsating layers of energy coalesce with each moment of pure concentration."
    }
    SlotEffect("Interruptible", icon="fas fa-hand-paper") {
        "A single blow can shatter your concentration, dissipating the accumulated energy and leaving your devastating assault unfulfilled."
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn BlastOption([ui]) {
	SlotOption(WantBlast) {
        BlastDescription
	}
}

pub fn ability.BlastAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        BlastDescription
    }

	SpawnEachIncantation incantation {
		use ownerColor=true, damage = damage * unit.DamageModifier
		let birth = Tick

		SpeedModifier(0.5)

		once Interrupt { incantation.Expire }

		if !GameCommenced {
			// Disallow pre-game charging to count during the real game
			once AfterGameCommenced { incantation.Expire }
		}

		on BotChannelling target {
			const channelDuration=1.0s
			if Tick - birth < channelDuration {
				BotKeepChannelling
			}
		}

		Sing(@blastCharging.esfx)
		await ChargeUntilReleased(2.0s, minProportion=0.1) {
			ChargingIndicator(flicker=0.1)
			CooldownRate(0)
		}

		Spawn projectile {
			use parent=unit, body=projectile
			use damage = damage * ChargeProportion
			use radius = ChargeProportion.Mix(0.3, 1.2), speed=40.0
			use aoe=2, impulse = 70 * ChargeProportion
			use lifetime=2s, dissipate=10
			use luminous=1, layer=Layer:Projectile
			use feather=1, glare=0.5

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:Maximum
			RecoverSpeed
			DecayTurnRate
			Sing(@blast.esfx)
			ExpireAfterLifetime

			PolygonCollider(
                Circle,
                category = Category:Projectile | Category:Disintegrator,
                density = 140 * ChargeProportion, restitution=1,
			)

			PolygonSprite(shape=Circle(0), bloom=10*ChargeProportion, bloomAlpha=1, layer=Layer:Bloom)

			on Paint {
				Spark(radius=2*radius, shine=0.5, shadow=0.5, splatter=0.5) // larger radius needed to compensate for feather=1 making it look smaller
			}

			on BeforeCollide that {
				if CanHurtSelf || that.Team != owner.Team {
					Attack(that)

					that.Tombstone victim {
						PlayerNameDisplay(owner)
						" farewelled "
						PlayerNameDisplay(victim)
						" with a bang "
					}
				}
			}
			on AfterCollide that {
				if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team  {
					CanHurtSelf = true // Can bounce off shield to hurt self
				}
				if that.Durability >= this.Durability {
					Strobe(growth=0.5)
					Hear(@blastHit.esfx)
					Expire
				}
			}
			once BeforeDespawn {
				repeat 3 { Spark(radius=2*radius, shine=0.5, splatter=1) }
				for that in QueryWithinRadius(aoe, filter=Category:Aoe) {
					if that.Team != owner.Team {
						ImpulseAway(that)
						ExpireIfDestructible(that)
					}
				}
			}
		}
	}
}