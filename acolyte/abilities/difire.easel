use glyph=@crossedSlashes.svg, color=#ff0088, damage=20.0
use numBolts=2, buffDuration=1.75s, lifesteal=0.3, cooldown=1.5s

pub symbol WantDifire

pub fn DifireDescription([ui]) {
    H1 { "Difire" }

    P {
        "Unleash twin bolts of scorching flame that ignite and inflict a prolonged burn. Additional Difire bolts intensify the burn, but only if used before the flames subside."
    }

    SlotEffect("Stacking Burn", icon="fas fa-fire") {
        const boltDps = damage / (buffDuration / TicksPerSecond) / numBolts
        "Each bolt of Difire will add another stack of " + boltDps + " damage per second to your enemy. "
        "You must hit them with Difire at least once every " + (buffDuration / TicksPerSecond) + " seconds to keep the fire burning. "
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Lifesteal", icon="fas fa-circle-plus") { %((lifesteal * 100.0) + "%") }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn DifireOption([ui]) {
	SlotOption(WantDifire) {
        DifireDescription
	}
}

pub fn ability.DifireAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        DifireDescription
    }

	SpawnEachIncantation incantation {
		use damage = damage * unit.DamageModifier

		await Spray(duration=1, count=numBolts, spray=0.25revs) headingOffset {
			use damage = damage / count

			Spawn projectile {
				use parent=unit, body=projectile
				use lifetime=1.5s, dissipate=15
				use radius=0.2, initialSpeed=60, speed=40
				use luminous=1, layer=Layer:Projectile

				const initialCursor = Pointer

				Body(pos=parent.Pos, heading=parent.Heading+headingOffset, velocity=initialSpeed*Direction(heading), bullet=true)
				Durability = Durability:Medium
                RecoverSpeed
                DecayTurnRate
				Sing(@difire.esfx)
				ExpireAfterLifetime

				once Tick(2) {
					Velocity:RedirectTowards(initialCursor, speed=)
				}

				PolygonCollider(
                    Circle,
                    category=Category:Projectile,
                    density=10, restitution=1,
                )

				on Paint {
					Streak(dissipate=8, bloom=3, bloomAlpha=1, glare=1, shadow=0.25)
				}

				on BeforeCollide that {
					if CanHurtSelf || that.Team != owner.Team {
						Attack(that, damage=0) // All damage is done by Poison, not this - this is to do other things like interrupt the enemy
						if that.HasHp {
							that.StackEffect<burning>(cleansable=true, maxStacks=(that.Category.Overlaps(Category:Unit) ? 99 : 0)) stacks {
								use body=that

								ExpireAfterLifetime(lifetime=buffDuration)
								Poison(that, damage=(stacks + 1)*damage, duration=buffDuration)

								on Paint {
								    if that.Invisibility {
								        await that.Invisibility
								    } else {
                                        Spark(
                                            radius=1.0, shine=0.5, feather=1, layer=Layer:Spark,
                                            color=color.WithOpacity(0.15 + 0.1 * stacks), fade=1,
                                            speed=12, splatter=1,
                                            glaze=1)
                                    }
								}

								that.Tombstone victim {
									PlayerNameDisplay(owner)
									" ignited "
									PlayerNameDisplay(victim)
									if stacks > 0 {
										" and watched them burn "
									}
								}
							}
						}
					}
				}
				on AfterCollide that {
					if that.Category.Overlaps(Category:Shield) && that.Team != owner.Team  {
						CanHurtSelf = true // Can bounce off shield to hurt self
					}
					if that.Durability >= this.Durability && !(that.Category.Overlaps(Category:Projectile) && (that.Owner == this.Owner)) {
						Strobe(shine=1.0)
						Hear(@difireHit.esfx)
						repeat 5 { Spark(splatter=1, feather=1, shine=0.5, dissipate=30) }
						Expire
					}
				}
			}
		}
	}
}