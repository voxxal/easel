use glyph=@teleport.svg, color=#2200ff, cooldown=10s, teleportDelay=0.25s, interruptCooldown=0.75s, maxDistance=48

pub symbol WantTeleport

pub fn TeleportDescription([ui]) {
    H1 { "Teleport" }

    P {
        "Master the art of instantaneous travel with Teleport, allowing you to transport yourself to a chosen destination after " + (teleportDelay / TicksPerSecond) + " seconds of concentration. "
    }

    SlotEffect("Interruptible", icon="fas fa-hand-paper") {
        "Any disturbance during the teleportation process will cause it to fail, forcing you to wait for " + (interruptCooldown / TicksPerSecond) + "s before attempting another escape. "
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn TeleportOption([ui]) {
	SlotOption(WantTeleport) {
        TeleportDescription
	}
}

pub fn ability.TeleportAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	with IsInLava {
		CooldownRate(IsInLava ? 2 : 1)
	}

	on BotRecovering target {
		if Cooldown == 0 {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        TeleportDescription
    }

	SpawnEachIncantation incantation {
		use radius=1.0, indicatorRadius=3.0
		use luminous=1, layer=Layer:Projectile, dissipate=20

		const target = Pointer

		SpeedModifier(0)
		TurnRateModifier(0)
		CooldownRate(0)

		on Interrupt interruptor {
			if interruptor.Overlaps(Interruptor:NotSelf) {
				Cooldown = interruptCooldown
				incantation.Expire
			}
		}

		await ChargeForDuration(teleportDelay) {
			Sing(@teleportCharging.esfx)
			with ChargeProportion {
				PolygonSprite(
					Circle(radius=ChargeProportion.Mix(indicatorRadius, radius)),
					crater=0.7, bloom=3, feather=0.5, shadow=0.25, flicker=ChargeProportion.Mix(0.0, 0.5))
			}
		}

		Hear(@teleportDeparting.esfx)
		CleanseEffects
		UngrabMe
		UngrabThem

		ApplyTeleport(target, maxDistance=, blockFilter=Category:Shield, against=Alliance:Enemy)

		Hear(@teleportArriving.esfx)
		Spark(radius=indicatorRadius, crater=0.7, bloom=3, bloomAlpha=0.5, feather=1, glare=0.3, shine=0.2)
	}
}

fn body.ApplyTeleport(target, maxDistance=null, against=Alliance:All, blockFilter=Category:None, [owner]) {
	let step = target - body.Pos
	let direction = Direction(step)
	let distance = Length(step).Min(maxDistance)

	if blockFilter {
		let found, foundDistance = QueryNearestAlongRay(direction, maxDistance=distance, filter=blockFilter, against=)
		distance = Min(distance, foundDistance)
	}

	body.Pos = body.Pos + distance * direction
}