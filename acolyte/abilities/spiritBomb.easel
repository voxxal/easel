use glyph=@mightyForce.svg, color=#ff0099, damage=0, cooldown=5s

pub symbol WantSpiritBomb

// Constants for the bot
const LeashRange = 12
const LeashSlack = 4

pub fn SpiritBombDescription([ui]) {
    H1 { "Spirit Bomb" }

    P {
        "Summon forth a malleable speck of energy, bending it to your will as you steer it relentlessly towards your adversaries. "
    }

    SlotEffect("Purposeful Path", icon="fas fa-arrows") {
        "Move your cursor to guide the path of Spirit Bomb. You are unable to move while channelling Spirit Bomb."
    }
    SlotEffect("Mindful Ignition", icon="fas fa-bullseye") {
        "Cast Spirit Bomb again to detonate at exactly the right moment. "
    }

    Blank(expand=true)

    SlotStats {
        SlotStat("Damage", icon="fas fa-heart-crack") { %(damage) }
        SlotStat("Cooldown", icon="fas fa-clock") { %((cooldown / TicksPerSecond) + "s") }
    }
}

pub fn SpiritBombOption([ui]) {
	SlotOption(WantSpiritBomb) {
        SpiritBombDescription
	}
}

pub fn ability.SpiritBombAbility([unit, owner, keycode, btnEdit?, btnOrder?, btnSize?]) {
    use body=unit, life=unit

	on BotAttacking target {
		if Cooldown == 0 && Distance(target, unit.Pos) <= LeashRange {
			BotUseAbility
		}
	}

    AbilityCommandBtn {
        SpiritBombDescription
    }

	SpawnEachIncantation incantation {
		use lifetime=2.25s

		SpeedModifier(0.05)
		CooldownRate(0)

		Subspawn projectile {
			use parent=unit, body=projectile
			use dissipate=20, impulse=570, radius=0.4, aoe=2.25, speed=17.5, turnProportion=0.012
			use ownerColor=true, luminous=1, layer=Layer:Projectile

			let leash = LeashRange
			on BotChannelling target {
				const distance = Distance(projectile.Pos, target)
				leash = Min(leash, distance) // Tighten the leash as the spirit bomb gets closer
				if distance > aoe && distance < leash + LeashSlack { // Keep channelling until within explosion range or until we've missed by too much
					BotKeepChannelling
				}
			}

			Body(pos=parent.Pos, heading=parent.Heading, velocity=speed*Direction(heading), bullet=true)
			Durability = Durability:Medium
			RecoverSpeed
			DecayTurnRate
			PolygonSprite(shape=Circle(0), bloom=4, bloomAlpha=1, layer=Layer:Bloom)
			Sing(@spiritBomb.esfx)

			with Pointer {
				Homing(Pointer, turnRate=0.006rev)
			}

			PolygonCollider(
                Circle,
                category=Category:Projectile,
                density=1.5, restitution=1,
            )

			on Paint {
				Spark(dissipate=5, splatter=0.5, feather=1, glare=0.2, shine=0.5)
			}

			on AfterCollide that {
				if that.Durability >= this.Durability {
					Strobe(growth=0.5, shine=1.0)
					repeat 10 { Spark(splatter=1, feather=1, shine=0.5) }
					Expire
				}
			}

			once Interrupt {
				Expire
			}

			await Tween(duration=1.0s, initial=0.5, final=1.0) factor {
				use aoe = aoe * factor

				PolygonSprite(shape=Circle(aoe), color=color.Fade(0.95), crater=0.85, layer=Layer:Indicator)
				once BeforeDespawn {
					repeat 10 { Spark(speed=10, feather=1, shine=0.5) }
					Spark(radius=aoe, bloom=3, bloomAlpha=0.5, feather=1, glare=0.3, shine=0.2)
					Hear(@spiritBombExplode.esfx)

					for that in QueryWithinRadius(aoe, filter=Category:Aoe) {
						if that.Team != owner.Team {
							Attack(that)
							ImpulseAwayAttenuated(that, impulse=, attenuate=0.75)
							ExpireIfDestructible(that)

							that.Tombstone victim {
								PlayerNameDisplay(owner)
								" banished "
								PlayerNameDisplay(victim)
								" to the spirit world "
							}
						}
					}

					incantation.Expire
				}
			}
		}

		await Tick(lifetime)
	}
}