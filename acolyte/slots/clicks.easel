pub symbol LeftClickSlot
pub symbol RightClickSlot

pub symbol WantNoBinding
pub symbol WantMoveBinding

const LeftClickDefault=KeyQ
const RightClickDefault=KeyA

field unit.PreviousBinding

pub fn unit.ClickBinding([owner]) {
    // Need to hook to both click slots because click-to-move could be on either
    with SlotChoice<LeftClickSlot>, SlotChoice<RightClickSlot> {
        // Destroy previous ability
		unit.PreviousBinding?.Despawn

        // Create new ability
		unit.PreviousBinding = Subspawn ability {
            const left = SlotChoice<LeftClickSlot> ?? LeftClickDefault
            const right = SlotChoice<RightClickSlot> ?? RightClickDefault

            if left == WantMoveBinding {
                ClickToMoveAbility(keycode=Click)
            } else if right == WantMoveBinding {
                ClickToMoveAbility(keycode=SecondaryClick)
            } else {
                FollowCursorAbility
            }

            if IsKeycode(left) {
                ButtonRemap<left>(Click, left)
            } else {
                delete ButtonRemap<left>
            }

            if IsKeycode(right) {
                ButtonRemap<right>([SecondaryClick, DoubleTap], right)
            } else {
                delete ButtonRemap<right>
            }
		}
    }
}

pub fn this.LeftClickEditor([owner, ui]) {
    SlotDropdown<LeftClickSlot>(slotDefault=LeftClickDefault) {
        ClickEditor
	}
}
pub fn this.RightClickEditor([owner, ui]) {
	SlotDropdown<RightClickSlot>(slotDefault=RightClickDefault) {
        ClickEditor
	}
}

fn ClickEditor([ui]) {
    DropdownOption(WantNoBinding, "Do Nothing")
    DropdownOption(WantMoveBinding, "Move")
    DropdownOption(KeyQ, "Primary Attack")
    DropdownOption(KeyW, "Special Ability")
    DropdownOption(KeyE, "Defensive Ability")
    DropdownOption(KeyR, "Ultimate Ability")
    DropdownOption(KeyF, "Melee Ability")
    DropdownOption(KeyA, "Dash")
}

fn ability.ClickToMoveAbility([unit, owner, keycode]) {
    use body=unit

	on ButtonDown {
        behavior<followCursor> with Pointer {
            Movement:WalkTo(Pointer)
        }
	}

	on ButtonUp {
	    delete behavior<followCursor>
	}
}